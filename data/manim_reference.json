{
  "modules": {},
  "key_classes": {
    "Scene": {
      "module": "manim.scene.scene",
      "summary": "A Scene is the canvas of your animation.",
      "bases": [],
      "methods": {
        "__deepcopy__": {
          "signature": "__deepcopy__(clone_from_id)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__init__": {
          "signature": "__init__(renderer=None, camera_class=<class 'manim.camera.camera.Camera'>, always_update_mobjects=False, random_seed=None, skip_animations=False)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__str__": {
          "signature": "__str__()",
          "summary": "Return str(self).",
          "doc": "Return str(self)."
        },
        "add": {
          "signature": "add(mobjects)",
          "summary": "Mobjects will be displayed, from background to",
          "doc": "Mobjects will be displayed, from background to\nforeground in the order with which they are added.\n\nParameters\n---------\n*mobjects\n    Mobjects to add.\n\nReturns\n-------\nScene\n    The same scene after adding the Mobjects in."
        },
        "add_foreground_mobject": {
          "signature": "add_foreground_mobject(mobject)",
          "summary": "Adds a single mobject to the foreground, and internally to the list",
          "doc": "Adds a single mobject to the foreground, and internally to the list\nforeground_mobjects, and mobjects.\n\nParameters\n----------\nmobject\n    The Mobject to add to the foreground.\n\nReturns\n------\nScene\n    The Scene, with the foreground mobject added."
        },
        "add_foreground_mobjects": {
          "signature": "add_foreground_mobjects(mobjects)",
          "summary": "Adds mobjects to the foreground, and internally to the list",
          "doc": "Adds mobjects to the foreground, and internally to the list\nforeground_mobjects, and mobjects.\n\nParameters\n----------\n*mobjects\n    The Mobjects to add to the foreground.\n\nReturns\n------\nScene\n    The Scene, with the foreground mobjects added."
        },
        "add_mobjects_from_animations": {
          "signature": "add_mobjects_from_animations(animations)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_sound": {
          "signature": "add_sound(sound_file, time_offset=0, gain=None, kwargs)",
          "summary": "This method is used to add a sound to the animation.",
          "doc": "This method is used to add a sound to the animation.\n\nParameters\n----------\n\nsound_file\n    The path to the sound file.\ntime_offset\n    The offset in the sound file after which\n    the sound can be played.\ngain\n    Amplification of the sound.\n\nExamples\n--------\n.. manim:: SoundExample\n    :no_autoplay:\n\n    class SoundExample(Scene):\n        # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n        def construct(self):\n            dot = Dot().set_color(GREEN)\n            self.add_sound(\"click.wav\")\n            self.add(dot)\n            self.wait()\n            self.add_sound(\"click.wav\")\n            dot.set_color(BLUE)\n            self.wait()\n            self.add_sound(\"click.wav\")\n            dot.set_color(RED)\n            self.wait()\n\nDownload the resource for the previous example `here <https://github.com/ManimCommunity/manim/blob/main/docs/source/_static/click.wav>`_ ."
        },
        "add_subcaption": {
          "signature": "add_subcaption(content, duration=1, offset=0)",
          "summary": "Adds an entry in the corresponding subcaption file",
          "doc": "Adds an entry in the corresponding subcaption file\nat the current time stamp.\n\nThe current time stamp is obtained from ``Scene.time``.\n\nParameters\n----------\n\ncontent\n    The subcaption content.\nduration\n    The duration (in seconds) for which the subcaption is shown.\noffset\n    This offset (in seconds) is added to the starting time stamp\n    of the subcaption.\n\nExamples\n--------\n\nThis example illustrates both possibilities for adding\nsubcaptions to Manimations::\n\n    class SubcaptionExample(Scene):\n        def construct(self):\n            square = Square()\n            circle = Circle()\n\n            # first option: via the add_subcaption method\n            self.add_subcaption(\"Hello square!\", duration=1)\n            self.play(Create(square))\n\n            # second option: within the call to Scene.play\n            self.play(\n                Transform(square, circle), subcaption=\"The square transforms.\"\n            )"
        },
        "add_updater": {
          "signature": "add_updater(func)",
          "summary": "Add an update function to the scene.",
          "doc": "Add an update function to the scene.\n\nThe scene updater functions are run every frame,\nand they are the last type of updaters to run.\n\n.. WARNING::\n\n    When using the Cairo renderer, scene updaters that\n    modify mobjects are not detected in the same way\n    that mobject updaters are. To be more concrete,\n    a mobject only modified via a scene updater will\n    not necessarily be added to the list of *moving\n    mobjects* and thus might not be updated every frame.\n\n    TL;DR: Use mobject updaters to update mobjects.\n\nParameters\n----------\nfunc\n    The updater function. It takes a float, which is the\n    time difference since the last update (usually equal\n    to the frame rate).\n\nSee also\n--------\n:meth:`.Scene.remove_updater`\n:meth:`.Scene.update_self`"
        },
        "begin_animations": {
          "signature": "begin_animations()",
          "summary": "Start the animations of the scene.",
          "doc": "Start the animations of the scene."
        },
        "bring_to_back": {
          "signature": "bring_to_back(mobjects)",
          "summary": "Removes the mobject from the scene and",
          "doc": "Removes the mobject from the scene and\nadds them to the back of the scene.\n\nParameters\n----------\n*mobjects\n    The mobject(s) to push to the back of the scene.\n\nReturns\n------\nScene\n    The Scene, with the mobjects pushed to the back\n    of the scene."
        },
        "bring_to_front": {
          "signature": "bring_to_front(mobjects)",
          "summary": "Adds the passed mobjects to the scene again,",
          "doc": "Adds the passed mobjects to the scene again,\npushing them to he front of the scene.\n\nParameters\n----------\n*mobjects\n    The mobject(s) to bring to the front of the scene.\n\nReturns\n------\nScene\n    The Scene, with the mobjects brought to the front\n    of the scene."
        },
        "check_interactive_embed_is_valid": {
          "signature": "check_interactive_embed_is_valid()",
          "summary": "No documentation available.",
          "doc": null
        },
        "clear": {
          "signature": "clear()",
          "summary": "Removes all mobjects present in self.mobjects",
          "doc": "Removes all mobjects present in self.mobjects\nand self.foreground_mobjects from the scene.\n\nReturns\n------\nScene\n    The Scene, with all of its mobjects in\n    self.mobjects and self.foreground_mobjects\n    removed."
        },
        "compile_animation_data": {
          "signature": "compile_animation_data(animations, play_kwargs)",
          "summary": "Given a list of animations, compile the corresponding",
          "doc": "Given a list of animations, compile the corresponding\nstatic and moving mobjects, and gather the animation durations.\n\nThis also begins the animations.\n\nParameters\n----------\nanimations\n    Animation or mobject with mobject method and params\nplay_kwargs\n    Named parameters affecting what was passed in ``animations``,\n    e.g. ``run_time``, ``lag_ratio`` and so on.\n\nReturns\n-------\nself, None\n    None if there is nothing to play, or self otherwise."
        },
        "compile_animations": {
          "signature": "compile_animations(args, kwargs)",
          "summary": "Creates _MethodAnimations from any _AnimationBuilders and updates animation",
          "doc": "Creates _MethodAnimations from any _AnimationBuilders and updates animation\nkwargs with kwargs passed to play().\n\nParameters\n----------\n*args\n    Animations to be played.\n**kwargs\n    Configuration for the call to play().\n\nReturns\n-------\nTuple[:class:`Animation`]\n    Animations to be played."
        },
        "construct": {
          "signature": "construct()",
          "summary": "Add content to the Scene.",
          "doc": "Add content to the Scene.\n\nFrom within :meth:`Scene.construct`, display mobjects on screen by calling\n:meth:`Scene.add` and remove them from screen by calling :meth:`Scene.remove`.\nAll mobjects currently on screen are kept in :attr:`Scene.mobjects`.  Play\nanimations by calling :meth:`Scene.play`.\n\nNotes\n-----\nInitialization code should go in :meth:`Scene.setup`.  Termination code should\ngo in :meth:`Scene.tear_down`.\n\nExamples\n--------\nA typical manim script includes a class derived from :class:`Scene` with an\noverridden :meth:`Scene.construct` method:\n\n.. code-block:: python\n\n    class MyScene(Scene):\n        def construct(self):\n            self.play(Write(Text(\"Hello World!\")))\n\nSee Also\n--------\n:meth:`Scene.setup`\n:meth:`Scene.render`\n:meth:`Scene.tear_down`"
        },
        "embed": {
          "signature": "embed()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_attrs": {
          "signature": "get_attrs(keys)",
          "summary": "Gets attributes of a scene given the attribute's identifier/name.",
          "doc": "Gets attributes of a scene given the attribute's identifier/name.\n\nParameters\n----------\n*keys\n    Name(s) of the argument(s) to return the attribute of.\n\nReturns\n-------\nlist\n    List of attributes of the passed identifiers."
        },
        "get_mobject_family_members": {
          "signature": "get_mobject_family_members()",
          "summary": "Returns list of family-members of all mobjects in scene.",
          "doc": "Returns list of family-members of all mobjects in scene.\nIf a Circle() and a VGroup(Rectangle(),Triangle()) were added,\nit returns not only the Circle(), Rectangle() and Triangle(), but\nalso the VGroup() object.\n\nReturns\n-------\nlist\n    List of mobject family members."
        },
        "get_moving_and_static_mobjects": {
          "signature": "get_moving_and_static_mobjects(animations)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_moving_mobjects": {
          "signature": "get_moving_mobjects(animations)",
          "summary": "Gets all moving mobjects in the passed animation(s).",
          "doc": "Gets all moving mobjects in the passed animation(s).\n\nParameters\n----------\n*animations\n    The animations to check for moving mobjects.\n\nReturns\n------\nlist\n    The list of mobjects that could be moving in\n    the Animation(s)"
        },
        "get_restructured_mobject_list": {
          "signature": "get_restructured_mobject_list(mobjects, to_remove)",
          "summary": "Given a list of mobjects and a list of mobjects to be removed, this",
          "doc": "Given a list of mobjects and a list of mobjects to be removed, this\nfilters out the removable mobjects from the list of mobjects.\n\nParameters\n----------\n\nmobjects\n    The Mobjects to check.\n\nto_remove\n    The list of mobjects to remove.\n\nReturns\n-------\nlist\n    The list of mobjects with the mobjects to remove removed."
        },
        "get_run_time": {
          "signature": "get_run_time(animations)",
          "summary": "Gets the total run time for a list of animations.",
          "doc": "Gets the total run time for a list of animations.\n\nParameters\n----------\nanimations\n    A list of the animations whose total\n    ``run_time`` is to be calculated.\n\nReturns\n-------\nfloat\n    The total ``run_time`` of all of the animations in the list."
        },
        "get_time_progression": {
          "signature": "get_time_progression(run_time, description, n_iterations=None, override_skip_animations=False)",
          "summary": "You will hardly use this when making your own animations.",
          "doc": "You will hardly use this when making your own animations.\nThis method is for Manim's internal use.\n\nReturns a CommandLine ProgressBar whose ``fill_time``\nis dependent on the ``run_time`` of an animation,\nthe iterations to perform in that animation\nand a bool saying whether or not to consider\nthe skipped animations.\n\nParameters\n----------\nrun_time\n    The ``run_time`` of the animation.\n\nn_iterations\n    The number of iterations in the animation.\n\noverride_skip_animations\n    Whether or not to show skipped animations in the progress bar.\n\nReturns\n-------\ntime_progression\n    The CommandLine Progress Bar."
        },
        "get_top_level_mobjects": {
          "signature": "get_top_level_mobjects()",
          "summary": "Returns all mobjects which are not submobjects.",
          "doc": "Returns all mobjects which are not submobjects.\n\nReturns\n-------\nlist\n    List of top level mobjects."
        },
        "interact": {
          "signature": "interact(shell, keyboard_thread)",
          "summary": "No documentation available.",
          "doc": null
        },
        "interactive_embed": {
          "signature": "interactive_embed()",
          "summary": "Like embed(), but allows for screen interaction.",
          "doc": "Like embed(), but allows for screen interaction."
        },
        "is_current_animation_frozen_frame": {
          "signature": "is_current_animation_frozen_frame()",
          "summary": "Returns whether the current animation produces a static frame (generally a Wait).",
          "doc": "Returns whether the current animation produces a static frame (generally a Wait)."
        },
        "mouse_drag_orbit_controls": {
          "signature": "mouse_drag_orbit_controls(point, d_point, buttons, modifiers)",
          "summary": "No documentation available.",
          "doc": null
        },
        "mouse_scroll_orbit_controls": {
          "signature": "mouse_scroll_orbit_controls(point, offset)",
          "summary": "No documentation available.",
          "doc": null
        },
        "next_section": {
          "signature": "next_section(name='unnamed', section_type='DefaultSectionType.NORMAL', skip_animations=False)",
          "summary": "Create separation here; the last section gets finished and a new one gets created.",
          "doc": "Create separation here; the last section gets finished and a new one gets created.\n``skip_animations`` skips the rendering of all animations in this section.\nRefer to :doc:`the documentation</tutorials/output_and_config>` on how to use sections."
        },
        "on_key_press": {
          "signature": "on_key_press(symbol, modifiers)",
          "summary": "No documentation available.",
          "doc": null
        },
        "on_key_release": {
          "signature": "on_key_release(symbol, modifiers)",
          "summary": "No documentation available.",
          "doc": null
        },
        "on_mouse_drag": {
          "signature": "on_mouse_drag(point, d_point, buttons, modifiers)",
          "summary": "No documentation available.",
          "doc": null
        },
        "on_mouse_motion": {
          "signature": "on_mouse_motion(point, d_point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "on_mouse_press": {
          "signature": "on_mouse_press(point, button, modifiers)",
          "summary": "No documentation available.",
          "doc": null
        },
        "on_mouse_scroll": {
          "signature": "on_mouse_scroll(point, offset)",
          "summary": "No documentation available.",
          "doc": null
        },
        "pause": {
          "signature": "pause(duration=1.0)",
          "summary": "Pauses the scene (i.e., displays a frozen frame).",
          "doc": "Pauses the scene (i.e., displays a frozen frame).\n\nThis is an alias for :meth:`.wait` with ``frozen_frame``\nset to ``True``.\n\nParameters\n----------\nduration\n    The duration of the pause.\n\nSee also\n--------\n:meth:`.wait`, :class:`.Wait`"
        },
        "play": {
          "signature": "play(args, subcaption=None, subcaption_duration=None, subcaption_offset=0, kwargs)",
          "summary": "Plays an animation in this scene.",
          "doc": "Plays an animation in this scene.\n\nParameters\n----------\n\nargs\n    Animations to be played.\nsubcaption\n    The content of the external subcaption that should\n    be added during the animation.\nsubcaption_duration\n    The duration for which the specified subcaption is\n    added. If ``None`` (the default), the run time of the\n    animation is taken.\nsubcaption_offset\n    An offset (in seconds) for the start time of the\n    added subcaption.\nkwargs\n    All other keywords are passed to the renderer."
        },
        "play_internal": {
          "signature": "play_internal(skip_rendering=False)",
          "summary": "This method is used to prep the animations for rendering,",
          "doc": "This method is used to prep the animations for rendering,\napply the arguments and parameters required to them,\nrender them, and write them to the video file.\n\nParameters\n----------\nskip_rendering\n    Whether the rendering should be skipped, by default False"
        },
        "remove": {
          "signature": "remove(mobjects)",
          "summary": "Removes mobjects in the passed list of mobjects",
          "doc": "Removes mobjects in the passed list of mobjects\nfrom the scene and the foreground, by removing them\nfrom \"mobjects\" and \"foreground_mobjects\"\n\nParameters\n----------\n*mobjects\n    The mobjects to remove."
        },
        "remove_foreground_mobject": {
          "signature": "remove_foreground_mobject(mobject)",
          "summary": "Removes a single mobject from the foreground, and internally from the list",
          "doc": "Removes a single mobject from the foreground, and internally from the list\nforeground_mobjects.\n\nParameters\n----------\nmobject\n    The mobject to remove from the foreground.\n\nReturns\n------\nScene\n    The Scene, with the foreground mobject removed."
        },
        "remove_foreground_mobjects": {
          "signature": "remove_foreground_mobjects(to_remove)",
          "summary": "Removes mobjects from the foreground, and internally from the list",
          "doc": "Removes mobjects from the foreground, and internally from the list\nforeground_mobjects.\n\nParameters\n----------\n*to_remove\n    The mobject(s) to remove from the foreground.\n\nReturns\n------\nScene\n    The Scene, with the foreground mobjects removed."
        },
        "remove_updater": {
          "signature": "remove_updater(func)",
          "summary": "Remove an update function from the scene.",
          "doc": "Remove an update function from the scene.\n\nParameters\n----------\nfunc\n    The updater function to be removed.\n\nSee also\n--------\n:meth:`.Scene.add_updater`\n:meth:`.Scene.update_self`"
        },
        "render": {
          "signature": "render(preview=False)",
          "summary": "Renders this Scene.",
          "doc": "Renders this Scene.\n\nParameters\n---------\npreview\n    If true, opens scene in a file viewer."
        },
        "replace": {
          "signature": "replace(old_mobject, new_mobject)",
          "summary": "Replace one mobject in the scene with another, preserving draw order.",
          "doc": "Replace one mobject in the scene with another, preserving draw order.\n\nIf ``old_mobject`` is a submobject of some other Mobject (e.g. a\n:class:`.Group`), the new_mobject will replace it inside the group,\nwithout otherwise changing the parent mobject.\n\nParameters\n----------\nold_mobject\n    The mobject to be replaced. Must be present in the scene.\nnew_mobject\n    A mobject which must not already be in the scene."
        },
        "restructure_mobjects": {
          "signature": "restructure_mobjects(to_remove, mobject_list_name='mobjects', extract_families=True)",
          "summary": "tl:wr If your scene has a Group(), and you removed a mobject from the Group, this dissolves the group and puts the rest of the mobjects directly in self.mobjects or self.foreground_mobjects.",
          "doc": "tl:wr\n    If your scene has a Group(), and you removed a mobject from the Group,\n    this dissolves the group and puts the rest of the mobjects directly\n    in self.mobjects or self.foreground_mobjects.\n\nIn cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\nof its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\nwill be edited to contain other submobjects, but not m1, e.g. it will now\ninsert m2 and m3 to where the group once was.\n\nParameters\n----------\nto_remove\n    The Mobject to remove.\n\nmobject_list_name\n    The list of mobjects (\"mobjects\", \"foreground_mobjects\" etc) to remove from.\n\nextract_families\n    Whether the mobject's families should be recursively extracted.\n\nReturns\n-------\nScene\n    The Scene mobject with restructured Mobjects."
        },
        "set_key_function": {
          "signature": "set_key_function(char, func)",
          "summary": "No documentation available.",
          "doc": null
        },
        "setup": {
          "signature": "setup()",
          "summary": "This is meant to be implemented by any scenes which",
          "doc": "This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common setup\ninvolved before the construct method is called."
        },
        "should_update_mobjects": {
          "signature": "should_update_mobjects()",
          "summary": "Returns True if the mobjects of this scene should be updated.",
          "doc": "Returns True if the mobjects of this scene should be updated.\n\nIn particular, this checks whether\n\n- the :attr:`always_update_mobjects` attribute of :class:`.Scene`\n  is set to ``True``,\n- the :class:`.Scene` itself has time-based updaters attached,\n- any mobject in this :class:`.Scene` has time-based updaters attached.\n\nThis is only called when a single Wait animation is played."
        },
        "tear_down": {
          "signature": "tear_down()",
          "summary": "This is meant to be implemented by any scenes which",
          "doc": "This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common method\nto be invoked before the scene ends."
        },
        "update_meshes": {
          "signature": "update_meshes(dt)",
          "summary": "No documentation available.",
          "doc": null
        },
        "update_mobjects": {
          "signature": "update_mobjects(dt)",
          "summary": "Begins updating all mobjects in the Scene.",
          "doc": "Begins updating all mobjects in the Scene.\n\nParameters\n----------\ndt\n    Change in time between updates. Defaults (mostly) to 1/frames_per_second"
        },
        "update_self": {
          "signature": "update_self(dt)",
          "summary": "Run all scene updater functions.",
          "doc": "Run all scene updater functions.\n\nAmong all types of update functions (mobject updaters, mesh updaters,\nscene updaters), scene update functions are called last.\n\nParameters\n----------\ndt\n    Scene time since last update.\n\nSee Also\n--------\n:meth:`.Scene.add_updater`\n:meth:`.Scene.remove_updater`"
        },
        "update_to_time": {
          "signature": "update_to_time(t)",
          "summary": "No documentation available.",
          "doc": null
        },
        "wait": {
          "signature": "wait(duration=1.0, stop_condition=None, frozen_frame=None)",
          "summary": "Plays a \"no operation\" animation.",
          "doc": "Plays a \"no operation\" animation.\n\nParameters\n----------\nduration\n    The run time of the animation.\nstop_condition\n    A function without positional arguments that is evaluated every time\n    a frame is rendered. The animation only stops when the return value\n    of the function is truthy, or when the time specified in ``duration``\n    passes.\nfrozen_frame\n    If True, updater functions are not evaluated, and the animation outputs\n    a frozen frame. If False, updater functions are called and frames\n    are rendered as usual. If None (the default), the scene tries to\n    determine whether or not the frame is frozen on its own.\n\nSee also\n--------\n:class:`.Wait`, :meth:`.should_mobjects_update`"
        },
        "wait_until": {
          "signature": "wait_until(stop_condition, max_time=60)",
          "summary": "Wait until a condition is satisfied, up to a given maximum duration.",
          "doc": "Wait until a condition is satisfied, up to a given maximum duration.\n\nParameters\n----------\nstop_condition\n    A function with no arguments that determines whether or not the\n    scene should keep waiting.\nmax_time\n    The maximum wait time in seconds."
        }
      },
      "doc": "A Scene is the canvas of your animation.\n\nThe primary role of :class:`Scene` is to provide the user with tools to manage\nmobjects and animations.  Generally speaking, a manim script consists of a class\nthat derives from :class:`Scene` whose :meth:`Scene.construct` method is overridden\nby the user's code.\n\nMobjects are displayed on screen by calling :meth:`Scene.add` and removed from\nscreen by calling :meth:`Scene.remove`.  All mobjects currently on screen are kept\nin :attr:`Scene.mobjects`.  Animations are played by calling :meth:`Scene.play`.\n\nA :class:`Scene` is rendered internally by calling :meth:`Scene.render`.  This in\nturn calls :meth:`Scene.setup`, :meth:`Scene.construct`, and\n:meth:`Scene.tear_down`, in that order.\n\nIt is not recommended to override the ``__init__`` method in user Scenes.  For code\nthat should be ran before a Scene is rendered, use :meth:`Scene.setup` instead.\n\nExamples\n--------\nOverride the :meth:`Scene.construct` method with your code.\n\n.. code-block:: python\n\n    class MyScene(Scene):\n        def construct(self):\n            self.play(Write(Text(\"Hello World!\")))"
    },
    "Mobject": {
      "module": "manim.mobject.mobject",
      "summary": "Mathematical Object: base class for objects that can be displayed on screen.",
      "bases": [],
      "methods": {
        "__add__": {
          "signature": "__add__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__deepcopy__": {
          "signature": "__deepcopy__(clone_from_id)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getattr__": {
          "signature": "__getattr__(attr)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getitem__": {
          "signature": "__getitem__(value)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iadd__": {
          "signature": "__iadd__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__init__": {
          "signature": "__init__(color=#FFFFFF, name=None, dim=3, target=None, z_index=0)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__isub__": {
          "signature": "__isub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iter__": {
          "signature": "__iter__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__len__": {
          "signature": "__len__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__sub__": {
          "signature": "__sub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add": {
          "signature": "add(mobjects)",
          "summary": "Add mobjects as submobjects.",
          "doc": "Add mobjects as submobjects.\n\nThe mobjects are added to :attr:`submobjects`.\n\nSubclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add_to_back`\n\nExamples\n--------\n::\n\n    >>> outer = Mobject()\n    >>> inner = Mobject()\n    >>> outer = outer.add(inner)\n\nDuplicates are not added again::\n\n    >>> outer = outer.add(inner)\n    >>> len(outer.submobjects)\n    1\n\nOnly Mobjects can be added::\n\n    >>> outer.add(3)\n    Traceback (most recent call last):\n    ...\n    TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.\n\nAdding an object to itself raises an error::\n\n    >>> outer.add(outer)\n    Traceback (most recent call last):\n    ...\n    ValueError: Cannot add Mobject as a submobject of itself (at index 0).\n\nA given mobject cannot be added as a submobject\ntwice to some parent::\n\n    >>> parent = Mobject(name=\"parent\")\n    >>> child = Mobject(name=\"child\")\n    >>> parent.add(child, child)\n    [...] WARNING  ...\n    parent\n    >>> parent.submobjects\n    [child]"
        },
        "add_background_rectangle": {
          "signature": "add_background_rectangle(color=None, opacity=0.75, kwargs)",
          "summary": "Add a BackgroundRectangle as submobject.",
          "doc": "Add a BackgroundRectangle as submobject.\n\nThe BackgroundRectangle is added behind other submobjects.\n\nThis can be used to increase the mobjects visibility in front of a noisy background.\n\nParameters\n----------\ncolor\n    The color of the BackgroundRectangle\nopacity\n    The opacity of the BackgroundRectangle\nkwargs\n    Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_to_back`\n:class:`~.BackgroundRectangle`"
        },
        "add_background_rectangle_to_family_members_with_points": {
          "signature": "add_background_rectangle_to_family_members_with_points(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_background_rectangle_to_submobjects": {
          "signature": "add_background_rectangle_to_submobjects(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_n_more_submobjects": {
          "signature": "add_n_more_submobjects(n)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_to_back": {
          "signature": "add_to_back(mobjects)",
          "summary": "Add all passed mobjects to the back of the submobjects.",
          "doc": "Add all passed mobjects to the back of the submobjects.\n\nIf :attr:`submobjects` already contains the given mobjects, they just get moved\nto the back instead.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\n\n.. note::\n\n    Technically, this is done by adding (or moving) the mobjects to\n    the head of :attr:`submobjects`. The head of this list is rendered\n    first, which places the corresponding mobjects behind the\n    subsequent list members.\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add`"
        },
        "add_updater": {
          "signature": "add_updater(update_function, index=None, call_updater=False)",
          "summary": "Add an update function to this mobject.",
          "doc": "Add an update function to this mobject.\n\nUpdate functions, or updaters in short, are functions that are applied to the\nMobject in every frame.\n\nParameters\n----------\nupdate_function\n    The update function to be added.\n    Whenever :meth:`update` is called, this update function gets called using\n    ``self`` as the first parameter.\n    The updater can have a second parameter ``dt``. If it uses this parameter,\n    it gets called using a second value ``dt``, usually representing the time\n    in seconds since the last call of :meth:`update`.\nindex\n    The index at which the new updater should be added in ``self.updaters``.\n    In case ``index`` is ``None`` the updater will be added at the end.\ncall_updater\n    Whether or not to call the updater initially. If ``True``, the updater will\n    be called using ``dt=0``.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n.. manim:: NextToUpdater\n\n    class NextToUpdater(Scene):\n        def construct(self):\n            def dot_position(mobject):\n                mobject.set_value(dot.get_center()[0])\n                mobject.next_to(dot)\n\n            dot = Dot(RIGHT*3)\n            label = DecimalNumber()\n            label.add_updater(dot_position)\n            self.add(dot, label)\n\n            self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))\n\n.. manim:: DtUpdater\n\n    class DtUpdater(Scene):\n        def construct(self):\n            square = Square()\n\n            #Let the square rotate 90\u00b0 per second\n            square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n            self.add(square)\n            self.wait(2)\n\nSee also\n--------\n:meth:`get_updaters`\n:meth:`remove_updater`\n:class:`~.UpdateFromFunc`"
        },
        "align_data": {
          "signature": "align_data(mobject, skip_point_alignment=False)",
          "summary": "Aligns the data of this mobject with another mobject.",
          "doc": "Aligns the data of this mobject with another mobject.\n\nAfterwards, the two mobjects will have the same number of submobjects\n(see :meth:`.align_submobjects`), the same parent structure (see\n:meth:`.null_point_align`). If ``skip_point_alignment`` is false,\nthey will also have the same number of points (see :meth:`.align_points`).\n\nParameters\n----------\nmobject\n    The other mobject this mobject should be aligned to.\nskip_point_alignment\n    Controls whether or not the computationally expensive\n    point alignment is skipped (default: False)."
        },
        "align_on_border": {
          "signature": "align_on_border(direction, buff=0.5)",
          "summary": "Direction just needs to be a vector pointing towards side or",
          "doc": "Direction just needs to be a vector pointing towards side or\ncorner in the 2d plane."
        },
        "align_points": {
          "signature": "align_points(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_points_with_larger": {
          "signature": "align_points_with_larger(larger_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_submobjects": {
          "signature": "align_submobjects(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_to": {
          "signature": "align_to(mobject_or_point, direction=[0. 0. 0.])",
          "summary": "Aligns mobject to another :class:`~.Mobject` in a certain direction.",
          "doc": "Aligns mobject to another :class:`~.Mobject` in a certain direction.\n\nExamples:\nmob1.align_to(mob2, UP) moves mob1 vertically so that its\ntop edge lines ups with mob2's top edge."
        },
        "apply_complex_function": {
          "signature": "apply_complex_function(function, kwargs)",
          "summary": "Applies a complex function to a :class:`Mobject`.",
          "doc": "Applies a complex function to a :class:`Mobject`.\nThe x and y Point3Ds correspond to the real and imaginary parts respectively.\n\nExample\n-------\n\n.. manim:: ApplyFuncExample\n\n    class ApplyFuncExample(Scene):\n        def construct(self):\n            circ = Circle().scale(1.5)\n            circ_ref = circ.copy()\n            circ.apply_complex_function(\n                lambda x: np.exp(x*1j)\n            )\n            t = ValueTracker(0)\n            circ.add_updater(\n                lambda x: x.become(circ_ref.copy().apply_complex_function(\n                    lambda x: np.exp(x+t.get_value()*1j)\n                )).set_color(BLUE)\n            )\n            self.add(circ_ref)\n            self.play(TransformFromCopy(circ_ref, circ))\n            self.play(t.animate.set_value(TAU), run_time=3)"
        },
        "apply_function": {
          "signature": "apply_function(function, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_position": {
          "signature": "apply_function_to_position(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_submobject_positions": {
          "signature": "apply_function_to_submobject_positions(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_matrix": {
          "signature": "apply_matrix(matrix, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_over_attr_arrays": {
          "signature": "apply_over_attr_arrays(func)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_points_function_about_point": {
          "signature": "apply_points_function_about_point(func, about_point=None, about_edge=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_to_family": {
          "signature": "apply_to_family(func)",
          "summary": "Apply a function to ``self`` and every submobject with points recursively.",
          "doc": "Apply a function to ``self`` and every submobject with points recursively.\n\nParameters\n----------\nfunc\n    The function to apply to each mobject. ``func`` gets passed the respective\n    (sub)mobject as parameter.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`family_members_with_points`"
        },
        "arrange": {
          "signature": "arrange(direction=[1. 0. 0.], buff=0.25, center=True, kwargs)",
          "summary": "Sorts :class:`~.Mobject` next to each other on screen.",
          "doc": "Sorts :class:`~.Mobject` next to each other on screen.\n\nExamples\n--------\n\n.. manim:: Example\n    :save_last_frame:\n\n    class Example(Scene):\n        def construct(self):\n            s1 = Square()\n            s2 = Square()\n            s3 = Square()\n            s4 = Square()\n            x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n            self.add(x)"
        },
        "arrange_in_grid": {
          "signature": "arrange_in_grid(rows=None, cols=None, buff=0.25, cell_alignment=[0. 0. 0.], row_alignments=None, col_alignments=None, row_heights=None, col_widths=None, flow_order='rd', kwargs)",
          "summary": "Arrange submobjects in a grid.",
          "doc": "Arrange submobjects in a grid.\n\nParameters\n----------\nrows\n    The number of rows in the grid.\ncols\n    The number of columns in the grid.\nbuff\n    The gap between grid cells. To specify a different buffer in the horizontal and\n    vertical directions, a tuple of two values can be given - ``(row, col)``.\ncell_alignment\n    The way each submobject is aligned in its grid cell.\nrow_alignments\n    The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n    up, ``\"c\"`` - center, ``\"d\"`` - down.\ncol_alignments\n    The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n    ``\"c\"`` - center, ``\"r\"`` - right.\nrow_heights\n    Defines a list of heights for certain rows (top to bottom). If the list contains\n    ``None``, the corresponding row will fit its height automatically based\n    on the highest element in that row.\ncol_widths\n    Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n    corresponding column will fit its width automatically based on the widest element in that column.\nflow_order\n    The order in which submobjects fill the grid. Can be one of the following values:\n    \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\nValueError\n    If ``rows`` and ``cols`` are too small to fit all submobjects.\nValueError\n    If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n    :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\nNotes\n-----\nIf only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\nenough to fit all submobjects. If neither is set, they will be chosen to be about the same,\ntending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\nIf both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\ndefined, the latter has higher priority.\n\nExamples\n--------\n.. manim:: ExampleBoxes\n    :save_last_frame:\n\n    class ExampleBoxes(Scene):\n        def construct(self):\n            boxes=VGroup(*[Square() for s in range(0,6)])\n            boxes.arrange_in_grid(rows=2, buff=0.1)\n            self.add(boxes)\n\n\n.. manim:: ArrangeInGrid\n    :save_last_frame:\n\n    class ArrangeInGrid(Scene):\n        def construct(self):\n            boxes = VGroup(*[\n                Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n                for i in range(24)\n            ])\n            self.add(boxes)\n\n            boxes.arrange_in_grid(\n                buff=(0.25,0.5),\n                col_alignments=\"lccccr\",\n                row_alignments=\"uccd\",\n                col_widths=[1, *[None]*4, 1],\n                row_heights=[1, None, None, 1],\n                flow_order=\"dr\"\n            )"
        },
        "arrange_submobjects": {
          "signature": "arrange_submobjects(args, kwargs)",
          "summary": "Arrange the position of :attr:`submobjects` with a small buffer.",
          "doc": "Arrange the position of :attr:`submobjects` with a small buffer.\n\nExamples\n--------\n\n.. manim:: ArrangeSumobjectsExample\n    :save_last_frame:\n\n    class ArrangeSumobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n            s.shift(UP).set_color(BLUE)\n            s2= s.copy().set_color(RED)\n            s2.arrange_submobjects()\n            s2.shift(DOWN)\n            self.add(s,s2)"
        },
        "become": {
          "signature": "become(mobject, match_height=False, match_width=False, match_depth=False, match_center=False, stretch=False)",
          "summary": "Edit points, colors and submobjects to be identical",
          "doc": "Edit points, colors and submobjects to be identical\nto another :class:`~.Mobject`\n\n.. note::\n\n    If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`\n    will match the height first and then the width.\n\nParameters\n----------\nmatch_height\n    Whether or not to preserve the height of the original\n    :class:`~.Mobject`.\nmatch_width\n    Whether or not to preserve the width of the original\n    :class:`~.Mobject`.\nmatch_depth\n    Whether or not to preserve the depth of the original\n    :class:`~.Mobject`.\nmatch_center\n    Whether or not to preserve the center of the original\n    :class:`~.Mobject`.\nstretch\n    Whether or not to stretch the target mobject to match the\n    the proportions of the original :class:`~.Mobject`.\n\nExamples\n--------\n.. manim:: BecomeScene\n\n    class BecomeScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            circ.become(square)\n            self.wait(0.5)\n\n\nThe following examples illustrate how mobject measurements\nchange when using the ``match_...`` and ``stretch`` arguments.\nWe start with a rectangle that is 2 units high and 4 units wide,\nwhich we want to turn into a circle of radius 3::\n\n    >>> from manim import Rectangle, Circle\n    >>> import numpy as np\n    >>> rect = Rectangle(height=2, width=4)\n    >>> circ = Circle(radius=3)\n\nWith ``stretch=True``, the target circle is deformed to match\nthe proportions of the rectangle, which results in the target\nmobject being an ellipse with height 2 and width 4. We can\ncheck that the resulting points satisfy the ellipse equation\n:math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`\nbeing the semi-axes::\n\n    >>> result = rect.copy().become(circ, stretch=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(4.0))\n    >>> ellipse_points = np.array(result.get_anchors())\n    >>> ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)\n    >>> np.allclose(ellipse_eq, 1)\n    True\n\nWith ``match_height=True`` and ``match_width=True`` the circle is\nscaled such that the height or the width of the rectangle will\nbe preserved, respectively.\nThe points of the resulting mobject satisfy the circle equation\n:math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::\n\n    >>> result = rect.copy().become(circ, match_height=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(2.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 1)\n    True\n    >>> result = rect.copy().become(circ, match_width=True)\n    >>> result.height, result.width\n    (np.float64(4.0), np.float64(4.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 2**2)\n    True\n\nWith ``match_center=True``, the resulting mobject is moved such that\nits center is the same as the center of the original mobject::\n\n    >>> rect = rect.shift(np.array([0, 1, 0]))\n    >>> np.allclose(rect.get_center(), circ.get_center())\n    False\n    >>> result = rect.copy().become(circ, match_center=True)\n    >>> np.allclose(rect.get_center(), result.get_center())\n    True"
        },
        "center": {
          "signature": "center()",
          "summary": "Moves the center of the mobject to the center of the scene.",
          "doc": "Moves the center of the mobject to the center of the scene.\n\nReturns\n-------\n:class:`.Mobject`\n    The centered mobject."
        },
        "clear_updaters": {
          "signature": "clear_updaters(recursive=True)",
          "summary": "Remove every updater.",
          "doc": "Remove every updater.\n\nParameters\n----------\nrecursive\n    Whether to recursively call ``clear_updaters`` on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`remove_updater`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create and return an identical copy of the :class:`Mobject` including all",
          "doc": "Create and return an identical copy of the :class:`Mobject` including all\n:attr:`submobjects`.\n\nReturns\n-------\n:class:`Mobject`\n    The copy.\n\nNote\n----\nThe clone is initially not visible in the Scene, even if the original was."
        },
        "fade": {
          "signature": "fade(darkness=0.5, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "fade_to": {
          "signature": "fade_to(color, alpha, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "family_members_with_points": {
          "signature": "family_members_with_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "flip": {
          "signature": "flip(axis=[0. 1. 0.], kwargs)",
          "summary": "Flips/Mirrors an mobject about its center.",
          "doc": "Flips/Mirrors an mobject about its center.\n\nExamples\n--------\n\n.. manim:: FlipExample\n    :save_last_frame:\n\n    class FlipExample(Scene):\n        def construct(self):\n            s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n            self.add(s)\n            s2= s.copy().flip()\n            self.add(s2)"
        },
        "generate_points": {
          "signature": "generate_points()",
          "summary": "Initializes :attr:`points` and therefore the shape.",
          "doc": "Initializes :attr:`points` and therefore the shape.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "generate_target": {
          "signature": "generate_target(use_deepcopy=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_points": {
          "signature": "get_all_points()",
          "summary": "Return all points from this mobject and all submobjects.",
          "doc": "Return all points from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_array_attrs": {
          "signature": "get_array_attrs()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_bottom": {
          "signature": "get_bottom()",
          "summary": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_boundary_point": {
          "signature": "get_boundary_point(direction)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_center": {
          "signature": "get_center()",
          "summary": "Get center Point3Ds",
          "doc": "Get center Point3Ds"
        },
        "get_center_of_mass": {
          "signature": "get_center_of_mass()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_color": {
          "signature": "get_color()",
          "summary": "Returns the color of the :class:`~.Mobject` Examples",
          "doc": "Returns the color of the :class:`~.Mobject`\n\nExamples\n--------\n::\n\n    >>> from manim import Square, RED\n    >>> Square(color=RED).get_color() == RED\n    True"
        },
        "get_coord": {
          "signature": "get_coord(dim, direction=[0. 0. 0.])",
          "summary": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``",
          "doc": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``"
        },
        "get_corner": {
          "signature": "get_corner(direction)",
          "summary": "Get corner Point3Ds for certain direction.",
          "doc": "Get corner Point3Ds for certain direction."
        },
        "get_critical_point": {
          "signature": "get_critical_point(direction)",
          "summary": "Picture a box bounding the :class:`~.Mobject`.",
          "doc": "Picture a box bounding the :class:`~.Mobject`.  Such a box has\n9 'critical points': 4 corners, 4 edge center, the\ncenter. This returns one of them, along the given direction.\n\n::\n\n    sample = Arc(start_angle=PI / 7, angle=PI / 5)\n\n    # These are all equivalent\n    max_y_1 = sample.get_top()[1]\n    max_y_2 = sample.get_critical_point(UP)[1]\n    max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)"
        },
        "get_edge_center": {
          "signature": "get_edge_center(direction)",
          "summary": "Get edge Point3Ds for certain direction.",
          "doc": "Get edge Point3Ds for certain direction."
        },
        "get_end": {
          "signature": "get_end()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends."
        },
        "get_extremum_along_dim": {
          "signature": "get_extremum_along_dim(points=None, dim=0, key=0)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family": {
          "signature": "get_family(recurse=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family_updaters": {
          "signature": "get_family_updaters()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_group_class": {
          "signature": "get_group_class()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_image": {
          "signature": "get_image(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_left": {
          "signature": "get_left()",
          "summary": "Get left Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get left Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_merged_array": {
          "signature": "get_merged_array(array_attr)",
          "summary": "Return all of a given attribute from this mobject and all submobjects.",
          "doc": "Return all of a given attribute from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_midpoint": {
          "signature": "get_midpoint()",
          "summary": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.",
          "doc": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.\n\nExamples\n--------\n\n.. manim:: AngleMidPoint\n    :save_last_frame:\n\n    class AngleMidPoint(Scene):\n        def construct(self):\n            line1 = Line(ORIGIN, 2*RIGHT)\n            line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n            a = Angle(line1, line2, radius=1.5, other_angle=False)\n            d = Dot(a.get_midpoint()).set_color(RED)\n\n            self.add(line1, line2, a, d)\n            self.wait()"
        },
        "get_mobject_type_class": {
          "signature": "get_mobject_type_class()",
          "summary": "Return the base class of this mobject type.",
          "doc": "Return the base class of this mobject type."
        },
        "get_nadir": {
          "signature": "get_nadir()",
          "summary": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "get_num_points": {
          "signature": "get_num_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_pieces": {
          "signature": "get_pieces(n_pieces)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_point_mobject": {
          "signature": "get_point_mobject(center=None)",
          "summary": "The simplest :class:`~.Mobject` to be transformed to or from self.",
          "doc": "The simplest :class:`~.Mobject` to be transformed to or from self.\nShould by a point of the appropriate type"
        },
        "get_points_defining_boundary": {
          "signature": "get_points_defining_boundary()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_right": {
          "signature": "get_right()",
          "summary": "Get right Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get right Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_start": {
          "signature": "get_start()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts."
        },
        "get_start_and_end": {
          "signature": "get_start_and_end()",
          "summary": "Returns starting and ending point of a stroke as a ``tuple``.",
          "doc": "Returns starting and ending point of a stroke as a ``tuple``."
        },
        "get_time_based_updaters": {
          "signature": "get_time_based_updaters()",
          "summary": "Return all updaters using the ``dt`` parameter.",
          "doc": "Return all updaters using the ``dt`` parameter.\n\nThe updaters use this parameter as the input for difference in time.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of time based updaters.\n\nSee Also\n--------\n:meth:`get_updaters`\n:meth:`has_time_based_updater`"
        },
        "get_top": {
          "signature": "get_top()",
          "summary": "Get top Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get top Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_updaters": {
          "signature": "get_updaters()",
          "summary": "Return all updaters.",
          "doc": "Return all updaters.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of updaters.\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_time_based_updaters`"
        },
        "get_x": {
          "signature": "get_x(direction=[0. 0. 0.])",
          "summary": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_y": {
          "signature": "get_y(direction=[0. 0. 0.])",
          "summary": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z": {
          "signature": "get_z(direction=[0. 0. 0.])",
          "summary": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z_index_reference_point": {
          "signature": "get_z_index_reference_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_zenith": {
          "signature": "get_zenith()",
          "summary": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "has_no_points": {
          "signature": "has_no_points()",
          "summary": "Check if :class:`~.Mobject` *does not* contains points.",
          "doc": "Check if :class:`~.Mobject` *does not* contains points."
        },
        "has_points": {
          "signature": "has_points()",
          "summary": "Check if :class:`~.Mobject` contains points.",
          "doc": "Check if :class:`~.Mobject` contains points."
        },
        "has_time_based_updater": {
          "signature": "has_time_based_updater()",
          "summary": "Test if ``self`` has a time based updater.",
          "doc": "Test if ``self`` has a time based updater.\n\nReturns\n-------\n:class:`bool`\n    ``True`` if at least one updater uses the ``dt`` parameter, ``False``\n    otherwise.\n\nSee Also\n--------\n:meth:`get_time_based_updaters`"
        },
        "init_colors": {
          "signature": "init_colors()",
          "summary": "Initializes the colors.",
          "doc": "Initializes the colors.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "insert": {
          "signature": "insert(index, mobject)",
          "summary": "Inserts a mobject at a specific position into self.submobjects Effectively just calls  ``self.submobjects.insert(index, mobject)``,",
          "doc": "Inserts a mobject at a specific position into self.submobjects\n\nEffectively just calls  ``self.submobjects.insert(index, mobject)``,\nwhere ``self.submobjects`` is a list.\n\nHighly adapted from ``Mobject.add``.\n\nParameters\n----------\nindex\n    The index at which\nmobject\n    The mobject to be inserted."
        },
        "interpolate": {
          "signature": "interpolate(mobject1, mobject2, alpha, path_func=<function interpolate at 0x109973f60>)",
          "summary": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``",
          "doc": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``\nand ``mobject2``.\n\nExamples\n--------\n\n.. manim:: DotInterpolation\n    :save_last_frame:\n\n    class DotInterpolation(Scene):\n        def construct(self):\n            dotR = Dot(color=DARK_GREY)\n            dotR.shift(2 * RIGHT)\n            dotL = Dot(color=WHITE)\n            dotL.shift(2 * LEFT)\n\n            dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n            self.add(dotL, dotR, dotMiddle)"
        },
        "interpolate_color": {
          "signature": "interpolate_color(mobject1, mobject2, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "invert": {
          "signature": "invert(recursive=False)",
          "summary": "Inverts the list of :attr:`submobjects`.",
          "doc": "Inverts the list of :attr:`submobjects`.\n\nParameters\n----------\nrecursive\n    If ``True``, all submobject lists of this mobject's family are inverted.\n\nExamples\n--------\n\n.. manim:: InvertSumobjectsExample\n\n    class InvertSumobjectsExample(Scene):\n        def construct(self):\n            s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2 = s.copy()\n            s2.invert()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "is_off_screen": {
          "signature": "is_off_screen()",
          "summary": "No documentation available.",
          "doc": null
        },
        "length_over_dim": {
          "signature": "length_over_dim(dim)",
          "summary": "Measure the length of an :class:`~.Mobject` in a certain direction.",
          "doc": "Measure the length of an :class:`~.Mobject` in a certain direction."
        },
        "match_color": {
          "signature": "match_color(mobject)",
          "summary": "Match the color with the color of another :class:`~.Mobject`.",
          "doc": "Match the color with the color of another :class:`~.Mobject`."
        },
        "match_coord": {
          "signature": "match_coord(mobject, dim, direction=[0. 0. 0.])",
          "summary": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`.",
          "doc": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`."
        },
        "match_depth": {
          "signature": "match_depth(mobject, kwargs)",
          "summary": "Match the depth with the depth of another :class:`~.Mobject`.",
          "doc": "Match the depth with the depth of another :class:`~.Mobject`."
        },
        "match_dim_size": {
          "signature": "match_dim_size(mobject, dim, kwargs)",
          "summary": "Match the specified dimension with the dimension of another :class:`~.Mobject`.",
          "doc": "Match the specified dimension with the dimension of another :class:`~.Mobject`."
        },
        "match_height": {
          "signature": "match_height(mobject, kwargs)",
          "summary": "Match the height with the height of another :class:`~.Mobject`.",
          "doc": "Match the height with the height of another :class:`~.Mobject`."
        },
        "match_points": {
          "signature": "match_points(mobject, copy_submobjects=True)",
          "summary": "Edit points, positions, and submobjects to be identical",
          "doc": "Edit points, positions, and submobjects to be identical\nto another :class:`~.Mobject`, while keeping the style unchanged.\n\nExamples\n--------\n.. manim:: MatchPointsScene\n\n    class MatchPointsScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)"
        },
        "match_updaters": {
          "signature": "match_updaters(mobject)",
          "summary": "Match the updaters of the given mobject.",
          "doc": "Match the updaters of the given mobject.\n\nParameters\n----------\nmobject\n    The mobject whose updaters get matched.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nNote\n----\nAll updaters from submobjects are removed, but only updaters of the given\nmobject are matched, not those of it's submobjects.\n\nSee also\n--------\n:meth:`add_updater`\n:meth:`clear_updaters`"
        },
        "match_width": {
          "signature": "match_width(mobject, kwargs)",
          "summary": "Match the width with the width of another :class:`~.Mobject`.",
          "doc": "Match the width with the width of another :class:`~.Mobject`."
        },
        "match_x": {
          "signature": "match_x(mobject, direction=[0. 0. 0.])",
          "summary": "Match x coord.",
          "doc": "Match x coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_y": {
          "signature": "match_y(mobject, direction=[0. 0. 0.])",
          "summary": "Match y coord.",
          "doc": "Match y coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_z": {
          "signature": "match_z(mobject, direction=[0. 0. 0.])",
          "summary": "Match z coord.",
          "doc": "Match z coord. to the x coord. of another :class:`~.Mobject`."
        },
        "move_to": {
          "signature": "move_to(point_or_mobject, aligned_edge=[0. 0. 0.], coor_mask=[1 1 1])",
          "summary": "Move center of the :class:`~.Mobject` to certain Point3D.",
          "doc": "Move center of the :class:`~.Mobject` to certain Point3D."
        },
        "next_to": {
          "signature": "next_to(mobject_or_point, direction=[1. 0. 0.], buff=0.25, aligned_edge=[0. 0. 0.], submobject_to_align=None, index_of_submobject_to_align=None, coor_mask=[1 1 1])",
          "summary": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.",
          "doc": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.\n\nExamples\n--------\n\n.. manim:: GeometricShapes\n    :save_last_frame:\n\n    class GeometricShapes(Scene):\n        def construct(self):\n            d = Dot()\n            c = Circle()\n            s = Square()\n            t = Triangle()\n            d.next_to(c, RIGHT)\n            s.next_to(c, LEFT)\n            t.next_to(c, DOWN)\n            self.add(d, c, s, t)"
        },
        "nonempty_submobjects": {
          "signature": "nonempty_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "null_point_align": {
          "signature": "null_point_align(mobject)",
          "summary": "If a :class:`~.Mobject` with points is being aligned to",
          "doc": "If a :class:`~.Mobject` with points is being aligned to\none without, treat both as groups, and push\nthe one with points into its own submobjects\nlist.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``"
        },
        "point_from_proportion": {
          "signature": "point_from_proportion(alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "pose_at_angle": {
          "signature": "pose_at_angle(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "proportion_from_point": {
          "signature": "proportion_from_point(point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "push_self_into_submobjects": {
          "signature": "push_self_into_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "put_start_and_end_on": {
          "signature": "put_start_and_end_on(start, end)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reduce_across_dimension": {
          "signature": "reduce_across_dimension(reduce_func, dim)",
          "summary": "Find the min or max value from a dimension across all points in this and submobjects.",
          "doc": "Find the min or max value from a dimension across all points in this and submobjects."
        },
        "remove": {
          "signature": "remove(mobjects)",
          "summary": "Remove :attr:`submobjects`.",
          "doc": "Remove :attr:`submobjects`.\n\nThe mobjects are removed from :attr:`submobjects`, if they exist.\n\nSubclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to remove.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add`"
        },
        "remove_updater": {
          "signature": "remove_updater(update_function)",
          "summary": "Remove an updater.",
          "doc": "Remove an updater.\n\nIf the same updater is applied multiple times, every instance gets removed.\n\nParameters\n----------\nupdate_function\n    The update function to be removed.\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`clear_updaters`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "repeat": {
          "signature": "repeat(count)",
          "summary": "This can make transition animations nicer",
          "doc": "This can make transition animations nicer"
        },
        "repeat_submobject": {
          "signature": "repeat_submobject(submob)",
          "summary": "No documentation available.",
          "doc": null
        },
        "replace": {
          "signature": "replace(mobject, dim_to_match=0, stretch=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "rescale_to_fit": {
          "signature": "rescale_to_fit(length, dim, stretch=False, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reset_points": {
          "signature": "reset_points()",
          "summary": "Sets :attr:`points` to be an empty array.",
          "doc": "Sets :attr:`points` to be an empty array."
        },
        "restore": {
          "signature": "restore()",
          "summary": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`.",
          "doc": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`."
        },
        "resume_updating": {
          "signature": "resume_updating(recursive=True)",
          "summary": "Enable updating from updaters and animations.",
          "doc": "Enable updating from updaters and animations.\n\nParameters\n----------\nrecursive\n    Whether to recursively enable updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`suspend_updating`\n:meth:`add_updater`"
        },
        "reverse_points": {
          "signature": "reverse_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "rotate": {
          "signature": "rotate(angle, axis=[0. 0. 1.], about_point=None, kwargs)",
          "summary": "Rotates the :class:`~.Mobject` about a certain point.",
          "doc": "Rotates the :class:`~.Mobject` about a certain point."
        },
        "rotate_about_origin": {
          "signature": "rotate_about_origin(angle, axis=[0. 0. 1.], axes=[])",
          "summary": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0].",
          "doc": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0]."
        },
        "save_image": {
          "signature": "save_image(name=None)",
          "summary": "Saves an image of only this :class:`Mobject` at its position to a png",
          "doc": "Saves an image of only this :class:`Mobject` at its position to a png\nfile."
        },
        "save_state": {
          "signature": "save_state()",
          "summary": "Save the current state (position, color & size).",
          "doc": "Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`."
        },
        "scale": {
          "signature": "scale(scale_factor, kwargs)",
          "summary": "Scale the size by a factor.",
          "doc": "Scale the size by a factor.\n\nDefault behavior is to scale about the center of the mobject.\n\nParameters\n----------\nscale_factor\n    The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n    will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n    if :math:`\\alpha < 0`, the mobject is also flipped.\nkwargs\n    Additional keyword arguments passed to\n    :meth:`apply_points_function_about_point`.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n\n.. manim:: MobjectScaleExample\n    :save_last_frame:\n\n    class MobjectScaleExample(Scene):\n        def construct(self):\n            f1 = Text(\"F\")\n            f2 = Text(\"F\").scale(2)\n            f3 = Text(\"F\").scale(0.5)\n            f4 = Text(\"F\").scale(-1)\n\n            vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n            self.add(vgroup)\n\nSee also\n--------\n:meth:`move_to`"
        },
        "scale_to_fit_depth": {
          "signature": "scale_to_fit_depth(depth, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional."
        },
        "scale_to_fit_height": {
          "signature": "scale_to_fit_height(height, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.scale_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(5.0)"
        },
        "scale_to_fit_width": {
          "signature": "scale_to_fit_width(width, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.scale_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(5.0)"
        },
        "set": {
          "signature": "set(kwargs)",
          "summary": "Sets attributes.",
          "doc": "Sets attributes.\n\nI.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.\n\nThis is a convenience to be used along with :attr:`animate` to\nanimate setting attributes.\n\nIn addition to this method, there is a compatibility\nlayer that allows ``get_*`` and ``set_*`` methods to\nget and set generic attributes. For instance::\n\n    >>> mob = Mobject()\n    >>> mob.set_foo(0)\n    Mobject\n    >>> mob.get_foo()\n    0\n    >>> mob.foo\n    0\n\nThis compatibility layer does not interfere with any\n``get_*`` or ``set_*`` methods that are explicitly\ndefined.\n\n.. warning::\n\n    This compatibility layer is for backwards compatibility\n    and is not guaranteed to stay around. Where applicable,\n    please prefer getting/setting attributes normally or with\n    the :meth:`set` method.\n\nParameters\n----------\n**kwargs\n    The attributes and corresponding values to set.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> mob = Mobject()\n    >>> mob.set(foo=0)\n    Mobject\n    >>> mob.foo\n    0"
        },
        "set_color": {
          "signature": "set_color(color=#FFFF00, family=True)",
          "summary": "Condition is function which takes in one arguments, (x, y, z).",
          "doc": "Condition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color"
        },
        "set_color_by_gradient": {
          "signature": "set_color_by_gradient(colors)",
          "summary": "Parameters",
          "doc": "Parameters\n----------\ncolors\n    The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.\n\nself.color = ManimColor.parse(color)\nreturn self"
        },
        "set_colors_by_radial_gradient": {
          "signature": "set_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_coord": {
          "signature": "set_coord(value, dim, direction=[0. 0. 0.])",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_gradient": {
          "signature": "set_submobject_colors_by_gradient(colors)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_radial_gradient": {
          "signature": "set_submobject_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_x": {
          "signature": "set_x(x, direction=[0. 0. 0.])",
          "summary": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_y": {
          "signature": "set_y(y, direction=[0. 0. 0.])",
          "summary": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z": {
          "signature": "set_z(z, direction=[0. 0. 0.])",
          "summary": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z_index": {
          "signature": "set_z_index(z_index_value, family=True)",
          "summary": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.",
          "doc": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.\n\nParameters\n----------\nz_index_value\n    The new value of :attr:`z_index` set.\nfamily\n    If ``True``, the :attr:`z_index` value of all submobjects is also set.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)\n\nExamples\n--------\n.. manim:: SetZIndex\n    :save_last_frame:\n\n    class SetZIndex(Scene):\n        def construct(self):\n            text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n            square = Square(2, fill_opacity=1).set_z_index(2)\n            tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n            circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n            # Displaying order is now defined by z_index values\n            self.add(text)\n            self.add(square)\n            self.add(tex)\n            self.add(circle)"
        },
        "set_z_index_by_z_Point3D": {
          "signature": "set_z_index_by_z_Point3D()",
          "summary": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.",
          "doc": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)"
        },
        "shift": {
          "signature": "shift(vectors)",
          "summary": "Shift by the given vectors.",
          "doc": "Shift by the given vectors.\n\nParameters\n----------\nvectors\n    Vectors to shift by. If multiple vectors are given, they are added\n    together.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`move_to`"
        },
        "shift_onto_screen": {
          "signature": "shift_onto_screen(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "show": {
          "signature": "show(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "shuffle": {
          "signature": "shuffle(recursive=False)",
          "summary": "Shuffles the list of :attr:`submobjects`.",
          "doc": "Shuffles the list of :attr:`submobjects`."
        },
        "shuffle_submobjects": {
          "signature": "shuffle_submobjects(args, kwargs)",
          "summary": "Shuffles the order of :attr:`submobjects` Examples",
          "doc": "Shuffles the order of :attr:`submobjects`\n\nExamples\n--------\n\n.. manim:: ShuffleSubmobjectsExample\n\n    class ShuffleSubmobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2= s.copy()\n            s2.shuffle_submobjects()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "sort": {
          "signature": "sort(point_to_num_func=<function Mobject.<lambda> at 0x10a232660>, submob_func=None)",
          "summary": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.",
          "doc": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."
        },
        "sort_submobjects": {
          "signature": "sort_submobjects(args, kwargs)",
          "summary": "Sort the :attr:`submobjects`",
          "doc": "Sort the :attr:`submobjects`"
        },
        "space_out_submobjects": {
          "signature": "space_out_submobjects(factor=1.5, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "split": {
          "signature": "split()",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch": {
          "signature": "stretch(factor, dim, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_about_point": {
          "signature": "stretch_about_point(factor, dim, point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_to_fit_depth": {
          "signature": "stretch_to_fit_depth(depth, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional."
        },
        "stretch_to_fit_height": {
          "signature": "stretch_to_fit_height(height, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(2.0)"
        },
        "stretch_to_fit_width": {
          "signature": "stretch_to_fit_width(width, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(2.0)"
        },
        "surround": {
          "signature": "surround(mobject, dim_to_match=0, stretch=False, buff=0.25)",
          "summary": "No documentation available.",
          "doc": null
        },
        "suspend_updating": {
          "signature": "suspend_updating(recursive=True)",
          "summary": "Disable updating from updaters and animations.",
          "doc": "Disable updating from updaters and animations.\n\n\nParameters\n----------\nrecursive\n    Whether to recursively suspend updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`resume_updating`\n:meth:`add_updater`"
        },
        "throw_error_if_no_points": {
          "signature": "throw_error_if_no_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "to_corner": {
          "signature": "to_corner(corner=[-1. -1.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given corner of the screen.",
          "doc": "Moves this :class:`~.Mobject` to the given corner of the screen.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToCornerExample\n    :save_last_frame:\n\n    class ToCornerExample(Scene):\n        def construct(self):\n            c = Circle()\n            c.to_corner(UR)\n            t = Tex(\"To the corner!\")\n            t2 = MathTex(\"x^3\").shift(DOWN)\n            self.add(c,t,t2)\n            t.to_corner(DL, buff=0)\n            t2.to_corner(UL, buff=1.5)"
        },
        "to_edge": {
          "signature": "to_edge(edge=[-1.  0.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given edge of the screen,",
          "doc": "Moves this :class:`~.Mobject` to the given edge of the screen,\nwithout affecting its position in the other dimension.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToEdgeExample\n    :save_last_frame:\n\n    class ToEdgeExample(Scene):\n        def construct(self):\n            tex_top = Tex(\"I am at the top!\")\n            tex_top.to_edge(UP)\n            tex_side = Tex(\"I am moving to the side!\")\n            c = Circle().shift(2*DOWN)\n            self.add(tex_top, tex_side, c)\n            tex_side.to_edge(LEFT)\n            c.to_edge(RIGHT, buff=0)"
        },
        "to_original_color": {
          "signature": "to_original_color()",
          "summary": "No documentation available.",
          "doc": null
        },
        "update": {
          "signature": "update(dt=0, recursive=True)",
          "summary": "Apply all updaters.",
          "doc": "Apply all updaters.\n\nDoes nothing if updating is suspended.\n\nParameters\n----------\ndt\n    The parameter ``dt`` to pass to the update functions. Usually this is the\n    time in seconds since the last call of ``update``.\nrecursive\n    Whether to recursively update all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_updaters`"
        }
      },
      "doc": "Mathematical Object: base class for objects that can be displayed on screen.\n\nThere is a compatibility layer that allows for\ngetting and setting generic attributes with ``get_*``\nand ``set_*`` methods. See :meth:`set` for more details.\n\nAttributes\n----------\nsubmobjects : List[:class:`Mobject`]\n    The contained objects.\npoints : :class:`numpy.ndarray`\n    The points of the objects.\n\n    .. seealso::\n\n        :class:`~.VMobject`"
    },
    "Circle": {
      "module": "manim.mobject.geometry.arc",
      "summary": "A circle.",
      "bases": [
        "Arc"
      ],
      "methods": {
        "__add__": {
          "signature": "__add__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__deepcopy__": {
          "signature": "__deepcopy__(clone_from_id)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getattr__": {
          "signature": "__getattr__(attr)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getitem__": {
          "signature": "__getitem__(value)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iadd__": {
          "signature": "__iadd__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__init__": {
          "signature": "__init__(radius=None, color=#FC6255, kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__isub__": {
          "signature": "__isub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iter__": {
          "signature": "__iter__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__len__": {
          "signature": "__len__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__sub__": {
          "signature": "__sub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add": {
          "signature": "add(mobjects)",
          "summary": "Add mobjects as submobjects.",
          "doc": "Add mobjects as submobjects.\n\nThe mobjects are added to :attr:`submobjects`.\n\nSubclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add_to_back`\n\nExamples\n--------\n::\n\n    >>> outer = Mobject()\n    >>> inner = Mobject()\n    >>> outer = outer.add(inner)\n\nDuplicates are not added again::\n\n    >>> outer = outer.add(inner)\n    >>> len(outer.submobjects)\n    1\n\nOnly Mobjects can be added::\n\n    >>> outer.add(3)\n    Traceback (most recent call last):\n    ...\n    TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.\n\nAdding an object to itself raises an error::\n\n    >>> outer.add(outer)\n    Traceback (most recent call last):\n    ...\n    ValueError: Cannot add Mobject as a submobject of itself (at index 0).\n\nA given mobject cannot be added as a submobject\ntwice to some parent::\n\n    >>> parent = Mobject(name=\"parent\")\n    >>> child = Mobject(name=\"child\")\n    >>> parent.add(child, child)\n    [...] WARNING  ...\n    parent\n    >>> parent.submobjects\n    [child]"
        },
        "add_background_rectangle": {
          "signature": "add_background_rectangle(color=None, opacity=0.75, kwargs)",
          "summary": "Add a BackgroundRectangle as submobject.",
          "doc": "Add a BackgroundRectangle as submobject.\n\nThe BackgroundRectangle is added behind other submobjects.\n\nThis can be used to increase the mobjects visibility in front of a noisy background.\n\nParameters\n----------\ncolor\n    The color of the BackgroundRectangle\nopacity\n    The opacity of the BackgroundRectangle\nkwargs\n    Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_to_back`\n:class:`~.BackgroundRectangle`"
        },
        "add_background_rectangle_to_family_members_with_points": {
          "signature": "add_background_rectangle_to_family_members_with_points(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_background_rectangle_to_submobjects": {
          "signature": "add_background_rectangle_to_submobjects(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve": {
          "signature": "add_cubic_bezier_curve(anchor1, handle1, handle2, anchor2)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve_to": {
          "signature": "add_cubic_bezier_curve_to(handle1, handle2, anchor)",
          "summary": "Add cubic bezier curve to the path.",
          "doc": "Add cubic bezier curve to the path.\n\nNOTE : the first anchor is not a parameter as by default the end of the last sub-path!\n\nParameters\n----------\nhandle1\n    first handle\nhandle2\n    second handle\nanchor\n    anchor\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_cubic_bezier_curves": {
          "signature": "add_cubic_bezier_curves(curves)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_line_to": {
          "signature": "add_line_to(point)",
          "summary": "Add a straight line from the last point of VMobject to the given point.",
          "doc": "Add a straight line from the last point of VMobject to the given point.\n\nParameters\n----------\n\npoint\n    The end of the straight line.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_n_more_submobjects": {
          "signature": "add_n_more_submobjects(n)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_points_as_corners": {
          "signature": "add_points_as_corners(points)",
          "summary": "Append multiple straight lines at the end of",
          "doc": "Append multiple straight lines at the end of\n:attr:`VMobject.points`, which connect the given ``points`` in order\nstarting from the end of the current path. These ``points`` would be\ntherefore the corners of the new polyline appended to the path.\n\nParameters\n----------\npoints\n    An array of 3D points representing the corners of the polyline to\n    append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending the straight lines to its\n    path."
        },
        "add_quadratic_bezier_curve_to": {
          "signature": "add_quadratic_bezier_curve_to(handle, anchor)",
          "summary": "Add Quadratic bezier curve to the path.",
          "doc": "Add Quadratic bezier curve to the path.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_smooth_curve_to": {
          "signature": "add_smooth_curve_to(points)",
          "summary": "Creates a smooth curve from given points and add it to the VMobject.",
          "doc": "Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted\nas a handle, the second as an anchor.\n\nParameters\n----------\npoints\n    Points (anchor and handle, or just anchor) to add a smooth curve from\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nRaises\n------\nValueError\n    If 0 or more than 2 points are given."
        },
        "add_subpath": {
          "signature": "add_subpath(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_tip": {
          "signature": "add_tip(tip=None, tip_shape=None, tip_length=None, tip_width=None, at_start=False)",
          "summary": "Adds a tip to the TipableVMobject instance, recognising",
          "doc": "Adds a tip to the TipableVMobject instance, recognising\nthat the endpoints might need to be switched if it's\na 'starting tip' or not."
        },
        "add_to_back": {
          "signature": "add_to_back(mobjects)",
          "summary": "Add all passed mobjects to the back of the submobjects.",
          "doc": "Add all passed mobjects to the back of the submobjects.\n\nIf :attr:`submobjects` already contains the given mobjects, they just get moved\nto the back instead.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\n\n.. note::\n\n    Technically, this is done by adding (or moving) the mobjects to\n    the head of :attr:`submobjects`. The head of this list is rendered\n    first, which places the corresponding mobjects behind the\n    subsequent list members.\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add`"
        },
        "add_updater": {
          "signature": "add_updater(update_function, index=None, call_updater=False)",
          "summary": "Add an update function to this mobject.",
          "doc": "Add an update function to this mobject.\n\nUpdate functions, or updaters in short, are functions that are applied to the\nMobject in every frame.\n\nParameters\n----------\nupdate_function\n    The update function to be added.\n    Whenever :meth:`update` is called, this update function gets called using\n    ``self`` as the first parameter.\n    The updater can have a second parameter ``dt``. If it uses this parameter,\n    it gets called using a second value ``dt``, usually representing the time\n    in seconds since the last call of :meth:`update`.\nindex\n    The index at which the new updater should be added in ``self.updaters``.\n    In case ``index`` is ``None`` the updater will be added at the end.\ncall_updater\n    Whether or not to call the updater initially. If ``True``, the updater will\n    be called using ``dt=0``.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n.. manim:: NextToUpdater\n\n    class NextToUpdater(Scene):\n        def construct(self):\n            def dot_position(mobject):\n                mobject.set_value(dot.get_center()[0])\n                mobject.next_to(dot)\n\n            dot = Dot(RIGHT*3)\n            label = DecimalNumber()\n            label.add_updater(dot_position)\n            self.add(dot, label)\n\n            self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))\n\n.. manim:: DtUpdater\n\n    class DtUpdater(Scene):\n        def construct(self):\n            square = Square()\n\n            #Let the square rotate 90\u00b0 per second\n            square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n            self.add(square)\n            self.wait(2)\n\nSee also\n--------\n:meth:`get_updaters`\n:meth:`remove_updater`\n:class:`~.UpdateFromFunc`"
        },
        "align_data": {
          "signature": "align_data(mobject, skip_point_alignment=False)",
          "summary": "Aligns the data of this mobject with another mobject.",
          "doc": "Aligns the data of this mobject with another mobject.\n\nAfterwards, the two mobjects will have the same number of submobjects\n(see :meth:`.align_submobjects`), the same parent structure (see\n:meth:`.null_point_align`). If ``skip_point_alignment`` is false,\nthey will also have the same number of points (see :meth:`.align_points`).\n\nParameters\n----------\nmobject\n    The other mobject this mobject should be aligned to.\nskip_point_alignment\n    Controls whether or not the computationally expensive\n    point alignment is skipped (default: False)."
        },
        "align_on_border": {
          "signature": "align_on_border(direction, buff=0.5)",
          "summary": "Direction just needs to be a vector pointing towards side or",
          "doc": "Direction just needs to be a vector pointing towards side or\ncorner in the 2d plane."
        },
        "align_points": {
          "signature": "align_points(vmobject)",
          "summary": "Adds points to self and vmobject so that they both have the same number of subpaths, with",
          "doc": "Adds points to self and vmobject so that they both have the same number of subpaths, with\ncorresponding subpaths each containing the same number of points.\n\nPoints are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting\nof a single point repeated.\n\nParameters\n----------\nvmobject\n    The object to align points with.\n\nReturns\n-------\n:class:`VMobject`\n   ``self``"
        },
        "align_points_with_larger": {
          "signature": "align_points_with_larger(larger_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_rgbas": {
          "signature": "align_rgbas(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_submobjects": {
          "signature": "align_submobjects(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_to": {
          "signature": "align_to(mobject_or_point, direction=[0. 0. 0.])",
          "summary": "Aligns mobject to another :class:`~.Mobject` in a certain direction.",
          "doc": "Aligns mobject to another :class:`~.Mobject` in a certain direction.\n\nExamples:\nmob1.align_to(mob2, UP) moves mob1 vertically so that its\ntop edge lines ups with mob2's top edge."
        },
        "append_points": {
          "signature": "append_points(new_points)",
          "summary": "Append the given ``new_points`` to the end of",
          "doc": "Append the given ``new_points`` to the end of\n:attr:`VMobject.points`.\n\nParameters\n----------\nnew_points\n    An array of 3D points to append.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``new_points``."
        },
        "append_vectorized_mobject": {
          "signature": "append_vectorized_mobject(vectorized_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_complex_function": {
          "signature": "apply_complex_function(function, kwargs)",
          "summary": "Applies a complex function to a :class:`Mobject`.",
          "doc": "Applies a complex function to a :class:`Mobject`.\nThe x and y Point3Ds correspond to the real and imaginary parts respectively.\n\nExample\n-------\n\n.. manim:: ApplyFuncExample\n\n    class ApplyFuncExample(Scene):\n        def construct(self):\n            circ = Circle().scale(1.5)\n            circ_ref = circ.copy()\n            circ.apply_complex_function(\n                lambda x: np.exp(x*1j)\n            )\n            t = ValueTracker(0)\n            circ.add_updater(\n                lambda x: x.become(circ_ref.copy().apply_complex_function(\n                    lambda x: np.exp(x+t.get_value()*1j)\n                )).set_color(BLUE)\n            )\n            self.add(circ_ref)\n            self.play(TransformFromCopy(circ_ref, circ))\n            self.play(t.animate.set_value(TAU), run_time=3)"
        },
        "apply_function": {
          "signature": "apply_function(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_position": {
          "signature": "apply_function_to_position(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_submobject_positions": {
          "signature": "apply_function_to_submobject_positions(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_matrix": {
          "signature": "apply_matrix(matrix, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_over_attr_arrays": {
          "signature": "apply_over_attr_arrays(func)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_points_function_about_point": {
          "signature": "apply_points_function_about_point(func, about_point=None, about_edge=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_to_family": {
          "signature": "apply_to_family(func)",
          "summary": "Apply a function to ``self`` and every submobject with points recursively.",
          "doc": "Apply a function to ``self`` and every submobject with points recursively.\n\nParameters\n----------\nfunc\n    The function to apply to each mobject. ``func`` gets passed the respective\n    (sub)mobject as parameter.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`family_members_with_points`"
        },
        "arrange": {
          "signature": "arrange(direction=[1. 0. 0.], buff=0.25, center=True, kwargs)",
          "summary": "Sorts :class:`~.Mobject` next to each other on screen.",
          "doc": "Sorts :class:`~.Mobject` next to each other on screen.\n\nExamples\n--------\n\n.. manim:: Example\n    :save_last_frame:\n\n    class Example(Scene):\n        def construct(self):\n            s1 = Square()\n            s2 = Square()\n            s3 = Square()\n            s4 = Square()\n            x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n            self.add(x)"
        },
        "arrange_in_grid": {
          "signature": "arrange_in_grid(rows=None, cols=None, buff=0.25, cell_alignment=[0. 0. 0.], row_alignments=None, col_alignments=None, row_heights=None, col_widths=None, flow_order='rd', kwargs)",
          "summary": "Arrange submobjects in a grid.",
          "doc": "Arrange submobjects in a grid.\n\nParameters\n----------\nrows\n    The number of rows in the grid.\ncols\n    The number of columns in the grid.\nbuff\n    The gap between grid cells. To specify a different buffer in the horizontal and\n    vertical directions, a tuple of two values can be given - ``(row, col)``.\ncell_alignment\n    The way each submobject is aligned in its grid cell.\nrow_alignments\n    The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n    up, ``\"c\"`` - center, ``\"d\"`` - down.\ncol_alignments\n    The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n    ``\"c\"`` - center, ``\"r\"`` - right.\nrow_heights\n    Defines a list of heights for certain rows (top to bottom). If the list contains\n    ``None``, the corresponding row will fit its height automatically based\n    on the highest element in that row.\ncol_widths\n    Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n    corresponding column will fit its width automatically based on the widest element in that column.\nflow_order\n    The order in which submobjects fill the grid. Can be one of the following values:\n    \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\nValueError\n    If ``rows`` and ``cols`` are too small to fit all submobjects.\nValueError\n    If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n    :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\nNotes\n-----\nIf only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\nenough to fit all submobjects. If neither is set, they will be chosen to be about the same,\ntending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\nIf both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\ndefined, the latter has higher priority.\n\nExamples\n--------\n.. manim:: ExampleBoxes\n    :save_last_frame:\n\n    class ExampleBoxes(Scene):\n        def construct(self):\n            boxes=VGroup(*[Square() for s in range(0,6)])\n            boxes.arrange_in_grid(rows=2, buff=0.1)\n            self.add(boxes)\n\n\n.. manim:: ArrangeInGrid\n    :save_last_frame:\n\n    class ArrangeInGrid(Scene):\n        def construct(self):\n            boxes = VGroup(*[\n                Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n                for i in range(24)\n            ])\n            self.add(boxes)\n\n            boxes.arrange_in_grid(\n                buff=(0.25,0.5),\n                col_alignments=\"lccccr\",\n                row_alignments=\"uccd\",\n                col_widths=[1, *[None]*4, 1],\n                row_heights=[1, None, None, 1],\n                flow_order=\"dr\"\n            )"
        },
        "arrange_submobjects": {
          "signature": "arrange_submobjects(args, kwargs)",
          "summary": "Arrange the position of :attr:`submobjects` with a small buffer.",
          "doc": "Arrange the position of :attr:`submobjects` with a small buffer.\n\nExamples\n--------\n\n.. manim:: ArrangeSumobjectsExample\n    :save_last_frame:\n\n    class ArrangeSumobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n            s.shift(UP).set_color(BLUE)\n            s2= s.copy().set_color(RED)\n            s2.arrange_submobjects()\n            s2.shift(DOWN)\n            self.add(s,s2)"
        },
        "asign_tip_attr": {
          "signature": "asign_tip_attr(tip, at_start)",
          "summary": "No documentation available.",
          "doc": null
        },
        "become": {
          "signature": "become(mobject, match_height=False, match_width=False, match_depth=False, match_center=False, stretch=False)",
          "summary": "Edit points, colors and submobjects to be identical",
          "doc": "Edit points, colors and submobjects to be identical\nto another :class:`~.Mobject`\n\n.. note::\n\n    If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`\n    will match the height first and then the width.\n\nParameters\n----------\nmatch_height\n    Whether or not to preserve the height of the original\n    :class:`~.Mobject`.\nmatch_width\n    Whether or not to preserve the width of the original\n    :class:`~.Mobject`.\nmatch_depth\n    Whether or not to preserve the depth of the original\n    :class:`~.Mobject`.\nmatch_center\n    Whether or not to preserve the center of the original\n    :class:`~.Mobject`.\nstretch\n    Whether or not to stretch the target mobject to match the\n    the proportions of the original :class:`~.Mobject`.\n\nExamples\n--------\n.. manim:: BecomeScene\n\n    class BecomeScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            circ.become(square)\n            self.wait(0.5)\n\n\nThe following examples illustrate how mobject measurements\nchange when using the ``match_...`` and ``stretch`` arguments.\nWe start with a rectangle that is 2 units high and 4 units wide,\nwhich we want to turn into a circle of radius 3::\n\n    >>> from manim import Rectangle, Circle\n    >>> import numpy as np\n    >>> rect = Rectangle(height=2, width=4)\n    >>> circ = Circle(radius=3)\n\nWith ``stretch=True``, the target circle is deformed to match\nthe proportions of the rectangle, which results in the target\nmobject being an ellipse with height 2 and width 4. We can\ncheck that the resulting points satisfy the ellipse equation\n:math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`\nbeing the semi-axes::\n\n    >>> result = rect.copy().become(circ, stretch=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(4.0))\n    >>> ellipse_points = np.array(result.get_anchors())\n    >>> ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)\n    >>> np.allclose(ellipse_eq, 1)\n    True\n\nWith ``match_height=True`` and ``match_width=True`` the circle is\nscaled such that the height or the width of the rectangle will\nbe preserved, respectively.\nThe points of the resulting mobject satisfy the circle equation\n:math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::\n\n    >>> result = rect.copy().become(circ, match_height=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(2.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 1)\n    True\n    >>> result = rect.copy().become(circ, match_width=True)\n    >>> result.height, result.width\n    (np.float64(4.0), np.float64(4.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 2**2)\n    True\n\nWith ``match_center=True``, the resulting mobject is moved such that\nits center is the same as the center of the original mobject::\n\n    >>> rect = rect.shift(np.array([0, 1, 0]))\n    >>> np.allclose(rect.get_center(), circ.get_center())\n    False\n    >>> result = rect.copy().become(circ, match_center=True)\n    >>> np.allclose(rect.get_center(), result.get_center())\n    True"
        },
        "center": {
          "signature": "center()",
          "summary": "Moves the center of the mobject to the center of the scene.",
          "doc": "Moves the center of the mobject to the center of the scene.\n\nReturns\n-------\n:class:`.Mobject`\n    The centered mobject."
        },
        "change_anchor_mode": {
          "signature": "change_anchor_mode(mode)",
          "summary": "Changes the anchor mode of the bezier curves.",
          "doc": "Changes the anchor mode of the bezier curves. This will modify the handles.\n\nThere can be only two modes, \"jagged\", and \"smooth\".\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "clear_points": {
          "signature": "clear_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "clear_updaters": {
          "signature": "clear_updaters(recursive=True)",
          "summary": "Remove every updater.",
          "doc": "Remove every updater.\n\nParameters\n----------\nrecursive\n    Whether to recursively call ``clear_updaters`` on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`remove_updater`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "close_path": {
          "signature": "close_path()",
          "summary": "No documentation available.",
          "doc": null
        },
        "color_using_background_image": {
          "signature": "color_using_background_image(background_image)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals": {
          "signature": "consider_points_equals(p0, p1)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals_2d": {
          "signature": "consider_points_equals_2d(p0, p1)",
          "summary": "Determine if two points are close enough to be considered equal.",
          "doc": "Determine if two points are close enough to be considered equal.\n\nThis uses the algorithm from np.isclose(), but expanded here for the\n2D point case. NumPy is overkill for such a small question.\nParameters\n----------\np0\n    first point\np1\n    second point\n\nReturns\n-------\nbool\n    whether two points considered close."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create and return an identical copy of the :class:`Mobject` including all",
          "doc": "Create and return an identical copy of the :class:`Mobject` including all\n:attr:`submobjects`.\n\nReturns\n-------\n:class:`Mobject`\n    The copy.\n\nNote\n----\nThe clone is initially not visible in the Scene, even if the original was."
        },
        "create_tip": {
          "signature": "create_tip(tip_shape=None, tip_length=None, tip_width=None, at_start=False)",
          "summary": "Stylises the tip, positions it spatially, and returns",
          "doc": "Stylises the tip, positions it spatially, and returns\nthe newly instantiated tip to the caller."
        },
        "fade": {
          "signature": "fade(darkness=0.5, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "fade_to": {
          "signature": "fade_to(color, alpha, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "family_members_with_points": {
          "signature": "family_members_with_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "flip": {
          "signature": "flip(axis=[0. 1. 0.], kwargs)",
          "summary": "Flips/Mirrors an mobject about its center.",
          "doc": "Flips/Mirrors an mobject about its center.\n\nExamples\n--------\n\n.. manim:: FlipExample\n    :save_last_frame:\n\n    class FlipExample(Scene):\n        def construct(self):\n            s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n            self.add(s)\n            s2= s.copy().flip()\n            self.add(s2)"
        },
        "force_direction": {
          "signature": "force_direction(target_direction)",
          "summary": "Makes sure that points are either directed clockwise or",
          "doc": "Makes sure that points are either directed clockwise or\ncounterclockwise.\n\nParameters\n----------\ntarget_direction\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "from_three_points": {
          "signature": "from_three_points(p1, p2, p3, kwargs)",
          "summary": "Returns a circle passing through the specified",
          "doc": "Returns a circle passing through the specified\nthree points.\n\nExample\n-------\n.. manim:: CircleFromPointsExample\n    :save_last_frame:\n\n    class CircleFromPointsExample(Scene):\n        def construct(self):\n            circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)\n            dots = VGroup(\n                Dot(LEFT),\n                Dot(LEFT + UP),\n                Dot(UP * 2),\n            )\n            self.add(NumberPlane(), circle, dots)"
        },
        "gen_cubic_bezier_tuples_from_points": {
          "signature": "gen_cubic_bezier_tuples_from_points(points)",
          "summary": "Returns the bezier tuples from an array of points.",
          "doc": "Returns the bezier tuples from an array of points.\n\nself.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])\nThis algorithm basically retrieve them by taking an element every n, where n is the number of control points\nof the bezier curve.\n\n\nParameters\n----------\npoints\n    Points from which control points will be extracted.\n\nReturns\n-------\ntuple\n    Bezier control points."
        },
        "gen_subpaths_from_points_2d": {
          "signature": "gen_subpaths_from_points_2d(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "generate_points": {
          "signature": "generate_points()",
          "summary": "Initializes :attr:`points` and therefore the shape.",
          "doc": "Initializes :attr:`points` and therefore the shape.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "generate_rgbas_array": {
          "signature": "generate_rgbas_array(color, opacity)",
          "summary": "First arg can be either a color, or a tuple/list of colors.",
          "doc": "First arg can be either a color, or a tuple/list of colors.\nLikewise, opacity can either be a float, or a tuple of floats.\nIf self.sheen_factor is not zero, and only\none color was passed in, a second slightly light color\nwill automatically be added for the gradient"
        },
        "generate_target": {
          "signature": "generate_target(use_deepcopy=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_points": {
          "signature": "get_all_points()",
          "summary": "Return all points from this mobject and all submobjects.",
          "doc": "Return all points from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_anchors": {
          "signature": "get_anchors()",
          "summary": "Returns the anchors of the curves forming the VMobject.",
          "doc": "Returns the anchors of the curves forming the VMobject.\n\nReturns\n-------\nPoint3D_Array\n    The anchors."
        },
        "get_anchors_and_handles": {
          "signature": "get_anchors_and_handles()",
          "summary": "Returns anchors1, handles1, handles2, anchors2,",
          "doc": "Returns anchors1, handles1, handles2, anchors2,\nwhere (anchors1[i], handles1[i], handles2[i], anchors2[i])\nwill be four points defining a cubic bezier curve\nfor any i in range(0, len(anchors1))\n\nReturns\n-------\n`list[Point3D_Array]`\n    Iterable of the anchors and handles."
        },
        "get_arc_center": {
          "signature": "get_arc_center(warning=True)",
          "summary": "Looks at the normals to the first two",
          "doc": "Looks at the normals to the first two\nanchors, and finds their intersection points"
        },
        "get_arc_length": {
          "signature": "get_arc_length(sample_points_per_curve=None)",
          "summary": "Return the approximated length of the whole curve.",
          "doc": "Return the approximated length of the whole curve.\n\nParameters\n----------\nsample_points_per_curve\n    Number of sample points per curve used to approximate the length. More points result in a better approximation.\n\nReturns\n-------\nfloat\n    The length of the :class:`VMobject`."
        },
        "get_array_attrs": {
          "signature": "get_array_attrs()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_background_image": {
          "signature": "get_background_image()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_bottom": {
          "signature": "get_bottom()",
          "summary": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_boundary_point": {
          "signature": "get_boundary_point(direction)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_center": {
          "signature": "get_center()",
          "summary": "Get center Point3Ds",
          "doc": "Get center Point3Ds"
        },
        "get_center_of_mass": {
          "signature": "get_center_of_mass()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_color": {
          "signature": "get_color()",
          "summary": "Returns the color of the :class:`~.Mobject` Examples",
          "doc": "Returns the color of the :class:`~.Mobject`\n\nExamples\n--------\n::\n\n    >>> from manim import Square, RED\n    >>> Square(color=RED).get_color() == RED\n    True"
        },
        "get_coord": {
          "signature": "get_coord(dim, direction=[0. 0. 0.])",
          "summary": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``",
          "doc": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``"
        },
        "get_corner": {
          "signature": "get_corner(direction)",
          "summary": "Get corner Point3Ds for certain direction.",
          "doc": "Get corner Point3Ds for certain direction."
        },
        "get_critical_point": {
          "signature": "get_critical_point(direction)",
          "summary": "Picture a box bounding the :class:`~.Mobject`.",
          "doc": "Picture a box bounding the :class:`~.Mobject`.  Such a box has\n9 'critical points': 4 corners, 4 edge center, the\ncenter. This returns one of them, along the given direction.\n\n::\n\n    sample = Arc(start_angle=PI / 7, angle=PI / 5)\n\n    # These are all equivalent\n    max_y_1 = sample.get_top()[1]\n    max_y_2 = sample.get_critical_point(UP)[1]\n    max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)"
        },
        "get_cubic_bezier_tuples": {
          "signature": "get_cubic_bezier_tuples()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_cubic_bezier_tuples_from_points": {
          "signature": "get_cubic_bezier_tuples_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_curve_functions": {
          "signature": "get_curve_functions()",
          "summary": "Gets the functions for the curves of the mobject.",
          "doc": "Gets the functions for the curves of the mobject.\n\nReturns\n-------\nIterable[Callable[[float], Point3D]]\n    The functions for the curves."
        },
        "get_curve_functions_with_lengths": {
          "signature": "get_curve_functions_with_lengths(kwargs)",
          "summary": "Gets the functions and lengths of the curves for the mobject.",
          "doc": "Gets the functions and lengths of the curves for the mobject.\n\nParameters\n----------\n**kwargs\n    The keyword arguments passed to :meth:`get_nth_curve_function_with_length`\n\nReturns\n-------\nIterable[tuple[Callable[[float], Point3D], float]]\n    The functions and lengths of the curves."
        },
        "get_default_tip_length": {
          "signature": "get_default_tip_length()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_direction": {
          "signature": "get_direction()",
          "summary": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.",
          "doc": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.\nThe direction of points determines in which direction the\nobject is drawn, clockwise or counterclockwise.\n\nExamples\n--------\nThe default direction of a :class:`~.Circle` is counterclockwise::\n\n    >>> from manim import Circle\n    >>> Circle().get_direction()\n    'CCW'\n\nReturns\n-------\n:class:`str`\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "get_edge_center": {
          "signature": "get_edge_center(direction)",
          "summary": "Get edge Point3Ds for certain direction.",
          "doc": "Get edge Point3Ds for certain direction."
        },
        "get_end": {
          "signature": "get_end()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends."
        },
        "get_end_anchors": {
          "signature": "get_end_anchors()",
          "summary": "Return the end anchors of the bezier curves.",
          "doc": "Return the end anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_extremum_along_dim": {
          "signature": "get_extremum_along_dim(points=None, dim=0, key=0)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family": {
          "signature": "get_family(recurse=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family_updaters": {
          "signature": "get_family_updaters()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_color": {
          "signature": "get_fill_color()",
          "summary": "If there are multiple colors (for gradient)",
          "doc": "If there are multiple colors (for gradient)\nthis returns the first one"
        },
        "get_fill_colors": {
          "signature": "get_fill_colors()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacities": {
          "signature": "get_fill_opacities()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacity": {
          "signature": "get_fill_opacity()",
          "summary": "If there are multiple opacities, this returns the",
          "doc": "If there are multiple opacities, this returns the\nfirst"
        },
        "get_fill_rgbas": {
          "signature": "get_fill_rgbas()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_first_handle": {
          "signature": "get_first_handle()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_gradient_start_and_end_points": {
          "signature": "get_gradient_start_and_end_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_group_class": {
          "signature": "get_group_class()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_image": {
          "signature": "get_image(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_last_handle": {
          "signature": "get_last_handle()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_last_point": {
          "signature": "get_last_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_left": {
          "signature": "get_left()",
          "summary": "Get left Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get left Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_length": {
          "signature": "get_length()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_merged_array": {
          "signature": "get_merged_array(array_attr)",
          "summary": "Return all of a given attribute from this mobject and all submobjects.",
          "doc": "Return all of a given attribute from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_midpoint": {
          "signature": "get_midpoint()",
          "summary": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.",
          "doc": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.\n\nExamples\n--------\n\n.. manim:: AngleMidPoint\n    :save_last_frame:\n\n    class AngleMidPoint(Scene):\n        def construct(self):\n            line1 = Line(ORIGIN, 2*RIGHT)\n            line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n            a = Angle(line1, line2, radius=1.5, other_angle=False)\n            d = Dot(a.get_midpoint()).set_color(RED)\n\n            self.add(line1, line2, a, d)\n            self.wait()"
        },
        "get_mobject_type_class": {
          "signature": "get_mobject_type_class()",
          "summary": "Return the base class of this mobject type.",
          "doc": "Return the base class of this mobject type."
        },
        "get_nadir": {
          "signature": "get_nadir()",
          "summary": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "get_nth_curve_function": {
          "signature": "get_nth_curve_function(n)",
          "summary": "Returns the expression of the nth curve.",
          "doc": "Returns the expression of the nth curve.\n\nParameters\n----------\nn\n    index of the desired curve.\n\nReturns\n-------\nCallable[float, Point3D]\n    expression of the nth bezier curve."
        },
        "get_nth_curve_function_with_length": {
          "signature": "get_nth_curve_function_with_length(n, sample_points=None)",
          "summary": "Returns the expression of the nth curve along with its (approximate) length.",
          "doc": "Returns the expression of the nth curve along with its (approximate) length.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\ncurve : Callable[[float], Point3D]\n    The function for the nth curve.\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length": {
          "signature": "get_nth_curve_length(n, sample_points=None)",
          "summary": "Returns the (approximate) length of the nth curve.",
          "doc": "Returns the (approximate) length of the nth curve.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length_pieces": {
          "signature": "get_nth_curve_length_pieces(n, sample_points=None)",
          "summary": "Returns the array of short line lengths used for length approximation.",
          "doc": "Returns the array of short line lengths used for length approximation.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\n    The short length-pieces of the nth curve."
        },
        "get_nth_curve_points": {
          "signature": "get_nth_curve_points(n)",
          "summary": "Returns the points defining the nth curve of the vmobject.",
          "doc": "Returns the points defining the nth curve of the vmobject.\n\nParameters\n----------\nn\n    index of the desired bezier curve.\n\nReturns\n-------\nCubicBezierPoints\n    points defining the nth bezier curve (anchors, handles)"
        },
        "get_num_curves": {
          "signature": "get_num_curves()",
          "summary": "Returns the number of curves of the vmobject.",
          "doc": "Returns the number of curves of the vmobject.\n\nReturns\n-------\nint\n    number of curves of the vmobject."
        },
        "get_num_points": {
          "signature": "get_num_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_pieces": {
          "signature": "get_pieces(n_pieces)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_point_mobject": {
          "signature": "get_point_mobject(center=None)",
          "summary": "The simplest :class:`~.Mobject` to be transformed to or from self.",
          "doc": "The simplest :class:`~.Mobject` to be transformed to or from self.\nShould by a point of the appropriate type"
        },
        "get_points_defining_boundary": {
          "signature": "get_points_defining_boundary()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_right": {
          "signature": "get_right()",
          "summary": "Get right Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get right Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_sheen_direction": {
          "signature": "get_sheen_direction()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_sheen_factor": {
          "signature": "get_sheen_factor()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_start": {
          "signature": "get_start()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts."
        },
        "get_start_anchors": {
          "signature": "get_start_anchors()",
          "summary": "Returns the start anchors of the bezier curves.",
          "doc": "Returns the start anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_start_and_end": {
          "signature": "get_start_and_end()",
          "summary": "Returns starting and ending point of a stroke as a ``tuple``.",
          "doc": "Returns starting and ending point of a stroke as a ``tuple``."
        },
        "get_stroke_color": {
          "signature": "get_stroke_color(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_colors": {
          "signature": "get_stroke_colors(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacities": {
          "signature": "get_stroke_opacities(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacity": {
          "signature": "get_stroke_opacity(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_rgbas": {
          "signature": "get_stroke_rgbas(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_width": {
          "signature": "get_stroke_width(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_style": {
          "signature": "get_style(simple=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_subcurve": {
          "signature": "get_subcurve(a, b)",
          "summary": "Returns the subcurve of the VMobject between the interval [a, b].",
          "doc": "Returns the subcurve of the VMobject between the interval [a, b].\nThe curve is a VMobject itself.\n\nParameters\n----------\n\na\n    The lower bound.\nb\n    The upper bound.\n\nReturns\n-------\nVMobject\n    The subcurve between of [a, b]"
        },
        "get_subpaths": {
          "signature": "get_subpaths()",
          "summary": "Returns subpaths formed by the curves of the VMobject.",
          "doc": "Returns subpaths formed by the curves of the VMobject.\n\nSubpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.\n\nReturns\n-------\nlist[CubicSpline]\n    subpaths."
        },
        "get_subpaths_from_points": {
          "signature": "get_subpaths_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_time_based_updaters": {
          "signature": "get_time_based_updaters()",
          "summary": "Return all updaters using the ``dt`` parameter.",
          "doc": "Return all updaters using the ``dt`` parameter.\n\nThe updaters use this parameter as the input for difference in time.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of time based updaters.\n\nSee Also\n--------\n:meth:`get_updaters`\n:meth:`has_time_based_updater`"
        },
        "get_tip": {
          "signature": "get_tip()",
          "summary": "Returns the TipableVMobject instance's (first) tip,",
          "doc": "Returns the TipableVMobject instance's (first) tip,\notherwise throws an exception."
        },
        "get_tips": {
          "signature": "get_tips()",
          "summary": "Returns a VGroup (collection of VMobjects) containing",
          "doc": "Returns a VGroup (collection of VMobjects) containing\nthe TipableVMObject instance's tips."
        },
        "get_top": {
          "signature": "get_top()",
          "summary": "Get top Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get top Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_unpositioned_tip": {
          "signature": "get_unpositioned_tip(tip_shape=None, tip_length=None, tip_width=None)",
          "summary": "Returns a tip that has been stylistically configured,",
          "doc": "Returns a tip that has been stylistically configured,\nbut has not yet been given a position in space."
        },
        "get_updaters": {
          "signature": "get_updaters()",
          "summary": "Return all updaters.",
          "doc": "Return all updaters.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of updaters.\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_time_based_updaters`"
        },
        "get_x": {
          "signature": "get_x(direction=[0. 0. 0.])",
          "summary": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_y": {
          "signature": "get_y(direction=[0. 0. 0.])",
          "summary": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z": {
          "signature": "get_z(direction=[0. 0. 0.])",
          "summary": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z_index_reference_point": {
          "signature": "get_z_index_reference_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_zenith": {
          "signature": "get_zenith()",
          "summary": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "has_new_path_started": {
          "signature": "has_new_path_started()",
          "summary": "No documentation available.",
          "doc": null
        },
        "has_no_points": {
          "signature": "has_no_points()",
          "summary": "Check if :class:`~.Mobject` *does not* contains points.",
          "doc": "Check if :class:`~.Mobject` *does not* contains points."
        },
        "has_points": {
          "signature": "has_points()",
          "summary": "Check if :class:`~.Mobject` contains points.",
          "doc": "Check if :class:`~.Mobject` contains points."
        },
        "has_start_tip": {
          "signature": "has_start_tip()",
          "summary": "No documentation available.",
          "doc": null
        },
        "has_time_based_updater": {
          "signature": "has_time_based_updater()",
          "summary": "Test if ``self`` has a time based updater.",
          "doc": "Test if ``self`` has a time based updater.\n\nReturns\n-------\n:class:`bool`\n    ``True`` if at least one updater uses the ``dt`` parameter, ``False``\n    otherwise.\n\nSee Also\n--------\n:meth:`get_time_based_updaters`"
        },
        "has_tip": {
          "signature": "has_tip()",
          "summary": "No documentation available.",
          "doc": null
        },
        "init_colors": {
          "signature": "init_colors(propagate_colors=True)",
          "summary": "Initializes the colors.",
          "doc": "Initializes the colors.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "init_points": {
          "signature": "init_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "insert": {
          "signature": "insert(index, mobject)",
          "summary": "Inserts a mobject at a specific position into self.submobjects Effectively just calls  ``self.submobjects.insert(index, mobject)``,",
          "doc": "Inserts a mobject at a specific position into self.submobjects\n\nEffectively just calls  ``self.submobjects.insert(index, mobject)``,\nwhere ``self.submobjects`` is a list.\n\nHighly adapted from ``Mobject.add``.\n\nParameters\n----------\nindex\n    The index at which\nmobject\n    The mobject to be inserted."
        },
        "insert_n_curves": {
          "signature": "insert_n_curves(n)",
          "summary": "Inserts n curves to the bezier curves of the vmobject.",
          "doc": "Inserts n curves to the bezier curves of the vmobject.\n\nParameters\n----------\nn\n    Number of curves to insert.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "insert_n_curves_to_point_list": {
          "signature": "insert_n_curves_to_point_list(n, points)",
          "summary": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.",
          "doc": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.\n\nParameters\n----------\nn\n    Number of desired curves.\npoints\n    Starting points.\n\nReturns\n-------\n    Points generated."
        },
        "interpolate": {
          "signature": "interpolate(mobject1, mobject2, alpha, path_func=<function interpolate at 0x109973f60>)",
          "summary": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``",
          "doc": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``\nand ``mobject2``.\n\nExamples\n--------\n\n.. manim:: DotInterpolation\n    :save_last_frame:\n\n    class DotInterpolation(Scene):\n        def construct(self):\n            dotR = Dot(color=DARK_GREY)\n            dotR.shift(2 * RIGHT)\n            dotL = Dot(color=WHITE)\n            dotL.shift(2 * LEFT)\n\n            dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n            self.add(dotL, dotR, dotMiddle)"
        },
        "interpolate_color": {
          "signature": "interpolate_color(mobject1, mobject2, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "invert": {
          "signature": "invert(recursive=False)",
          "summary": "Inverts the list of :attr:`submobjects`.",
          "doc": "Inverts the list of :attr:`submobjects`.\n\nParameters\n----------\nrecursive\n    If ``True``, all submobject lists of this mobject's family are inverted.\n\nExamples\n--------\n\n.. manim:: InvertSumobjectsExample\n\n    class InvertSumobjectsExample(Scene):\n        def construct(self):\n            s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2 = s.copy()\n            s2.invert()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "is_closed": {
          "signature": "is_closed()",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_off_screen": {
          "signature": "is_off_screen()",
          "summary": "No documentation available.",
          "doc": null
        },
        "length_over_dim": {
          "signature": "length_over_dim(dim)",
          "summary": "Measure the length of an :class:`~.Mobject` in a certain direction.",
          "doc": "Measure the length of an :class:`~.Mobject` in a certain direction."
        },
        "make_jagged": {
          "signature": "make_jagged()",
          "summary": "No documentation available.",
          "doc": null
        },
        "make_smooth": {
          "signature": "make_smooth()",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_background_image": {
          "signature": "match_background_image(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_color": {
          "signature": "match_color(mobject)",
          "summary": "Match the color with the color of another :class:`~.Mobject`.",
          "doc": "Match the color with the color of another :class:`~.Mobject`."
        },
        "match_coord": {
          "signature": "match_coord(mobject, dim, direction=[0. 0. 0.])",
          "summary": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`.",
          "doc": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`."
        },
        "match_depth": {
          "signature": "match_depth(mobject, kwargs)",
          "summary": "Match the depth with the depth of another :class:`~.Mobject`.",
          "doc": "Match the depth with the depth of another :class:`~.Mobject`."
        },
        "match_dim_size": {
          "signature": "match_dim_size(mobject, dim, kwargs)",
          "summary": "Match the specified dimension with the dimension of another :class:`~.Mobject`.",
          "doc": "Match the specified dimension with the dimension of another :class:`~.Mobject`."
        },
        "match_height": {
          "signature": "match_height(mobject, kwargs)",
          "summary": "Match the height with the height of another :class:`~.Mobject`.",
          "doc": "Match the height with the height of another :class:`~.Mobject`."
        },
        "match_points": {
          "signature": "match_points(mobject, copy_submobjects=True)",
          "summary": "Edit points, positions, and submobjects to be identical",
          "doc": "Edit points, positions, and submobjects to be identical\nto another :class:`~.Mobject`, while keeping the style unchanged.\n\nExamples\n--------\n.. manim:: MatchPointsScene\n\n    class MatchPointsScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)"
        },
        "match_style": {
          "signature": "match_style(vmobject, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_updaters": {
          "signature": "match_updaters(mobject)",
          "summary": "Match the updaters of the given mobject.",
          "doc": "Match the updaters of the given mobject.\n\nParameters\n----------\nmobject\n    The mobject whose updaters get matched.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nNote\n----\nAll updaters from submobjects are removed, but only updaters of the given\nmobject are matched, not those of it's submobjects.\n\nSee also\n--------\n:meth:`add_updater`\n:meth:`clear_updaters`"
        },
        "match_width": {
          "signature": "match_width(mobject, kwargs)",
          "summary": "Match the width with the width of another :class:`~.Mobject`.",
          "doc": "Match the width with the width of another :class:`~.Mobject`."
        },
        "match_x": {
          "signature": "match_x(mobject, direction=[0. 0. 0.])",
          "summary": "Match x coord.",
          "doc": "Match x coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_y": {
          "signature": "match_y(mobject, direction=[0. 0. 0.])",
          "summary": "Match y coord.",
          "doc": "Match y coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_z": {
          "signature": "match_z(mobject, direction=[0. 0. 0.])",
          "summary": "Match z coord.",
          "doc": "Match z coord. to the x coord. of another :class:`~.Mobject`."
        },
        "move_arc_center_to": {
          "signature": "move_arc_center_to(point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "move_to": {
          "signature": "move_to(point_or_mobject, aligned_edge=[0. 0. 0.], coor_mask=[1 1 1])",
          "summary": "Move center of the :class:`~.Mobject` to certain Point3D.",
          "doc": "Move center of the :class:`~.Mobject` to certain Point3D."
        },
        "next_to": {
          "signature": "next_to(mobject_or_point, direction=[1. 0. 0.], buff=0.25, aligned_edge=[0. 0. 0.], submobject_to_align=None, index_of_submobject_to_align=None, coor_mask=[1 1 1])",
          "summary": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.",
          "doc": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.\n\nExamples\n--------\n\n.. manim:: GeometricShapes\n    :save_last_frame:\n\n    class GeometricShapes(Scene):\n        def construct(self):\n            d = Dot()\n            c = Circle()\n            s = Square()\n            t = Triangle()\n            d.next_to(c, RIGHT)\n            s.next_to(c, LEFT)\n            t.next_to(c, DOWN)\n            self.add(d, c, s, t)"
        },
        "nonempty_submobjects": {
          "signature": "nonempty_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "null_point_align": {
          "signature": "null_point_align(mobject)",
          "summary": "If a :class:`~.Mobject` with points is being aligned to",
          "doc": "If a :class:`~.Mobject` with points is being aligned to\none without, treat both as groups, and push\nthe one with points into its own submobjects\nlist.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``"
        },
        "point_at_angle": {
          "signature": "point_at_angle(angle)",
          "summary": "Returns the position of a point on the circle.",
          "doc": "Returns the position of a point on the circle.\n\nParameters\n----------\nangle\n    The angle of the point along the circle in radians.\n\nReturns\n-------\n:class:`numpy.ndarray`\n    The location of the point along the circle's circumference.\n\nExamples\n--------\n.. manim:: PointAtAngleExample\n    :save_last_frame:\n\n    class PointAtAngleExample(Scene):\n        def construct(self):\n            circle = Circle(radius=2.0)\n            p1 = circle.point_at_angle(PI/2)\n            p2 = circle.point_at_angle(270*DEGREES)\n\n            s1 = Square(side_length=0.25).move_to(p1)\n            s2 = Square(side_length=0.25).move_to(p2)\n            self.add(circle, s1, s2)"
        },
        "point_from_proportion": {
          "signature": "point_from_proportion(alpha)",
          "summary": "Gets the point at a proportion along the path of the :class:`VMobject`.",
          "doc": "Gets the point at a proportion along the path of the :class:`VMobject`.\n\nParameters\n----------\nalpha\n    The proportion along the the path of the :class:`VMobject`.\n\nReturns\n-------\n:class:`numpy.ndarray`\n    The point on the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``alpha`` is not between 0 and 1.\n:exc:`Exception`\n    If the :class:`VMobject` has no points.\n\nExample\n-------\n.. manim:: PointFromProportion\n    :save_last_frame:\n\n    class PointFromProportion(Scene):\n        def construct(self):\n            line = Line(2*DL, 2*UR)\n            self.add(line)\n            colors = (RED, BLUE, YELLOW)\n            proportions = (1/4, 1/2, 3/4)\n            for color, proportion in zip(colors, proportions):\n                self.add(Dot(color=color).move_to(\n                        line.point_from_proportion(proportion)\n                ))"
        },
        "pointwise_become_partial": {
          "signature": "pointwise_become_partial(vmobject, a, b)",
          "summary": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and",
          "doc": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and\nan upper bound ``b``, modify this :class:`.VMobject`'s points to\nmatch the portion of the B\u00e9zier spline described by ``vmobject.points``\nwith the parameter ``t`` between ``a`` and ``b``.\n\nParameters\n----------\nvmobject\n    The :class:`.VMobject` that will serve as a model.\na\n    The lower bound for ``t``.\nb\n    The upper bound for ``t``\n\nReturns\n-------\n:class:`.VMobject`\n    The :class:`.VMobject` itself, after the transformation.\n\nRaises\n------\nTypeError\n    If ``vmobject`` is not an instance of :class:`VMobject`."
        },
        "pop_tips": {
          "signature": "pop_tips()",
          "summary": "No documentation available.",
          "doc": null
        },
        "pose_at_angle": {
          "signature": "pose_at_angle(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "position_tip": {
          "signature": "position_tip(tip, at_start=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "proportion_from_point": {
          "signature": "proportion_from_point(point)",
          "summary": "Returns the proportion along the path of the :class:`VMobject`",
          "doc": "Returns the proportion along the path of the :class:`VMobject`\na particular given point is at.\n\nParameters\n----------\npoint\n    The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`\n\nReturns\n-------\nfloat\n    The proportion along the path of the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``point`` does not lie on the curve.\n:exc:`Exception`\n    If the :class:`VMobject` has no points."
        },
        "push_self_into_submobjects": {
          "signature": "push_self_into_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "put_start_and_end_on": {
          "signature": "put_start_and_end_on(start, end)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reduce_across_dimension": {
          "signature": "reduce_across_dimension(reduce_func, dim)",
          "summary": "Find the min or max value from a dimension across all points in this and submobjects.",
          "doc": "Find the min or max value from a dimension across all points in this and submobjects."
        },
        "remove": {
          "signature": "remove(mobjects)",
          "summary": "Remove :attr:`submobjects`.",
          "doc": "Remove :attr:`submobjects`.\n\nThe mobjects are removed from :attr:`submobjects`, if they exist.\n\nSubclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to remove.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add`"
        },
        "remove_updater": {
          "signature": "remove_updater(update_function)",
          "summary": "Remove an updater.",
          "doc": "Remove an updater.\n\nIf the same updater is applied multiple times, every instance gets removed.\n\nParameters\n----------\nupdate_function\n    The update function to be removed.\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`clear_updaters`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "repeat": {
          "signature": "repeat(count)",
          "summary": "This can make transition animations nicer",
          "doc": "This can make transition animations nicer"
        },
        "repeat_submobject": {
          "signature": "repeat_submobject(submob)",
          "summary": "No documentation available.",
          "doc": null
        },
        "replace": {
          "signature": "replace(mobject, dim_to_match=0, stretch=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "rescale_to_fit": {
          "signature": "rescale_to_fit(length, dim, stretch=False, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reset_endpoints_based_on_tip": {
          "signature": "reset_endpoints_based_on_tip(tip, at_start)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reset_points": {
          "signature": "reset_points()",
          "summary": "Sets :attr:`points` to be an empty array.",
          "doc": "Sets :attr:`points` to be an empty array."
        },
        "resize_points": {
          "signature": "resize_points(new_length, resize_func=<function resize_array at 0x1056ab380>)",
          "summary": "Resize the array of anchor points and handles to have",
          "doc": "Resize the array of anchor points and handles to have\nthe specified size.\n\nParameters\n----------\nnew_length\n    The new (total) number of points.\nresize_func\n    A function mapping a Numpy array (the points) and an integer\n    (the target size) to a Numpy array. The default implementation\n    is based on Numpy's ``resize`` function."
        },
        "restore": {
          "signature": "restore()",
          "summary": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`.",
          "doc": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`."
        },
        "resume_updating": {
          "signature": "resume_updating(recursive=True)",
          "summary": "Enable updating from updaters and animations.",
          "doc": "Enable updating from updaters and animations.\n\nParameters\n----------\nrecursive\n    Whether to recursively enable updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`suspend_updating`\n:meth:`add_updater`"
        },
        "reverse_direction": {
          "signature": "reverse_direction()",
          "summary": "Reverts the point direction by inverting the point order.",
          "doc": "Reverts the point direction by inverting the point order.\n\nReturns\n-------\n:class:`VMobject`\n    Returns self.\n\nExamples\n--------\n.. manim:: ChangeOfDirection\n\n    class ChangeOfDirection(Scene):\n        def construct(self):\n            ccw = RegularPolygon(5)\n            ccw.shift(LEFT)\n            cw = RegularPolygon(5)\n            cw.shift(RIGHT).reverse_direction()\n\n            self.play(Create(ccw), Create(cw),\n            run_time=4)"
        },
        "reverse_points": {
          "signature": "reverse_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "rotate": {
          "signature": "rotate(angle, axis=[0. 0. 1.], about_point=None, kwargs)",
          "summary": "Rotates the :class:`~.Mobject` about a certain point.",
          "doc": "Rotates the :class:`~.Mobject` about a certain point."
        },
        "rotate_about_origin": {
          "signature": "rotate_about_origin(angle, axis=[0. 0. 1.], axes=[])",
          "summary": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0].",
          "doc": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0]."
        },
        "rotate_sheen_direction": {
          "signature": "rotate_sheen_direction(angle, axis=[0. 0. 1.], family=True)",
          "summary": "Rotates the direction of the applied sheen.",
          "doc": "Rotates the direction of the applied sheen.\n\nParameters\n----------\nangle\n    Angle by which the direction of sheen is rotated.\naxis\n    Axis of rotation.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen_direction`"
        },
        "save_image": {
          "signature": "save_image(name=None)",
          "summary": "Saves an image of only this :class:`Mobject` at its position to a png",
          "doc": "Saves an image of only this :class:`Mobject` at its position to a png\nfile."
        },
        "save_state": {
          "signature": "save_state()",
          "summary": "Save the current state (position, color & size).",
          "doc": "Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`."
        },
        "scale": {
          "signature": "scale(scale_factor, scale_stroke=False, kwargs)",
          "summary": "Scale the size by a factor.",
          "doc": "Scale the size by a factor.\n\nDefault behavior is to scale about the center of the vmobject.\n\nParameters\n----------\nscale_factor\n    The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n    will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n    if :math:`\\alpha < 0`, the mobject is also flipped.\nscale_stroke\n    Boolean determining if the object's outline is scaled when the object is scaled.\n    If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.\nkwargs\n    Additional keyword arguments passed to\n    :meth:`~.Mobject.scale`.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n\n.. manim:: MobjectScaleExample\n    :save_last_frame:\n\n    class MobjectScaleExample(Scene):\n        def construct(self):\n            c1 = Circle(1, RED).set_x(-1)\n            c2 = Circle(1, GREEN).set_x(1)\n\n            vg = VGroup(c1, c2)\n            vg.set_stroke(width=50)\n            self.add(vg)\n\n            self.play(\n                c1.animate.scale(.25),\n                c2.animate.scale(.25,\n                    scale_stroke=True)\n            )\n\nSee also\n--------\n:meth:`move_to`"
        },
        "scale_handle_to_anchor_distances": {
          "signature": "scale_handle_to_anchor_distances(factor)",
          "summary": "If the distance between a given handle point H and its associated",
          "doc": "If the distance between a given handle point H and its associated\nanchor point A is d, then it changes H to be a distances factor*d\naway from A, but so that the line from A to H doesn't change.\nThis is mostly useful in the context of applying a (differentiable)\nfunction, to preserve tangency properties.  One would pull all the\nhandles closer to their anchors, apply the function then push them out\nagain.\n\nParameters\n----------\nfactor\n    The factor used for scaling.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "scale_to_fit_depth": {
          "signature": "scale_to_fit_depth(depth, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional."
        },
        "scale_to_fit_height": {
          "signature": "scale_to_fit_height(height, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.scale_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(5.0)"
        },
        "scale_to_fit_width": {
          "signature": "scale_to_fit_width(width, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.scale_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(5.0)"
        },
        "set": {
          "signature": "set(kwargs)",
          "summary": "Sets attributes.",
          "doc": "Sets attributes.\n\nI.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.\n\nThis is a convenience to be used along with :attr:`animate` to\nanimate setting attributes.\n\nIn addition to this method, there is a compatibility\nlayer that allows ``get_*`` and ``set_*`` methods to\nget and set generic attributes. For instance::\n\n    >>> mob = Mobject()\n    >>> mob.set_foo(0)\n    Mobject\n    >>> mob.get_foo()\n    0\n    >>> mob.foo\n    0\n\nThis compatibility layer does not interfere with any\n``get_*`` or ``set_*`` methods that are explicitly\ndefined.\n\n.. warning::\n\n    This compatibility layer is for backwards compatibility\n    and is not guaranteed to stay around. Where applicable,\n    please prefer getting/setting attributes normally or with\n    the :meth:`set` method.\n\nParameters\n----------\n**kwargs\n    The attributes and corresponding values to set.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> mob = Mobject()\n    >>> mob.set(foo=0)\n    Mobject\n    >>> mob.foo\n    0"
        },
        "set_anchors_and_handles": {
          "signature": "set_anchors_and_handles(anchors1, handles1, handles2, anchors2)",
          "summary": "Given two sets of anchors and handles, process them to set them as anchors",
          "doc": "Given two sets of anchors and handles, process them to set them as anchors\nand handles of the VMobject.\n\nanchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier\ncurve of the vmobject. There are four hardcoded parameters and this is a\nproblem as it makes the number of points per cubic curve unchangeable from 4\n(two anchors and two handles).\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "set_background_stroke": {
          "signature": "set_background_stroke(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_cap_style": {
          "signature": "set_cap_style(cap_style)",
          "summary": "Sets the cap style of the :class:`VMobject`.",
          "doc": "Sets the cap style of the :class:`VMobject`.\n\nParameters\n----------\ncap_style\n    The cap style to be set. See :class:`.CapStyleType` for options.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: CapStyleExample\n    :save_last_frame:\n\n    class CapStyleExample(Scene):\n        def construct(self):\n            line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n            line.set_cap_style(CapStyleType.ROUND)\n            self.add(line)"
        },
        "set_color": {
          "signature": "set_color(color, family=True)",
          "summary": "Condition is function which takes in one arguments, (x, y, z).",
          "doc": "Condition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color"
        },
        "set_color_by_gradient": {
          "signature": "set_color_by_gradient(colors)",
          "summary": "Parameters",
          "doc": "Parameters\n----------\ncolors\n    The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.\n\nself.color = ManimColor.parse(color)\nreturn self"
        },
        "set_colors_by_radial_gradient": {
          "signature": "set_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_coord": {
          "signature": "set_coord(value, dim, direction=[0. 0. 0.])",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_fill": {
          "signature": "set_fill(color=None, opacity=None, family=True)",
          "summary": "Set the fill color and fill opacity of a :class:`VMobject`.",
          "doc": "Set the fill color and fill opacity of a :class:`VMobject`.\n\nParameters\n----------\ncolor\n    Fill color of the :class:`VMobject`.\nopacity\n    Fill opacity of the :class:`VMobject`.\nfamily\n    If ``True``, the fill color of all submobjects is also set.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: SetFill\n    :save_last_frame:\n\n    class SetFill(Scene):\n        def construct(self):\n            square = Square().scale(2).set_fill(WHITE,1)\n            circle1 = Circle().set_fill(GREEN,0.8)\n            circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n            circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n            group = Group(circle1,circle2,circle3).arrange()\n            self.add(square)\n            self.add(group)\n\nSee Also\n--------\n:meth:`~.VMobject.set_style`"
        },
        "set_opacity": {
          "signature": "set_opacity(opacity, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_points": {
          "signature": "set_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_points_as_corners": {
          "signature": "set_points_as_corners(points)",
          "summary": "Given an array of points, set them as corners of the",
          "doc": "Given an array of points, set them as corners of the\n:class:`VMobject`.\n\nTo achieve that, this algorithm sets handles aligned with the anchors\nsuch that the resultant B\u00e9zier curve will be the segment between the\ntwo anchors.\n\nParameters\n----------\npoints\n    Array of points that will be set as corners.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after setting the new points as corners.\n\n\nExamples\n--------\n.. manim:: PointsAsCornersExample\n    :save_last_frame:\n\n    class PointsAsCornersExample(Scene):\n        def construct(self):\n            corners = (\n                # create square\n                UR, UL,\n                DL, DR,\n                UR,\n                # create crosses\n                DL, UL,\n                DR\n            )\n            vmob = VMobject(stroke_color=RED)\n            vmob.set_points_as_corners(corners).scale(2)\n            self.add(vmob)"
        },
        "set_points_smoothly": {
          "signature": "set_points_smoothly(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_shade_in_3d": {
          "signature": "set_shade_in_3d(value=True, z_index_as_group=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_sheen": {
          "signature": "set_sheen(factor, direction=None, family=True)",
          "summary": "Applies a color gradient from a direction.",
          "doc": "Applies a color gradient from a direction.\n\nParameters\n----------\nfactor\n    The extent of lustre/gradient to apply. If negative, the gradient\n    starts from black, if positive the gradient starts from white and\n    changes to the current color.\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\n.. manim:: SetSheen\n    :save_last_frame:\n\n    class SetSheen(Scene):\n        def construct(self):\n            circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n            self.add(circle)"
        },
        "set_sheen_direction": {
          "signature": "set_sheen_direction(direction, family=True)",
          "summary": "Sets the direction of the applied sheen.",
          "doc": "Sets the direction of the applied sheen.\n\nParameters\n----------\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen`\n:meth:`~.VMobject.rotate_sheen_direction`"
        },
        "set_stroke": {
          "signature": "set_stroke(color=None, width=None, opacity=None, background=False, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_style": {
          "signature": "set_style(fill_color=None, fill_opacity=None, stroke_color=None, stroke_width=None, stroke_opacity=None, background_stroke_color=None, background_stroke_width=None, background_stroke_opacity=None, sheen_factor=None, sheen_direction=None, background_image=None, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_gradient": {
          "signature": "set_submobject_colors_by_gradient(colors)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_radial_gradient": {
          "signature": "set_submobject_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_x": {
          "signature": "set_x(x, direction=[0. 0. 0.])",
          "summary": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_y": {
          "signature": "set_y(y, direction=[0. 0. 0.])",
          "summary": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z": {
          "signature": "set_z(z, direction=[0. 0. 0.])",
          "summary": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z_index": {
          "signature": "set_z_index(z_index_value, family=True)",
          "summary": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.",
          "doc": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.\n\nParameters\n----------\nz_index_value\n    The new value of :attr:`z_index` set.\nfamily\n    If ``True``, the :attr:`z_index` value of all submobjects is also set.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)\n\nExamples\n--------\n.. manim:: SetZIndex\n    :save_last_frame:\n\n    class SetZIndex(Scene):\n        def construct(self):\n            text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n            square = Square(2, fill_opacity=1).set_z_index(2)\n            tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n            circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n            # Displaying order is now defined by z_index values\n            self.add(text)\n            self.add(square)\n            self.add(tex)\n            self.add(circle)"
        },
        "set_z_index_by_z_Point3D": {
          "signature": "set_z_index_by_z_Point3D()",
          "summary": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.",
          "doc": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)"
        },
        "shift": {
          "signature": "shift(vectors)",
          "summary": "Shift by the given vectors.",
          "doc": "Shift by the given vectors.\n\nParameters\n----------\nvectors\n    Vectors to shift by. If multiple vectors are given, they are added\n    together.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`move_to`"
        },
        "shift_onto_screen": {
          "signature": "shift_onto_screen(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "show": {
          "signature": "show(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "shuffle": {
          "signature": "shuffle(recursive=False)",
          "summary": "Shuffles the list of :attr:`submobjects`.",
          "doc": "Shuffles the list of :attr:`submobjects`."
        },
        "shuffle_submobjects": {
          "signature": "shuffle_submobjects(args, kwargs)",
          "summary": "Shuffles the order of :attr:`submobjects` Examples",
          "doc": "Shuffles the order of :attr:`submobjects`\n\nExamples\n--------\n\n.. manim:: ShuffleSubmobjectsExample\n\n    class ShuffleSubmobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2= s.copy()\n            s2.shuffle_submobjects()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "sort": {
          "signature": "sort(point_to_num_func=<function Mobject.<lambda> at 0x10a232660>, submob_func=None)",
          "summary": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.",
          "doc": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."
        },
        "sort_submobjects": {
          "signature": "sort_submobjects(args, kwargs)",
          "summary": "Sort the :attr:`submobjects`",
          "doc": "Sort the :attr:`submobjects`"
        },
        "space_out_submobjects": {
          "signature": "space_out_submobjects(factor=1.5, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "split": {
          "signature": "split()",
          "summary": "No documentation available.",
          "doc": null
        },
        "start_new_path": {
          "signature": "start_new_path(point)",
          "summary": "Append a ``point`` to the :attr:`VMobject.points`, which will be the",
          "doc": "Append a ``point`` to the :attr:`VMobject.points`, which will be the\nbeginning of a new B\u00e9zier curve in the path given by the points. If\nthere's an unfinished curve at the end of :attr:`VMobject.points`,\ncomplete it by appending the last B\u00e9zier curve's start anchor as many\ntimes as needed.\n\nParameters\n----------\npoint\n    A 3D point to append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``point`` and starting a new\n    curve."
        },
        "stop_angle": {
          "signature": "stop_angle()",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch": {
          "signature": "stretch(factor, dim, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_about_point": {
          "signature": "stretch_about_point(factor, dim, point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_to_fit_depth": {
          "signature": "stretch_to_fit_depth(depth, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional."
        },
        "stretch_to_fit_height": {
          "signature": "stretch_to_fit_height(height, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(2.0)"
        },
        "stretch_to_fit_width": {
          "signature": "stretch_to_fit_width(width, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(2.0)"
        },
        "surround": {
          "signature": "surround(mobject, dim_to_match=0, stretch=False, buffer_factor=1.2)",
          "summary": "Modifies a circle so that it surrounds a given mobject.",
          "doc": "Modifies a circle so that it surrounds a given mobject.\n\nParameters\n----------\nmobject\n    The mobject that the circle will be surrounding.\ndim_to_match\nbuffer_factor\n    Scales the circle with respect to the mobject. A `buffer_factor` < 1 makes the circle smaller than the mobject.\nstretch\n    Stretches the circle to fit more tightly around the mobject. Note: Does not work with :class:`Line`\n\nExamples\n--------\n.. manim:: CircleSurround\n    :save_last_frame:\n\n    class CircleSurround(Scene):\n        def construct(self):\n            triangle1 = Triangle()\n            circle1 = Circle().surround(triangle1)\n            group1 = Group(triangle1,circle1) # treat the two mobjects as one\n\n            line2 = Line()\n            circle2 = Circle().surround(line2, buffer_factor=2.0)\n            group2 = Group(line2,circle2)\n\n            # buffer_factor < 1, so the circle is smaller than the square\n            square3 = Square()\n            circle3 = Circle().surround(square3, buffer_factor=0.5)\n            group3 = Group(square3, circle3)\n\n            group = Group(group1, group2, group3).arrange(buff=1)\n            self.add(group)"
        },
        "suspend_updating": {
          "signature": "suspend_updating(recursive=True)",
          "summary": "Disable updating from updaters and animations.",
          "doc": "Disable updating from updaters and animations.\n\n\nParameters\n----------\nrecursive\n    Whether to recursively suspend updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`resume_updating`\n:meth:`add_updater`"
        },
        "throw_error_if_no_points": {
          "signature": "throw_error_if_no_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "to_corner": {
          "signature": "to_corner(corner=[-1. -1.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given corner of the screen.",
          "doc": "Moves this :class:`~.Mobject` to the given corner of the screen.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToCornerExample\n    :save_last_frame:\n\n    class ToCornerExample(Scene):\n        def construct(self):\n            c = Circle()\n            c.to_corner(UR)\n            t = Tex(\"To the corner!\")\n            t2 = MathTex(\"x^3\").shift(DOWN)\n            self.add(c,t,t2)\n            t.to_corner(DL, buff=0)\n            t2.to_corner(UL, buff=1.5)"
        },
        "to_edge": {
          "signature": "to_edge(edge=[-1.  0.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given edge of the screen,",
          "doc": "Moves this :class:`~.Mobject` to the given edge of the screen,\nwithout affecting its position in the other dimension.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToEdgeExample\n    :save_last_frame:\n\n    class ToEdgeExample(Scene):\n        def construct(self):\n            tex_top = Tex(\"I am at the top!\")\n            tex_top.to_edge(UP)\n            tex_side = Tex(\"I am moving to the side!\")\n            c = Circle().shift(2*DOWN)\n            self.add(tex_top, tex_side, c)\n            tex_side.to_edge(LEFT)\n            c.to_edge(RIGHT, buff=0)"
        },
        "to_original_color": {
          "signature": "to_original_color()",
          "summary": "No documentation available.",
          "doc": null
        },
        "update": {
          "signature": "update(dt=0, recursive=True)",
          "summary": "Apply all updaters.",
          "doc": "Apply all updaters.\n\nDoes nothing if updating is suspended.\n\nParameters\n----------\ndt\n    The parameter ``dt`` to pass to the update functions. Usually this is the\n    time in seconds since the last call of ``update``.\nrecursive\n    Whether to recursively update all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "update_rgbas_array": {
          "signature": "update_rgbas_array(array_name, color=None, opacity=None)",
          "summary": "No documentation available.",
          "doc": null
        }
      },
      "doc": "A circle.\n\nParameters\n----------\ncolor\n    The color of the shape.\nkwargs\n    Additional arguments to be passed to :class:`Arc`\n\nExamples\n--------\n.. manim:: CircleExample\n    :save_last_frame:\n\n    class CircleExample(Scene):\n        def construct(self):\n            circle_1 = Circle(radius=1.0)\n            circle_2 = Circle(radius=1.5, color=GREEN)\n            circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)\n\n            circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)\n            self.add(circle_group)"
    },
    "Square": {
      "module": "manim.mobject.geometry.polygram",
      "summary": "A rectangle with equal side lengths.",
      "bases": [
        "Rectangle"
      ],
      "methods": {
        "__add__": {
          "signature": "__add__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__deepcopy__": {
          "signature": "__deepcopy__(clone_from_id)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getattr__": {
          "signature": "__getattr__(attr)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getitem__": {
          "signature": "__getitem__(value)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iadd__": {
          "signature": "__iadd__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__init__": {
          "signature": "__init__(side_length=2.0, kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__isub__": {
          "signature": "__isub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iter__": {
          "signature": "__iter__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__len__": {
          "signature": "__len__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__sub__": {
          "signature": "__sub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add": {
          "signature": "add(mobjects)",
          "summary": "Add mobjects as submobjects.",
          "doc": "Add mobjects as submobjects.\n\nThe mobjects are added to :attr:`submobjects`.\n\nSubclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add_to_back`\n\nExamples\n--------\n::\n\n    >>> outer = Mobject()\n    >>> inner = Mobject()\n    >>> outer = outer.add(inner)\n\nDuplicates are not added again::\n\n    >>> outer = outer.add(inner)\n    >>> len(outer.submobjects)\n    1\n\nOnly Mobjects can be added::\n\n    >>> outer.add(3)\n    Traceback (most recent call last):\n    ...\n    TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.\n\nAdding an object to itself raises an error::\n\n    >>> outer.add(outer)\n    Traceback (most recent call last):\n    ...\n    ValueError: Cannot add Mobject as a submobject of itself (at index 0).\n\nA given mobject cannot be added as a submobject\ntwice to some parent::\n\n    >>> parent = Mobject(name=\"parent\")\n    >>> child = Mobject(name=\"child\")\n    >>> parent.add(child, child)\n    [...] WARNING  ...\n    parent\n    >>> parent.submobjects\n    [child]"
        },
        "add_background_rectangle": {
          "signature": "add_background_rectangle(color=None, opacity=0.75, kwargs)",
          "summary": "Add a BackgroundRectangle as submobject.",
          "doc": "Add a BackgroundRectangle as submobject.\n\nThe BackgroundRectangle is added behind other submobjects.\n\nThis can be used to increase the mobjects visibility in front of a noisy background.\n\nParameters\n----------\ncolor\n    The color of the BackgroundRectangle\nopacity\n    The opacity of the BackgroundRectangle\nkwargs\n    Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_to_back`\n:class:`~.BackgroundRectangle`"
        },
        "add_background_rectangle_to_family_members_with_points": {
          "signature": "add_background_rectangle_to_family_members_with_points(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_background_rectangle_to_submobjects": {
          "signature": "add_background_rectangle_to_submobjects(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve": {
          "signature": "add_cubic_bezier_curve(anchor1, handle1, handle2, anchor2)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve_to": {
          "signature": "add_cubic_bezier_curve_to(handle1, handle2, anchor)",
          "summary": "Add cubic bezier curve to the path.",
          "doc": "Add cubic bezier curve to the path.\n\nNOTE : the first anchor is not a parameter as by default the end of the last sub-path!\n\nParameters\n----------\nhandle1\n    first handle\nhandle2\n    second handle\nanchor\n    anchor\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_cubic_bezier_curves": {
          "signature": "add_cubic_bezier_curves(curves)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_line_to": {
          "signature": "add_line_to(point)",
          "summary": "Add a straight line from the last point of VMobject to the given point.",
          "doc": "Add a straight line from the last point of VMobject to the given point.\n\nParameters\n----------\n\npoint\n    The end of the straight line.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_n_more_submobjects": {
          "signature": "add_n_more_submobjects(n)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_points_as_corners": {
          "signature": "add_points_as_corners(points)",
          "summary": "Append multiple straight lines at the end of",
          "doc": "Append multiple straight lines at the end of\n:attr:`VMobject.points`, which connect the given ``points`` in order\nstarting from the end of the current path. These ``points`` would be\ntherefore the corners of the new polyline appended to the path.\n\nParameters\n----------\npoints\n    An array of 3D points representing the corners of the polyline to\n    append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending the straight lines to its\n    path."
        },
        "add_quadratic_bezier_curve_to": {
          "signature": "add_quadratic_bezier_curve_to(handle, anchor)",
          "summary": "Add Quadratic bezier curve to the path.",
          "doc": "Add Quadratic bezier curve to the path.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_smooth_curve_to": {
          "signature": "add_smooth_curve_to(points)",
          "summary": "Creates a smooth curve from given points and add it to the VMobject.",
          "doc": "Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted\nas a handle, the second as an anchor.\n\nParameters\n----------\npoints\n    Points (anchor and handle, or just anchor) to add a smooth curve from\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nRaises\n------\nValueError\n    If 0 or more than 2 points are given."
        },
        "add_subpath": {
          "signature": "add_subpath(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_to_back": {
          "signature": "add_to_back(mobjects)",
          "summary": "Add all passed mobjects to the back of the submobjects.",
          "doc": "Add all passed mobjects to the back of the submobjects.\n\nIf :attr:`submobjects` already contains the given mobjects, they just get moved\nto the back instead.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\n\n.. note::\n\n    Technically, this is done by adding (or moving) the mobjects to\n    the head of :attr:`submobjects`. The head of this list is rendered\n    first, which places the corresponding mobjects behind the\n    subsequent list members.\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add`"
        },
        "add_updater": {
          "signature": "add_updater(update_function, index=None, call_updater=False)",
          "summary": "Add an update function to this mobject.",
          "doc": "Add an update function to this mobject.\n\nUpdate functions, or updaters in short, are functions that are applied to the\nMobject in every frame.\n\nParameters\n----------\nupdate_function\n    The update function to be added.\n    Whenever :meth:`update` is called, this update function gets called using\n    ``self`` as the first parameter.\n    The updater can have a second parameter ``dt``. If it uses this parameter,\n    it gets called using a second value ``dt``, usually representing the time\n    in seconds since the last call of :meth:`update`.\nindex\n    The index at which the new updater should be added in ``self.updaters``.\n    In case ``index`` is ``None`` the updater will be added at the end.\ncall_updater\n    Whether or not to call the updater initially. If ``True``, the updater will\n    be called using ``dt=0``.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n.. manim:: NextToUpdater\n\n    class NextToUpdater(Scene):\n        def construct(self):\n            def dot_position(mobject):\n                mobject.set_value(dot.get_center()[0])\n                mobject.next_to(dot)\n\n            dot = Dot(RIGHT*3)\n            label = DecimalNumber()\n            label.add_updater(dot_position)\n            self.add(dot, label)\n\n            self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))\n\n.. manim:: DtUpdater\n\n    class DtUpdater(Scene):\n        def construct(self):\n            square = Square()\n\n            #Let the square rotate 90\u00b0 per second\n            square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n            self.add(square)\n            self.wait(2)\n\nSee also\n--------\n:meth:`get_updaters`\n:meth:`remove_updater`\n:class:`~.UpdateFromFunc`"
        },
        "align_data": {
          "signature": "align_data(mobject, skip_point_alignment=False)",
          "summary": "Aligns the data of this mobject with another mobject.",
          "doc": "Aligns the data of this mobject with another mobject.\n\nAfterwards, the two mobjects will have the same number of submobjects\n(see :meth:`.align_submobjects`), the same parent structure (see\n:meth:`.null_point_align`). If ``skip_point_alignment`` is false,\nthey will also have the same number of points (see :meth:`.align_points`).\n\nParameters\n----------\nmobject\n    The other mobject this mobject should be aligned to.\nskip_point_alignment\n    Controls whether or not the computationally expensive\n    point alignment is skipped (default: False)."
        },
        "align_on_border": {
          "signature": "align_on_border(direction, buff=0.5)",
          "summary": "Direction just needs to be a vector pointing towards side or",
          "doc": "Direction just needs to be a vector pointing towards side or\ncorner in the 2d plane."
        },
        "align_points": {
          "signature": "align_points(vmobject)",
          "summary": "Adds points to self and vmobject so that they both have the same number of subpaths, with",
          "doc": "Adds points to self and vmobject so that they both have the same number of subpaths, with\ncorresponding subpaths each containing the same number of points.\n\nPoints are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting\nof a single point repeated.\n\nParameters\n----------\nvmobject\n    The object to align points with.\n\nReturns\n-------\n:class:`VMobject`\n   ``self``"
        },
        "align_points_with_larger": {
          "signature": "align_points_with_larger(larger_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_rgbas": {
          "signature": "align_rgbas(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_submobjects": {
          "signature": "align_submobjects(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_to": {
          "signature": "align_to(mobject_or_point, direction=[0. 0. 0.])",
          "summary": "Aligns mobject to another :class:`~.Mobject` in a certain direction.",
          "doc": "Aligns mobject to another :class:`~.Mobject` in a certain direction.\n\nExamples:\nmob1.align_to(mob2, UP) moves mob1 vertically so that its\ntop edge lines ups with mob2's top edge."
        },
        "append_points": {
          "signature": "append_points(new_points)",
          "summary": "Append the given ``new_points`` to the end of",
          "doc": "Append the given ``new_points`` to the end of\n:attr:`VMobject.points`.\n\nParameters\n----------\nnew_points\n    An array of 3D points to append.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``new_points``."
        },
        "append_vectorized_mobject": {
          "signature": "append_vectorized_mobject(vectorized_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_complex_function": {
          "signature": "apply_complex_function(function, kwargs)",
          "summary": "Applies a complex function to a :class:`Mobject`.",
          "doc": "Applies a complex function to a :class:`Mobject`.\nThe x and y Point3Ds correspond to the real and imaginary parts respectively.\n\nExample\n-------\n\n.. manim:: ApplyFuncExample\n\n    class ApplyFuncExample(Scene):\n        def construct(self):\n            circ = Circle().scale(1.5)\n            circ_ref = circ.copy()\n            circ.apply_complex_function(\n                lambda x: np.exp(x*1j)\n            )\n            t = ValueTracker(0)\n            circ.add_updater(\n                lambda x: x.become(circ_ref.copy().apply_complex_function(\n                    lambda x: np.exp(x+t.get_value()*1j)\n                )).set_color(BLUE)\n            )\n            self.add(circ_ref)\n            self.play(TransformFromCopy(circ_ref, circ))\n            self.play(t.animate.set_value(TAU), run_time=3)"
        },
        "apply_function": {
          "signature": "apply_function(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_position": {
          "signature": "apply_function_to_position(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_submobject_positions": {
          "signature": "apply_function_to_submobject_positions(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_matrix": {
          "signature": "apply_matrix(matrix, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_over_attr_arrays": {
          "signature": "apply_over_attr_arrays(func)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_points_function_about_point": {
          "signature": "apply_points_function_about_point(func, about_point=None, about_edge=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_to_family": {
          "signature": "apply_to_family(func)",
          "summary": "Apply a function to ``self`` and every submobject with points recursively.",
          "doc": "Apply a function to ``self`` and every submobject with points recursively.\n\nParameters\n----------\nfunc\n    The function to apply to each mobject. ``func`` gets passed the respective\n    (sub)mobject as parameter.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`family_members_with_points`"
        },
        "arrange": {
          "signature": "arrange(direction=[1. 0. 0.], buff=0.25, center=True, kwargs)",
          "summary": "Sorts :class:`~.Mobject` next to each other on screen.",
          "doc": "Sorts :class:`~.Mobject` next to each other on screen.\n\nExamples\n--------\n\n.. manim:: Example\n    :save_last_frame:\n\n    class Example(Scene):\n        def construct(self):\n            s1 = Square()\n            s2 = Square()\n            s3 = Square()\n            s4 = Square()\n            x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n            self.add(x)"
        },
        "arrange_in_grid": {
          "signature": "arrange_in_grid(rows=None, cols=None, buff=0.25, cell_alignment=[0. 0. 0.], row_alignments=None, col_alignments=None, row_heights=None, col_widths=None, flow_order='rd', kwargs)",
          "summary": "Arrange submobjects in a grid.",
          "doc": "Arrange submobjects in a grid.\n\nParameters\n----------\nrows\n    The number of rows in the grid.\ncols\n    The number of columns in the grid.\nbuff\n    The gap between grid cells. To specify a different buffer in the horizontal and\n    vertical directions, a tuple of two values can be given - ``(row, col)``.\ncell_alignment\n    The way each submobject is aligned in its grid cell.\nrow_alignments\n    The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n    up, ``\"c\"`` - center, ``\"d\"`` - down.\ncol_alignments\n    The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n    ``\"c\"`` - center, ``\"r\"`` - right.\nrow_heights\n    Defines a list of heights for certain rows (top to bottom). If the list contains\n    ``None``, the corresponding row will fit its height automatically based\n    on the highest element in that row.\ncol_widths\n    Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n    corresponding column will fit its width automatically based on the widest element in that column.\nflow_order\n    The order in which submobjects fill the grid. Can be one of the following values:\n    \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\nValueError\n    If ``rows`` and ``cols`` are too small to fit all submobjects.\nValueError\n    If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n    :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\nNotes\n-----\nIf only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\nenough to fit all submobjects. If neither is set, they will be chosen to be about the same,\ntending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\nIf both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\ndefined, the latter has higher priority.\n\nExamples\n--------\n.. manim:: ExampleBoxes\n    :save_last_frame:\n\n    class ExampleBoxes(Scene):\n        def construct(self):\n            boxes=VGroup(*[Square() for s in range(0,6)])\n            boxes.arrange_in_grid(rows=2, buff=0.1)\n            self.add(boxes)\n\n\n.. manim:: ArrangeInGrid\n    :save_last_frame:\n\n    class ArrangeInGrid(Scene):\n        def construct(self):\n            boxes = VGroup(*[\n                Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n                for i in range(24)\n            ])\n            self.add(boxes)\n\n            boxes.arrange_in_grid(\n                buff=(0.25,0.5),\n                col_alignments=\"lccccr\",\n                row_alignments=\"uccd\",\n                col_widths=[1, *[None]*4, 1],\n                row_heights=[1, None, None, 1],\n                flow_order=\"dr\"\n            )"
        },
        "arrange_submobjects": {
          "signature": "arrange_submobjects(args, kwargs)",
          "summary": "Arrange the position of :attr:`submobjects` with a small buffer.",
          "doc": "Arrange the position of :attr:`submobjects` with a small buffer.\n\nExamples\n--------\n\n.. manim:: ArrangeSumobjectsExample\n    :save_last_frame:\n\n    class ArrangeSumobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n            s.shift(UP).set_color(BLUE)\n            s2= s.copy().set_color(RED)\n            s2.arrange_submobjects()\n            s2.shift(DOWN)\n            self.add(s,s2)"
        },
        "become": {
          "signature": "become(mobject, match_height=False, match_width=False, match_depth=False, match_center=False, stretch=False)",
          "summary": "Edit points, colors and submobjects to be identical",
          "doc": "Edit points, colors and submobjects to be identical\nto another :class:`~.Mobject`\n\n.. note::\n\n    If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`\n    will match the height first and then the width.\n\nParameters\n----------\nmatch_height\n    Whether or not to preserve the height of the original\n    :class:`~.Mobject`.\nmatch_width\n    Whether or not to preserve the width of the original\n    :class:`~.Mobject`.\nmatch_depth\n    Whether or not to preserve the depth of the original\n    :class:`~.Mobject`.\nmatch_center\n    Whether or not to preserve the center of the original\n    :class:`~.Mobject`.\nstretch\n    Whether or not to stretch the target mobject to match the\n    the proportions of the original :class:`~.Mobject`.\n\nExamples\n--------\n.. manim:: BecomeScene\n\n    class BecomeScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            circ.become(square)\n            self.wait(0.5)\n\n\nThe following examples illustrate how mobject measurements\nchange when using the ``match_...`` and ``stretch`` arguments.\nWe start with a rectangle that is 2 units high and 4 units wide,\nwhich we want to turn into a circle of radius 3::\n\n    >>> from manim import Rectangle, Circle\n    >>> import numpy as np\n    >>> rect = Rectangle(height=2, width=4)\n    >>> circ = Circle(radius=3)\n\nWith ``stretch=True``, the target circle is deformed to match\nthe proportions of the rectangle, which results in the target\nmobject being an ellipse with height 2 and width 4. We can\ncheck that the resulting points satisfy the ellipse equation\n:math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`\nbeing the semi-axes::\n\n    >>> result = rect.copy().become(circ, stretch=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(4.0))\n    >>> ellipse_points = np.array(result.get_anchors())\n    >>> ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)\n    >>> np.allclose(ellipse_eq, 1)\n    True\n\nWith ``match_height=True`` and ``match_width=True`` the circle is\nscaled such that the height or the width of the rectangle will\nbe preserved, respectively.\nThe points of the resulting mobject satisfy the circle equation\n:math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::\n\n    >>> result = rect.copy().become(circ, match_height=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(2.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 1)\n    True\n    >>> result = rect.copy().become(circ, match_width=True)\n    >>> result.height, result.width\n    (np.float64(4.0), np.float64(4.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 2**2)\n    True\n\nWith ``match_center=True``, the resulting mobject is moved such that\nits center is the same as the center of the original mobject::\n\n    >>> rect = rect.shift(np.array([0, 1, 0]))\n    >>> np.allclose(rect.get_center(), circ.get_center())\n    False\n    >>> result = rect.copy().become(circ, match_center=True)\n    >>> np.allclose(rect.get_center(), result.get_center())\n    True"
        },
        "center": {
          "signature": "center()",
          "summary": "Moves the center of the mobject to the center of the scene.",
          "doc": "Moves the center of the mobject to the center of the scene.\n\nReturns\n-------\n:class:`.Mobject`\n    The centered mobject."
        },
        "change_anchor_mode": {
          "signature": "change_anchor_mode(mode)",
          "summary": "Changes the anchor mode of the bezier curves.",
          "doc": "Changes the anchor mode of the bezier curves. This will modify the handles.\n\nThere can be only two modes, \"jagged\", and \"smooth\".\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "clear_points": {
          "signature": "clear_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "clear_updaters": {
          "signature": "clear_updaters(recursive=True)",
          "summary": "Remove every updater.",
          "doc": "Remove every updater.\n\nParameters\n----------\nrecursive\n    Whether to recursively call ``clear_updaters`` on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`remove_updater`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "close_path": {
          "signature": "close_path()",
          "summary": "No documentation available.",
          "doc": null
        },
        "color_using_background_image": {
          "signature": "color_using_background_image(background_image)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals": {
          "signature": "consider_points_equals(p0, p1)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals_2d": {
          "signature": "consider_points_equals_2d(p0, p1)",
          "summary": "Determine if two points are close enough to be considered equal.",
          "doc": "Determine if two points are close enough to be considered equal.\n\nThis uses the algorithm from np.isclose(), but expanded here for the\n2D point case. NumPy is overkill for such a small question.\nParameters\n----------\np0\n    first point\np1\n    second point\n\nReturns\n-------\nbool\n    whether two points considered close."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create and return an identical copy of the :class:`Mobject` including all",
          "doc": "Create and return an identical copy of the :class:`Mobject` including all\n:attr:`submobjects`.\n\nReturns\n-------\n:class:`Mobject`\n    The copy.\n\nNote\n----\nThe clone is initially not visible in the Scene, even if the original was."
        },
        "fade": {
          "signature": "fade(darkness=0.5, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "fade_to": {
          "signature": "fade_to(color, alpha, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "family_members_with_points": {
          "signature": "family_members_with_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "flip": {
          "signature": "flip(axis=[0. 1. 0.], kwargs)",
          "summary": "Flips/Mirrors an mobject about its center.",
          "doc": "Flips/Mirrors an mobject about its center.\n\nExamples\n--------\n\n.. manim:: FlipExample\n    :save_last_frame:\n\n    class FlipExample(Scene):\n        def construct(self):\n            s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n            self.add(s)\n            s2= s.copy().flip()\n            self.add(s2)"
        },
        "force_direction": {
          "signature": "force_direction(target_direction)",
          "summary": "Makes sure that points are either directed clockwise or",
          "doc": "Makes sure that points are either directed clockwise or\ncounterclockwise.\n\nParameters\n----------\ntarget_direction\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "gen_cubic_bezier_tuples_from_points": {
          "signature": "gen_cubic_bezier_tuples_from_points(points)",
          "summary": "Returns the bezier tuples from an array of points.",
          "doc": "Returns the bezier tuples from an array of points.\n\nself.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])\nThis algorithm basically retrieve them by taking an element every n, where n is the number of control points\nof the bezier curve.\n\n\nParameters\n----------\npoints\n    Points from which control points will be extracted.\n\nReturns\n-------\ntuple\n    Bezier control points."
        },
        "gen_subpaths_from_points_2d": {
          "signature": "gen_subpaths_from_points_2d(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "generate_points": {
          "signature": "generate_points()",
          "summary": "Initializes :attr:`points` and therefore the shape.",
          "doc": "Initializes :attr:`points` and therefore the shape.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "generate_rgbas_array": {
          "signature": "generate_rgbas_array(color, opacity)",
          "summary": "First arg can be either a color, or a tuple/list of colors.",
          "doc": "First arg can be either a color, or a tuple/list of colors.\nLikewise, opacity can either be a float, or a tuple of floats.\nIf self.sheen_factor is not zero, and only\none color was passed in, a second slightly light color\nwill automatically be added for the gradient"
        },
        "generate_target": {
          "signature": "generate_target(use_deepcopy=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_points": {
          "signature": "get_all_points()",
          "summary": "Return all points from this mobject and all submobjects.",
          "doc": "Return all points from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_anchors": {
          "signature": "get_anchors()",
          "summary": "Returns the anchors of the curves forming the VMobject.",
          "doc": "Returns the anchors of the curves forming the VMobject.\n\nReturns\n-------\nPoint3D_Array\n    The anchors."
        },
        "get_anchors_and_handles": {
          "signature": "get_anchors_and_handles()",
          "summary": "Returns anchors1, handles1, handles2, anchors2,",
          "doc": "Returns anchors1, handles1, handles2, anchors2,\nwhere (anchors1[i], handles1[i], handles2[i], anchors2[i])\nwill be four points defining a cubic bezier curve\nfor any i in range(0, len(anchors1))\n\nReturns\n-------\n`list[Point3D_Array]`\n    Iterable of the anchors and handles."
        },
        "get_arc_length": {
          "signature": "get_arc_length(sample_points_per_curve=None)",
          "summary": "Return the approximated length of the whole curve.",
          "doc": "Return the approximated length of the whole curve.\n\nParameters\n----------\nsample_points_per_curve\n    Number of sample points per curve used to approximate the length. More points result in a better approximation.\n\nReturns\n-------\nfloat\n    The length of the :class:`VMobject`."
        },
        "get_array_attrs": {
          "signature": "get_array_attrs()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_background_image": {
          "signature": "get_background_image()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_bottom": {
          "signature": "get_bottom()",
          "summary": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_boundary_point": {
          "signature": "get_boundary_point(direction)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_center": {
          "signature": "get_center()",
          "summary": "Get center Point3Ds",
          "doc": "Get center Point3Ds"
        },
        "get_center_of_mass": {
          "signature": "get_center_of_mass()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_color": {
          "signature": "get_color()",
          "summary": "Returns the color of the :class:`~.Mobject` Examples",
          "doc": "Returns the color of the :class:`~.Mobject`\n\nExamples\n--------\n::\n\n    >>> from manim import Square, RED\n    >>> Square(color=RED).get_color() == RED\n    True"
        },
        "get_coord": {
          "signature": "get_coord(dim, direction=[0. 0. 0.])",
          "summary": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``",
          "doc": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``"
        },
        "get_corner": {
          "signature": "get_corner(direction)",
          "summary": "Get corner Point3Ds for certain direction.",
          "doc": "Get corner Point3Ds for certain direction."
        },
        "get_critical_point": {
          "signature": "get_critical_point(direction)",
          "summary": "Picture a box bounding the :class:`~.Mobject`.",
          "doc": "Picture a box bounding the :class:`~.Mobject`.  Such a box has\n9 'critical points': 4 corners, 4 edge center, the\ncenter. This returns one of them, along the given direction.\n\n::\n\n    sample = Arc(start_angle=PI / 7, angle=PI / 5)\n\n    # These are all equivalent\n    max_y_1 = sample.get_top()[1]\n    max_y_2 = sample.get_critical_point(UP)[1]\n    max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)"
        },
        "get_cubic_bezier_tuples": {
          "signature": "get_cubic_bezier_tuples()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_cubic_bezier_tuples_from_points": {
          "signature": "get_cubic_bezier_tuples_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_curve_functions": {
          "signature": "get_curve_functions()",
          "summary": "Gets the functions for the curves of the mobject.",
          "doc": "Gets the functions for the curves of the mobject.\n\nReturns\n-------\nIterable[Callable[[float], Point3D]]\n    The functions for the curves."
        },
        "get_curve_functions_with_lengths": {
          "signature": "get_curve_functions_with_lengths(kwargs)",
          "summary": "Gets the functions and lengths of the curves for the mobject.",
          "doc": "Gets the functions and lengths of the curves for the mobject.\n\nParameters\n----------\n**kwargs\n    The keyword arguments passed to :meth:`get_nth_curve_function_with_length`\n\nReturns\n-------\nIterable[tuple[Callable[[float], Point3D], float]]\n    The functions and lengths of the curves."
        },
        "get_direction": {
          "signature": "get_direction()",
          "summary": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.",
          "doc": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.\nThe direction of points determines in which direction the\nobject is drawn, clockwise or counterclockwise.\n\nExamples\n--------\nThe default direction of a :class:`~.Circle` is counterclockwise::\n\n    >>> from manim import Circle\n    >>> Circle().get_direction()\n    'CCW'\n\nReturns\n-------\n:class:`str`\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "get_edge_center": {
          "signature": "get_edge_center(direction)",
          "summary": "Get edge Point3Ds for certain direction.",
          "doc": "Get edge Point3Ds for certain direction."
        },
        "get_end": {
          "signature": "get_end()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends."
        },
        "get_end_anchors": {
          "signature": "get_end_anchors()",
          "summary": "Return the end anchors of the bezier curves.",
          "doc": "Return the end anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_extremum_along_dim": {
          "signature": "get_extremum_along_dim(points=None, dim=0, key=0)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family": {
          "signature": "get_family(recurse=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family_updaters": {
          "signature": "get_family_updaters()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_color": {
          "signature": "get_fill_color()",
          "summary": "If there are multiple colors (for gradient)",
          "doc": "If there are multiple colors (for gradient)\nthis returns the first one"
        },
        "get_fill_colors": {
          "signature": "get_fill_colors()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacities": {
          "signature": "get_fill_opacities()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacity": {
          "signature": "get_fill_opacity()",
          "summary": "If there are multiple opacities, this returns the",
          "doc": "If there are multiple opacities, this returns the\nfirst"
        },
        "get_fill_rgbas": {
          "signature": "get_fill_rgbas()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_gradient_start_and_end_points": {
          "signature": "get_gradient_start_and_end_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_group_class": {
          "signature": "get_group_class()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_image": {
          "signature": "get_image(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_last_point": {
          "signature": "get_last_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_left": {
          "signature": "get_left()",
          "summary": "Get left Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get left Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_merged_array": {
          "signature": "get_merged_array(array_attr)",
          "summary": "Return all of a given attribute from this mobject and all submobjects.",
          "doc": "Return all of a given attribute from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_midpoint": {
          "signature": "get_midpoint()",
          "summary": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.",
          "doc": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.\n\nExamples\n--------\n\n.. manim:: AngleMidPoint\n    :save_last_frame:\n\n    class AngleMidPoint(Scene):\n        def construct(self):\n            line1 = Line(ORIGIN, 2*RIGHT)\n            line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n            a = Angle(line1, line2, radius=1.5, other_angle=False)\n            d = Dot(a.get_midpoint()).set_color(RED)\n\n            self.add(line1, line2, a, d)\n            self.wait()"
        },
        "get_mobject_type_class": {
          "signature": "get_mobject_type_class()",
          "summary": "Return the base class of this mobject type.",
          "doc": "Return the base class of this mobject type."
        },
        "get_nadir": {
          "signature": "get_nadir()",
          "summary": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "get_nth_curve_function": {
          "signature": "get_nth_curve_function(n)",
          "summary": "Returns the expression of the nth curve.",
          "doc": "Returns the expression of the nth curve.\n\nParameters\n----------\nn\n    index of the desired curve.\n\nReturns\n-------\nCallable[float, Point3D]\n    expression of the nth bezier curve."
        },
        "get_nth_curve_function_with_length": {
          "signature": "get_nth_curve_function_with_length(n, sample_points=None)",
          "summary": "Returns the expression of the nth curve along with its (approximate) length.",
          "doc": "Returns the expression of the nth curve along with its (approximate) length.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\ncurve : Callable[[float], Point3D]\n    The function for the nth curve.\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length": {
          "signature": "get_nth_curve_length(n, sample_points=None)",
          "summary": "Returns the (approximate) length of the nth curve.",
          "doc": "Returns the (approximate) length of the nth curve.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length_pieces": {
          "signature": "get_nth_curve_length_pieces(n, sample_points=None)",
          "summary": "Returns the array of short line lengths used for length approximation.",
          "doc": "Returns the array of short line lengths used for length approximation.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\n    The short length-pieces of the nth curve."
        },
        "get_nth_curve_points": {
          "signature": "get_nth_curve_points(n)",
          "summary": "Returns the points defining the nth curve of the vmobject.",
          "doc": "Returns the points defining the nth curve of the vmobject.\n\nParameters\n----------\nn\n    index of the desired bezier curve.\n\nReturns\n-------\nCubicBezierPoints\n    points defining the nth bezier curve (anchors, handles)"
        },
        "get_num_curves": {
          "signature": "get_num_curves()",
          "summary": "Returns the number of curves of the vmobject.",
          "doc": "Returns the number of curves of the vmobject.\n\nReturns\n-------\nint\n    number of curves of the vmobject."
        },
        "get_num_points": {
          "signature": "get_num_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_pieces": {
          "signature": "get_pieces(n_pieces)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_point_mobject": {
          "signature": "get_point_mobject(center=None)",
          "summary": "The simplest :class:`~.Mobject` to be transformed to or from self.",
          "doc": "The simplest :class:`~.Mobject` to be transformed to or from self.\nShould by a point of the appropriate type"
        },
        "get_points_defining_boundary": {
          "signature": "get_points_defining_boundary()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_right": {
          "signature": "get_right()",
          "summary": "Get right Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get right Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_sheen_direction": {
          "signature": "get_sheen_direction()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_sheen_factor": {
          "signature": "get_sheen_factor()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_start": {
          "signature": "get_start()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts."
        },
        "get_start_anchors": {
          "signature": "get_start_anchors()",
          "summary": "Returns the start anchors of the bezier curves.",
          "doc": "Returns the start anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_start_and_end": {
          "signature": "get_start_and_end()",
          "summary": "Returns starting and ending point of a stroke as a ``tuple``.",
          "doc": "Returns starting and ending point of a stroke as a ``tuple``."
        },
        "get_stroke_color": {
          "signature": "get_stroke_color(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_colors": {
          "signature": "get_stroke_colors(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacities": {
          "signature": "get_stroke_opacities(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacity": {
          "signature": "get_stroke_opacity(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_rgbas": {
          "signature": "get_stroke_rgbas(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_width": {
          "signature": "get_stroke_width(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_style": {
          "signature": "get_style(simple=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_subcurve": {
          "signature": "get_subcurve(a, b)",
          "summary": "Returns the subcurve of the VMobject between the interval [a, b].",
          "doc": "Returns the subcurve of the VMobject between the interval [a, b].\nThe curve is a VMobject itself.\n\nParameters\n----------\n\na\n    The lower bound.\nb\n    The upper bound.\n\nReturns\n-------\nVMobject\n    The subcurve between of [a, b]"
        },
        "get_subpaths": {
          "signature": "get_subpaths()",
          "summary": "Returns subpaths formed by the curves of the VMobject.",
          "doc": "Returns subpaths formed by the curves of the VMobject.\n\nSubpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.\n\nReturns\n-------\nlist[CubicSpline]\n    subpaths."
        },
        "get_subpaths_from_points": {
          "signature": "get_subpaths_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_time_based_updaters": {
          "signature": "get_time_based_updaters()",
          "summary": "Return all updaters using the ``dt`` parameter.",
          "doc": "Return all updaters using the ``dt`` parameter.\n\nThe updaters use this parameter as the input for difference in time.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of time based updaters.\n\nSee Also\n--------\n:meth:`get_updaters`\n:meth:`has_time_based_updater`"
        },
        "get_top": {
          "signature": "get_top()",
          "summary": "Get top Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get top Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_updaters": {
          "signature": "get_updaters()",
          "summary": "Return all updaters.",
          "doc": "Return all updaters.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of updaters.\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_time_based_updaters`"
        },
        "get_vertex_groups": {
          "signature": "get_vertex_groups()",
          "summary": "Gets the vertex groups of the :class:`Polygram`.",
          "doc": "Gets the vertex groups of the :class:`Polygram`.\n\nReturns\n-------\n:class:`numpy.ndarray`\n    The vertex groups of the :class:`Polygram`.\n\nExamples\n--------\n::\n\n    >>> poly = Polygram([ORIGIN, RIGHT, UP], [LEFT, LEFT + UP, 2 * LEFT])\n    >>> poly.get_vertex_groups()\n    array([[[ 0.,  0.,  0.],\n            [ 1.,  0.,  0.],\n            [ 0.,  1.,  0.]],\n    <BLANKLINE>\n           [[-1.,  0.,  0.],\n            [-1.,  1.,  0.],\n            [-2.,  0.,  0.]]])"
        },
        "get_vertices": {
          "signature": "get_vertices()",
          "summary": "Gets the vertices of the :class:`Polygram`.",
          "doc": "Gets the vertices of the :class:`Polygram`.\n\nReturns\n-------\n:class:`numpy.ndarray`\n    The vertices of the :class:`Polygram`.\n\nExamples\n--------\n::\n\n    >>> sq = Square()\n    >>> sq.get_vertices()\n    array([[ 1.,  1.,  0.],\n           [-1.,  1.,  0.],\n           [-1., -1.,  0.],\n           [ 1., -1.,  0.]])"
        },
        "get_x": {
          "signature": "get_x(direction=[0. 0. 0.])",
          "summary": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_y": {
          "signature": "get_y(direction=[0. 0. 0.])",
          "summary": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z": {
          "signature": "get_z(direction=[0. 0. 0.])",
          "summary": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z_index_reference_point": {
          "signature": "get_z_index_reference_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_zenith": {
          "signature": "get_zenith()",
          "summary": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "has_new_path_started": {
          "signature": "has_new_path_started()",
          "summary": "No documentation available.",
          "doc": null
        },
        "has_no_points": {
          "signature": "has_no_points()",
          "summary": "Check if :class:`~.Mobject` *does not* contains points.",
          "doc": "Check if :class:`~.Mobject` *does not* contains points."
        },
        "has_points": {
          "signature": "has_points()",
          "summary": "Check if :class:`~.Mobject` contains points.",
          "doc": "Check if :class:`~.Mobject` contains points."
        },
        "has_time_based_updater": {
          "signature": "has_time_based_updater()",
          "summary": "Test if ``self`` has a time based updater.",
          "doc": "Test if ``self`` has a time based updater.\n\nReturns\n-------\n:class:`bool`\n    ``True`` if at least one updater uses the ``dt`` parameter, ``False``\n    otherwise.\n\nSee Also\n--------\n:meth:`get_time_based_updaters`"
        },
        "init_colors": {
          "signature": "init_colors(propagate_colors=True)",
          "summary": "Initializes the colors.",
          "doc": "Initializes the colors.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "insert": {
          "signature": "insert(index, mobject)",
          "summary": "Inserts a mobject at a specific position into self.submobjects Effectively just calls  ``self.submobjects.insert(index, mobject)``,",
          "doc": "Inserts a mobject at a specific position into self.submobjects\n\nEffectively just calls  ``self.submobjects.insert(index, mobject)``,\nwhere ``self.submobjects`` is a list.\n\nHighly adapted from ``Mobject.add``.\n\nParameters\n----------\nindex\n    The index at which\nmobject\n    The mobject to be inserted."
        },
        "insert_n_curves": {
          "signature": "insert_n_curves(n)",
          "summary": "Inserts n curves to the bezier curves of the vmobject.",
          "doc": "Inserts n curves to the bezier curves of the vmobject.\n\nParameters\n----------\nn\n    Number of curves to insert.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "insert_n_curves_to_point_list": {
          "signature": "insert_n_curves_to_point_list(n, points)",
          "summary": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.",
          "doc": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.\n\nParameters\n----------\nn\n    Number of desired curves.\npoints\n    Starting points.\n\nReturns\n-------\n    Points generated."
        },
        "interpolate": {
          "signature": "interpolate(mobject1, mobject2, alpha, path_func=<function interpolate at 0x109973f60>)",
          "summary": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``",
          "doc": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``\nand ``mobject2``.\n\nExamples\n--------\n\n.. manim:: DotInterpolation\n    :save_last_frame:\n\n    class DotInterpolation(Scene):\n        def construct(self):\n            dotR = Dot(color=DARK_GREY)\n            dotR.shift(2 * RIGHT)\n            dotL = Dot(color=WHITE)\n            dotL.shift(2 * LEFT)\n\n            dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n            self.add(dotL, dotR, dotMiddle)"
        },
        "interpolate_color": {
          "signature": "interpolate_color(mobject1, mobject2, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "invert": {
          "signature": "invert(recursive=False)",
          "summary": "Inverts the list of :attr:`submobjects`.",
          "doc": "Inverts the list of :attr:`submobjects`.\n\nParameters\n----------\nrecursive\n    If ``True``, all submobject lists of this mobject's family are inverted.\n\nExamples\n--------\n\n.. manim:: InvertSumobjectsExample\n\n    class InvertSumobjectsExample(Scene):\n        def construct(self):\n            s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2 = s.copy()\n            s2.invert()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "is_closed": {
          "signature": "is_closed()",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_off_screen": {
          "signature": "is_off_screen()",
          "summary": "No documentation available.",
          "doc": null
        },
        "length_over_dim": {
          "signature": "length_over_dim(dim)",
          "summary": "Measure the length of an :class:`~.Mobject` in a certain direction.",
          "doc": "Measure the length of an :class:`~.Mobject` in a certain direction."
        },
        "make_jagged": {
          "signature": "make_jagged()",
          "summary": "No documentation available.",
          "doc": null
        },
        "make_smooth": {
          "signature": "make_smooth()",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_background_image": {
          "signature": "match_background_image(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_color": {
          "signature": "match_color(mobject)",
          "summary": "Match the color with the color of another :class:`~.Mobject`.",
          "doc": "Match the color with the color of another :class:`~.Mobject`."
        },
        "match_coord": {
          "signature": "match_coord(mobject, dim, direction=[0. 0. 0.])",
          "summary": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`.",
          "doc": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`."
        },
        "match_depth": {
          "signature": "match_depth(mobject, kwargs)",
          "summary": "Match the depth with the depth of another :class:`~.Mobject`.",
          "doc": "Match the depth with the depth of another :class:`~.Mobject`."
        },
        "match_dim_size": {
          "signature": "match_dim_size(mobject, dim, kwargs)",
          "summary": "Match the specified dimension with the dimension of another :class:`~.Mobject`.",
          "doc": "Match the specified dimension with the dimension of another :class:`~.Mobject`."
        },
        "match_height": {
          "signature": "match_height(mobject, kwargs)",
          "summary": "Match the height with the height of another :class:`~.Mobject`.",
          "doc": "Match the height with the height of another :class:`~.Mobject`."
        },
        "match_points": {
          "signature": "match_points(mobject, copy_submobjects=True)",
          "summary": "Edit points, positions, and submobjects to be identical",
          "doc": "Edit points, positions, and submobjects to be identical\nto another :class:`~.Mobject`, while keeping the style unchanged.\n\nExamples\n--------\n.. manim:: MatchPointsScene\n\n    class MatchPointsScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)"
        },
        "match_style": {
          "signature": "match_style(vmobject, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_updaters": {
          "signature": "match_updaters(mobject)",
          "summary": "Match the updaters of the given mobject.",
          "doc": "Match the updaters of the given mobject.\n\nParameters\n----------\nmobject\n    The mobject whose updaters get matched.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nNote\n----\nAll updaters from submobjects are removed, but only updaters of the given\nmobject are matched, not those of it's submobjects.\n\nSee also\n--------\n:meth:`add_updater`\n:meth:`clear_updaters`"
        },
        "match_width": {
          "signature": "match_width(mobject, kwargs)",
          "summary": "Match the width with the width of another :class:`~.Mobject`.",
          "doc": "Match the width with the width of another :class:`~.Mobject`."
        },
        "match_x": {
          "signature": "match_x(mobject, direction=[0. 0. 0.])",
          "summary": "Match x coord.",
          "doc": "Match x coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_y": {
          "signature": "match_y(mobject, direction=[0. 0. 0.])",
          "summary": "Match y coord.",
          "doc": "Match y coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_z": {
          "signature": "match_z(mobject, direction=[0. 0. 0.])",
          "summary": "Match z coord.",
          "doc": "Match z coord. to the x coord. of another :class:`~.Mobject`."
        },
        "move_to": {
          "signature": "move_to(point_or_mobject, aligned_edge=[0. 0. 0.], coor_mask=[1 1 1])",
          "summary": "Move center of the :class:`~.Mobject` to certain Point3D.",
          "doc": "Move center of the :class:`~.Mobject` to certain Point3D."
        },
        "next_to": {
          "signature": "next_to(mobject_or_point, direction=[1. 0. 0.], buff=0.25, aligned_edge=[0. 0. 0.], submobject_to_align=None, index_of_submobject_to_align=None, coor_mask=[1 1 1])",
          "summary": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.",
          "doc": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.\n\nExamples\n--------\n\n.. manim:: GeometricShapes\n    :save_last_frame:\n\n    class GeometricShapes(Scene):\n        def construct(self):\n            d = Dot()\n            c = Circle()\n            s = Square()\n            t = Triangle()\n            d.next_to(c, RIGHT)\n            s.next_to(c, LEFT)\n            t.next_to(c, DOWN)\n            self.add(d, c, s, t)"
        },
        "nonempty_submobjects": {
          "signature": "nonempty_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "null_point_align": {
          "signature": "null_point_align(mobject)",
          "summary": "If a :class:`~.Mobject` with points is being aligned to",
          "doc": "If a :class:`~.Mobject` with points is being aligned to\none without, treat both as groups, and push\nthe one with points into its own submobjects\nlist.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``"
        },
        "point_from_proportion": {
          "signature": "point_from_proportion(alpha)",
          "summary": "Gets the point at a proportion along the path of the :class:`VMobject`.",
          "doc": "Gets the point at a proportion along the path of the :class:`VMobject`.\n\nParameters\n----------\nalpha\n    The proportion along the the path of the :class:`VMobject`.\n\nReturns\n-------\n:class:`numpy.ndarray`\n    The point on the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``alpha`` is not between 0 and 1.\n:exc:`Exception`\n    If the :class:`VMobject` has no points.\n\nExample\n-------\n.. manim:: PointFromProportion\n    :save_last_frame:\n\n    class PointFromProportion(Scene):\n        def construct(self):\n            line = Line(2*DL, 2*UR)\n            self.add(line)\n            colors = (RED, BLUE, YELLOW)\n            proportions = (1/4, 1/2, 3/4)\n            for color, proportion in zip(colors, proportions):\n                self.add(Dot(color=color).move_to(\n                        line.point_from_proportion(proportion)\n                ))"
        },
        "pointwise_become_partial": {
          "signature": "pointwise_become_partial(vmobject, a, b)",
          "summary": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and",
          "doc": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and\nan upper bound ``b``, modify this :class:`.VMobject`'s points to\nmatch the portion of the B\u00e9zier spline described by ``vmobject.points``\nwith the parameter ``t`` between ``a`` and ``b``.\n\nParameters\n----------\nvmobject\n    The :class:`.VMobject` that will serve as a model.\na\n    The lower bound for ``t``.\nb\n    The upper bound for ``t``\n\nReturns\n-------\n:class:`.VMobject`\n    The :class:`.VMobject` itself, after the transformation.\n\nRaises\n------\nTypeError\n    If ``vmobject`` is not an instance of :class:`VMobject`."
        },
        "pose_at_angle": {
          "signature": "pose_at_angle(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "proportion_from_point": {
          "signature": "proportion_from_point(point)",
          "summary": "Returns the proportion along the path of the :class:`VMobject`",
          "doc": "Returns the proportion along the path of the :class:`VMobject`\na particular given point is at.\n\nParameters\n----------\npoint\n    The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`\n\nReturns\n-------\nfloat\n    The proportion along the path of the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``point`` does not lie on the curve.\n:exc:`Exception`\n    If the :class:`VMobject` has no points."
        },
        "push_self_into_submobjects": {
          "signature": "push_self_into_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "put_start_and_end_on": {
          "signature": "put_start_and_end_on(start, end)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reduce_across_dimension": {
          "signature": "reduce_across_dimension(reduce_func, dim)",
          "summary": "Find the min or max value from a dimension across all points in this and submobjects.",
          "doc": "Find the min or max value from a dimension across all points in this and submobjects."
        },
        "remove": {
          "signature": "remove(mobjects)",
          "summary": "Remove :attr:`submobjects`.",
          "doc": "Remove :attr:`submobjects`.\n\nThe mobjects are removed from :attr:`submobjects`, if they exist.\n\nSubclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to remove.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add`"
        },
        "remove_updater": {
          "signature": "remove_updater(update_function)",
          "summary": "Remove an updater.",
          "doc": "Remove an updater.\n\nIf the same updater is applied multiple times, every instance gets removed.\n\nParameters\n----------\nupdate_function\n    The update function to be removed.\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`clear_updaters`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "repeat": {
          "signature": "repeat(count)",
          "summary": "This can make transition animations nicer",
          "doc": "This can make transition animations nicer"
        },
        "repeat_submobject": {
          "signature": "repeat_submobject(submob)",
          "summary": "No documentation available.",
          "doc": null
        },
        "replace": {
          "signature": "replace(mobject, dim_to_match=0, stretch=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "rescale_to_fit": {
          "signature": "rescale_to_fit(length, dim, stretch=False, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reset_points": {
          "signature": "reset_points()",
          "summary": "Sets :attr:`points` to be an empty array.",
          "doc": "Sets :attr:`points` to be an empty array."
        },
        "resize_points": {
          "signature": "resize_points(new_length, resize_func=<function resize_array at 0x1056ab380>)",
          "summary": "Resize the array of anchor points and handles to have",
          "doc": "Resize the array of anchor points and handles to have\nthe specified size.\n\nParameters\n----------\nnew_length\n    The new (total) number of points.\nresize_func\n    A function mapping a Numpy array (the points) and an integer\n    (the target size) to a Numpy array. The default implementation\n    is based on Numpy's ``resize`` function."
        },
        "restore": {
          "signature": "restore()",
          "summary": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`.",
          "doc": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`."
        },
        "resume_updating": {
          "signature": "resume_updating(recursive=True)",
          "summary": "Enable updating from updaters and animations.",
          "doc": "Enable updating from updaters and animations.\n\nParameters\n----------\nrecursive\n    Whether to recursively enable updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`suspend_updating`\n:meth:`add_updater`"
        },
        "reverse_direction": {
          "signature": "reverse_direction()",
          "summary": "Reverts the point direction by inverting the point order.",
          "doc": "Reverts the point direction by inverting the point order.\n\nReturns\n-------\n:class:`VMobject`\n    Returns self.\n\nExamples\n--------\n.. manim:: ChangeOfDirection\n\n    class ChangeOfDirection(Scene):\n        def construct(self):\n            ccw = RegularPolygon(5)\n            ccw.shift(LEFT)\n            cw = RegularPolygon(5)\n            cw.shift(RIGHT).reverse_direction()\n\n            self.play(Create(ccw), Create(cw),\n            run_time=4)"
        },
        "reverse_points": {
          "signature": "reverse_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "rotate": {
          "signature": "rotate(angle, axis=[0. 0. 1.], about_point=None, kwargs)",
          "summary": "Rotates the :class:`~.Mobject` about a certain point.",
          "doc": "Rotates the :class:`~.Mobject` about a certain point."
        },
        "rotate_about_origin": {
          "signature": "rotate_about_origin(angle, axis=[0. 0. 1.], axes=[])",
          "summary": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0].",
          "doc": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0]."
        },
        "rotate_sheen_direction": {
          "signature": "rotate_sheen_direction(angle, axis=[0. 0. 1.], family=True)",
          "summary": "Rotates the direction of the applied sheen.",
          "doc": "Rotates the direction of the applied sheen.\n\nParameters\n----------\nangle\n    Angle by which the direction of sheen is rotated.\naxis\n    Axis of rotation.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen_direction`"
        },
        "round_corners": {
          "signature": "round_corners(radius=0.5, evenly_distribute_anchors=False, components_per_rounded_corner=2)",
          "summary": "Rounds off the corners of the :class:`Polygram`.",
          "doc": "Rounds off the corners of the :class:`Polygram`.\n\nParameters\n----------\nradius\n    The curvature of the corners of the :class:`Polygram`.\nevenly_distribute_anchors\n    Break long line segments into proportionally-sized segments.\ncomponents_per_rounded_corner\n    The number of points used to represent the rounded corner curve.\n\n\n.. seealso::\n    :class:`.~RoundedRectangle`\n\n.. note::\n    If `radius` is supplied as a single value, then the same radius\n    will be applied to all corners.  If `radius` is a list, then the\n    individual values will be applied sequentially, with the first\n    corner receiving `radius[0]`, the second corner receiving\n    `radius[1]`, etc.  The radius list will be repeated as necessary.\n\n    The `components_per_rounded_corner` value is provided so that the\n    fidelity of the rounded corner may be fine-tuned as needed.  2 is\n    an appropriate value for most shapes, however a larger value may be\n    need if the rounded corner is particularly large.  2 is the minimum\n    number allowed, representing the start and end of the curve.  3 will\n    result in a start, middle, and end point, meaning 2 curves will be\n    generated.\n\n    The option to `evenly_distribute_anchors` is provided so that the\n    line segments (the part part of each line remaining after rounding\n    off the corners) can be subdivided to a density similar to that of\n    the average density of the rounded corners.  This may be desirable\n    in situations in which an even distribution of curves is desired\n    for use in later transformation animations.  Be aware, though, that\n    enabling this option can result in an an object containing\n    significantly more points than the original, especially when the\n    rounded corner curves are small.\n\nExamples\n--------\n.. manim:: PolygramRoundCorners\n    :save_last_frame:\n\n    class PolygramRoundCorners(Scene):\n        def construct(self):\n            star = Star(outer_radius=2)\n\n            shapes = VGroup(star)\n            shapes.add(star.copy().round_corners(radius=0.1))\n            shapes.add(star.copy().round_corners(radius=0.25))\n\n            shapes.arrange(RIGHT)\n            self.add(shapes)"
        },
        "save_image": {
          "signature": "save_image(name=None)",
          "summary": "Saves an image of only this :class:`Mobject` at its position to a png",
          "doc": "Saves an image of only this :class:`Mobject` at its position to a png\nfile."
        },
        "save_state": {
          "signature": "save_state()",
          "summary": "Save the current state (position, color & size).",
          "doc": "Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`."
        },
        "scale": {
          "signature": "scale(scale_factor, scale_stroke=False, kwargs)",
          "summary": "Scale the size by a factor.",
          "doc": "Scale the size by a factor.\n\nDefault behavior is to scale about the center of the vmobject.\n\nParameters\n----------\nscale_factor\n    The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n    will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n    if :math:`\\alpha < 0`, the mobject is also flipped.\nscale_stroke\n    Boolean determining if the object's outline is scaled when the object is scaled.\n    If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.\nkwargs\n    Additional keyword arguments passed to\n    :meth:`~.Mobject.scale`.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n\n.. manim:: MobjectScaleExample\n    :save_last_frame:\n\n    class MobjectScaleExample(Scene):\n        def construct(self):\n            c1 = Circle(1, RED).set_x(-1)\n            c2 = Circle(1, GREEN).set_x(1)\n\n            vg = VGroup(c1, c2)\n            vg.set_stroke(width=50)\n            self.add(vg)\n\n            self.play(\n                c1.animate.scale(.25),\n                c2.animate.scale(.25,\n                    scale_stroke=True)\n            )\n\nSee also\n--------\n:meth:`move_to`"
        },
        "scale_handle_to_anchor_distances": {
          "signature": "scale_handle_to_anchor_distances(factor)",
          "summary": "If the distance between a given handle point H and its associated",
          "doc": "If the distance between a given handle point H and its associated\nanchor point A is d, then it changes H to be a distances factor*d\naway from A, but so that the line from A to H doesn't change.\nThis is mostly useful in the context of applying a (differentiable)\nfunction, to preserve tangency properties.  One would pull all the\nhandles closer to their anchors, apply the function then push them out\nagain.\n\nParameters\n----------\nfactor\n    The factor used for scaling.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "scale_to_fit_depth": {
          "signature": "scale_to_fit_depth(depth, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional."
        },
        "scale_to_fit_height": {
          "signature": "scale_to_fit_height(height, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.scale_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(5.0)"
        },
        "scale_to_fit_width": {
          "signature": "scale_to_fit_width(width, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.scale_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(5.0)"
        },
        "set": {
          "signature": "set(kwargs)",
          "summary": "Sets attributes.",
          "doc": "Sets attributes.\n\nI.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.\n\nThis is a convenience to be used along with :attr:`animate` to\nanimate setting attributes.\n\nIn addition to this method, there is a compatibility\nlayer that allows ``get_*`` and ``set_*`` methods to\nget and set generic attributes. For instance::\n\n    >>> mob = Mobject()\n    >>> mob.set_foo(0)\n    Mobject\n    >>> mob.get_foo()\n    0\n    >>> mob.foo\n    0\n\nThis compatibility layer does not interfere with any\n``get_*`` or ``set_*`` methods that are explicitly\ndefined.\n\n.. warning::\n\n    This compatibility layer is for backwards compatibility\n    and is not guaranteed to stay around. Where applicable,\n    please prefer getting/setting attributes normally or with\n    the :meth:`set` method.\n\nParameters\n----------\n**kwargs\n    The attributes and corresponding values to set.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> mob = Mobject()\n    >>> mob.set(foo=0)\n    Mobject\n    >>> mob.foo\n    0"
        },
        "set_anchors_and_handles": {
          "signature": "set_anchors_and_handles(anchors1, handles1, handles2, anchors2)",
          "summary": "Given two sets of anchors and handles, process them to set them as anchors",
          "doc": "Given two sets of anchors and handles, process them to set them as anchors\nand handles of the VMobject.\n\nanchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier\ncurve of the vmobject. There are four hardcoded parameters and this is a\nproblem as it makes the number of points per cubic curve unchangeable from 4\n(two anchors and two handles).\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "set_background_stroke": {
          "signature": "set_background_stroke(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_cap_style": {
          "signature": "set_cap_style(cap_style)",
          "summary": "Sets the cap style of the :class:`VMobject`.",
          "doc": "Sets the cap style of the :class:`VMobject`.\n\nParameters\n----------\ncap_style\n    The cap style to be set. See :class:`.CapStyleType` for options.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: CapStyleExample\n    :save_last_frame:\n\n    class CapStyleExample(Scene):\n        def construct(self):\n            line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n            line.set_cap_style(CapStyleType.ROUND)\n            self.add(line)"
        },
        "set_color": {
          "signature": "set_color(color, family=True)",
          "summary": "Condition is function which takes in one arguments, (x, y, z).",
          "doc": "Condition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color"
        },
        "set_color_by_gradient": {
          "signature": "set_color_by_gradient(colors)",
          "summary": "Parameters",
          "doc": "Parameters\n----------\ncolors\n    The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.\n\nself.color = ManimColor.parse(color)\nreturn self"
        },
        "set_colors_by_radial_gradient": {
          "signature": "set_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_coord": {
          "signature": "set_coord(value, dim, direction=[0. 0. 0.])",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_fill": {
          "signature": "set_fill(color=None, opacity=None, family=True)",
          "summary": "Set the fill color and fill opacity of a :class:`VMobject`.",
          "doc": "Set the fill color and fill opacity of a :class:`VMobject`.\n\nParameters\n----------\ncolor\n    Fill color of the :class:`VMobject`.\nopacity\n    Fill opacity of the :class:`VMobject`.\nfamily\n    If ``True``, the fill color of all submobjects is also set.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: SetFill\n    :save_last_frame:\n\n    class SetFill(Scene):\n        def construct(self):\n            square = Square().scale(2).set_fill(WHITE,1)\n            circle1 = Circle().set_fill(GREEN,0.8)\n            circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n            circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n            group = Group(circle1,circle2,circle3).arrange()\n            self.add(square)\n            self.add(group)\n\nSee Also\n--------\n:meth:`~.VMobject.set_style`"
        },
        "set_opacity": {
          "signature": "set_opacity(opacity, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_points": {
          "signature": "set_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_points_as_corners": {
          "signature": "set_points_as_corners(points)",
          "summary": "Given an array of points, set them as corners of the",
          "doc": "Given an array of points, set them as corners of the\n:class:`VMobject`.\n\nTo achieve that, this algorithm sets handles aligned with the anchors\nsuch that the resultant B\u00e9zier curve will be the segment between the\ntwo anchors.\n\nParameters\n----------\npoints\n    Array of points that will be set as corners.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after setting the new points as corners.\n\n\nExamples\n--------\n.. manim:: PointsAsCornersExample\n    :save_last_frame:\n\n    class PointsAsCornersExample(Scene):\n        def construct(self):\n            corners = (\n                # create square\n                UR, UL,\n                DL, DR,\n                UR,\n                # create crosses\n                DL, UL,\n                DR\n            )\n            vmob = VMobject(stroke_color=RED)\n            vmob.set_points_as_corners(corners).scale(2)\n            self.add(vmob)"
        },
        "set_points_smoothly": {
          "signature": "set_points_smoothly(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_shade_in_3d": {
          "signature": "set_shade_in_3d(value=True, z_index_as_group=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_sheen": {
          "signature": "set_sheen(factor, direction=None, family=True)",
          "summary": "Applies a color gradient from a direction.",
          "doc": "Applies a color gradient from a direction.\n\nParameters\n----------\nfactor\n    The extent of lustre/gradient to apply. If negative, the gradient\n    starts from black, if positive the gradient starts from white and\n    changes to the current color.\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\n.. manim:: SetSheen\n    :save_last_frame:\n\n    class SetSheen(Scene):\n        def construct(self):\n            circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n            self.add(circle)"
        },
        "set_sheen_direction": {
          "signature": "set_sheen_direction(direction, family=True)",
          "summary": "Sets the direction of the applied sheen.",
          "doc": "Sets the direction of the applied sheen.\n\nParameters\n----------\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen`\n:meth:`~.VMobject.rotate_sheen_direction`"
        },
        "set_stroke": {
          "signature": "set_stroke(color=None, width=None, opacity=None, background=False, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_style": {
          "signature": "set_style(fill_color=None, fill_opacity=None, stroke_color=None, stroke_width=None, stroke_opacity=None, background_stroke_color=None, background_stroke_width=None, background_stroke_opacity=None, sheen_factor=None, sheen_direction=None, background_image=None, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_gradient": {
          "signature": "set_submobject_colors_by_gradient(colors)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_radial_gradient": {
          "signature": "set_submobject_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_x": {
          "signature": "set_x(x, direction=[0. 0. 0.])",
          "summary": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_y": {
          "signature": "set_y(y, direction=[0. 0. 0.])",
          "summary": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z": {
          "signature": "set_z(z, direction=[0. 0. 0.])",
          "summary": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z_index": {
          "signature": "set_z_index(z_index_value, family=True)",
          "summary": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.",
          "doc": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.\n\nParameters\n----------\nz_index_value\n    The new value of :attr:`z_index` set.\nfamily\n    If ``True``, the :attr:`z_index` value of all submobjects is also set.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)\n\nExamples\n--------\n.. manim:: SetZIndex\n    :save_last_frame:\n\n    class SetZIndex(Scene):\n        def construct(self):\n            text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n            square = Square(2, fill_opacity=1).set_z_index(2)\n            tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n            circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n            # Displaying order is now defined by z_index values\n            self.add(text)\n            self.add(square)\n            self.add(tex)\n            self.add(circle)"
        },
        "set_z_index_by_z_Point3D": {
          "signature": "set_z_index_by_z_Point3D()",
          "summary": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.",
          "doc": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)"
        },
        "shift": {
          "signature": "shift(vectors)",
          "summary": "Shift by the given vectors.",
          "doc": "Shift by the given vectors.\n\nParameters\n----------\nvectors\n    Vectors to shift by. If multiple vectors are given, they are added\n    together.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`move_to`"
        },
        "shift_onto_screen": {
          "signature": "shift_onto_screen(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "show": {
          "signature": "show(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "shuffle": {
          "signature": "shuffle(recursive=False)",
          "summary": "Shuffles the list of :attr:`submobjects`.",
          "doc": "Shuffles the list of :attr:`submobjects`."
        },
        "shuffle_submobjects": {
          "signature": "shuffle_submobjects(args, kwargs)",
          "summary": "Shuffles the order of :attr:`submobjects` Examples",
          "doc": "Shuffles the order of :attr:`submobjects`\n\nExamples\n--------\n\n.. manim:: ShuffleSubmobjectsExample\n\n    class ShuffleSubmobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2= s.copy()\n            s2.shuffle_submobjects()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "sort": {
          "signature": "sort(point_to_num_func=<function Mobject.<lambda> at 0x10a232660>, submob_func=None)",
          "summary": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.",
          "doc": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."
        },
        "sort_submobjects": {
          "signature": "sort_submobjects(args, kwargs)",
          "summary": "Sort the :attr:`submobjects`",
          "doc": "Sort the :attr:`submobjects`"
        },
        "space_out_submobjects": {
          "signature": "space_out_submobjects(factor=1.5, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "split": {
          "signature": "split()",
          "summary": "No documentation available.",
          "doc": null
        },
        "start_new_path": {
          "signature": "start_new_path(point)",
          "summary": "Append a ``point`` to the :attr:`VMobject.points`, which will be the",
          "doc": "Append a ``point`` to the :attr:`VMobject.points`, which will be the\nbeginning of a new B\u00e9zier curve in the path given by the points. If\nthere's an unfinished curve at the end of :attr:`VMobject.points`,\ncomplete it by appending the last B\u00e9zier curve's start anchor as many\ntimes as needed.\n\nParameters\n----------\npoint\n    A 3D point to append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``point`` and starting a new\n    curve."
        },
        "stretch": {
          "signature": "stretch(factor, dim, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_about_point": {
          "signature": "stretch_about_point(factor, dim, point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_to_fit_depth": {
          "signature": "stretch_to_fit_depth(depth, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional."
        },
        "stretch_to_fit_height": {
          "signature": "stretch_to_fit_height(height, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(2.0)"
        },
        "stretch_to_fit_width": {
          "signature": "stretch_to_fit_width(width, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(2.0)"
        },
        "surround": {
          "signature": "surround(mobject, dim_to_match=0, stretch=False, buff=0.25)",
          "summary": "No documentation available.",
          "doc": null
        },
        "suspend_updating": {
          "signature": "suspend_updating(recursive=True)",
          "summary": "Disable updating from updaters and animations.",
          "doc": "Disable updating from updaters and animations.\n\n\nParameters\n----------\nrecursive\n    Whether to recursively suspend updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`resume_updating`\n:meth:`add_updater`"
        },
        "throw_error_if_no_points": {
          "signature": "throw_error_if_no_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "to_corner": {
          "signature": "to_corner(corner=[-1. -1.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given corner of the screen.",
          "doc": "Moves this :class:`~.Mobject` to the given corner of the screen.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToCornerExample\n    :save_last_frame:\n\n    class ToCornerExample(Scene):\n        def construct(self):\n            c = Circle()\n            c.to_corner(UR)\n            t = Tex(\"To the corner!\")\n            t2 = MathTex(\"x^3\").shift(DOWN)\n            self.add(c,t,t2)\n            t.to_corner(DL, buff=0)\n            t2.to_corner(UL, buff=1.5)"
        },
        "to_edge": {
          "signature": "to_edge(edge=[-1.  0.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given edge of the screen,",
          "doc": "Moves this :class:`~.Mobject` to the given edge of the screen,\nwithout affecting its position in the other dimension.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToEdgeExample\n    :save_last_frame:\n\n    class ToEdgeExample(Scene):\n        def construct(self):\n            tex_top = Tex(\"I am at the top!\")\n            tex_top.to_edge(UP)\n            tex_side = Tex(\"I am moving to the side!\")\n            c = Circle().shift(2*DOWN)\n            self.add(tex_top, tex_side, c)\n            tex_side.to_edge(LEFT)\n            c.to_edge(RIGHT, buff=0)"
        },
        "to_original_color": {
          "signature": "to_original_color()",
          "summary": "No documentation available.",
          "doc": null
        },
        "update": {
          "signature": "update(dt=0, recursive=True)",
          "summary": "Apply all updaters.",
          "doc": "Apply all updaters.\n\nDoes nothing if updating is suspended.\n\nParameters\n----------\ndt\n    The parameter ``dt`` to pass to the update functions. Usually this is the\n    time in seconds since the last call of ``update``.\nrecursive\n    Whether to recursively update all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "update_rgbas_array": {
          "signature": "update_rgbas_array(array_name, color=None, opacity=None)",
          "summary": "No documentation available.",
          "doc": null
        }
      },
      "doc": "A rectangle with equal side lengths.\n\nParameters\n----------\nside_length\n    The length of the sides of the square.\nkwargs\n    Additional arguments to be passed to :class:`Rectangle`.\n\nExamples\n--------\n.. manim:: SquareExample\n    :save_last_frame:\n\n    class SquareExample(Scene):\n        def construct(self):\n            square_1 = Square(side_length=2.0).shift(DOWN)\n            square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)\n            square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)\n            self.add(square_1, square_2, square_3)"
    },
    "Text": {
      "module": "manim.mobject.text.text_mobject",
      "summary": "Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.",
      "bases": [
        "SVGMobject"
      ],
      "methods": {
        "__add__": {
          "signature": "__add__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__deepcopy__": {
          "signature": "__deepcopy__(clone_from_id)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getattr__": {
          "signature": "__getattr__(attr)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getitem__": {
          "signature": "__getitem__(value)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iadd__": {
          "signature": "__iadd__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__init__": {
          "signature": "__init__(text, fill_opacity=1.0, stroke_width=0, color=None, font_size=48, line_spacing=-1, font='', slant='NORMAL', weight='NORMAL', t2c=None, t2f=None, t2g=None, t2s=None, t2w=None, gradient=None, tab_width=4, warn_missing_font=True, height=None, width=None, should_center=True, disable_ligatures=False, use_svg_cache=False, kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__isub__": {
          "signature": "__isub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iter__": {
          "signature": "__iter__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__len__": {
          "signature": "__len__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__sub__": {
          "signature": "__sub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add": {
          "signature": "add(mobjects)",
          "summary": "Add mobjects as submobjects.",
          "doc": "Add mobjects as submobjects.\n\nThe mobjects are added to :attr:`submobjects`.\n\nSubclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add_to_back`\n\nExamples\n--------\n::\n\n    >>> outer = Mobject()\n    >>> inner = Mobject()\n    >>> outer = outer.add(inner)\n\nDuplicates are not added again::\n\n    >>> outer = outer.add(inner)\n    >>> len(outer.submobjects)\n    1\n\nOnly Mobjects can be added::\n\n    >>> outer.add(3)\n    Traceback (most recent call last):\n    ...\n    TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.\n\nAdding an object to itself raises an error::\n\n    >>> outer.add(outer)\n    Traceback (most recent call last):\n    ...\n    ValueError: Cannot add Mobject as a submobject of itself (at index 0).\n\nA given mobject cannot be added as a submobject\ntwice to some parent::\n\n    >>> parent = Mobject(name=\"parent\")\n    >>> child = Mobject(name=\"child\")\n    >>> parent.add(child, child)\n    [...] WARNING  ...\n    parent\n    >>> parent.submobjects\n    [child]"
        },
        "add_background_rectangle": {
          "signature": "add_background_rectangle(color=None, opacity=0.75, kwargs)",
          "summary": "Add a BackgroundRectangle as submobject.",
          "doc": "Add a BackgroundRectangle as submobject.\n\nThe BackgroundRectangle is added behind other submobjects.\n\nThis can be used to increase the mobjects visibility in front of a noisy background.\n\nParameters\n----------\ncolor\n    The color of the BackgroundRectangle\nopacity\n    The opacity of the BackgroundRectangle\nkwargs\n    Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_to_back`\n:class:`~.BackgroundRectangle`"
        },
        "add_background_rectangle_to_family_members_with_points": {
          "signature": "add_background_rectangle_to_family_members_with_points(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_background_rectangle_to_submobjects": {
          "signature": "add_background_rectangle_to_submobjects(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve": {
          "signature": "add_cubic_bezier_curve(anchor1, handle1, handle2, anchor2)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve_to": {
          "signature": "add_cubic_bezier_curve_to(handle1, handle2, anchor)",
          "summary": "Add cubic bezier curve to the path.",
          "doc": "Add cubic bezier curve to the path.\n\nNOTE : the first anchor is not a parameter as by default the end of the last sub-path!\n\nParameters\n----------\nhandle1\n    first handle\nhandle2\n    second handle\nanchor\n    anchor\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_cubic_bezier_curves": {
          "signature": "add_cubic_bezier_curves(curves)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_line_to": {
          "signature": "add_line_to(point)",
          "summary": "Add a straight line from the last point of VMobject to the given point.",
          "doc": "Add a straight line from the last point of VMobject to the given point.\n\nParameters\n----------\n\npoint\n    The end of the straight line.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_n_more_submobjects": {
          "signature": "add_n_more_submobjects(n)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_points_as_corners": {
          "signature": "add_points_as_corners(points)",
          "summary": "Append multiple straight lines at the end of",
          "doc": "Append multiple straight lines at the end of\n:attr:`VMobject.points`, which connect the given ``points`` in order\nstarting from the end of the current path. These ``points`` would be\ntherefore the corners of the new polyline appended to the path.\n\nParameters\n----------\npoints\n    An array of 3D points representing the corners of the polyline to\n    append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending the straight lines to its\n    path."
        },
        "add_quadratic_bezier_curve_to": {
          "signature": "add_quadratic_bezier_curve_to(handle, anchor)",
          "summary": "Add Quadratic bezier curve to the path.",
          "doc": "Add Quadratic bezier curve to the path.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_smooth_curve_to": {
          "signature": "add_smooth_curve_to(points)",
          "summary": "Creates a smooth curve from given points and add it to the VMobject.",
          "doc": "Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted\nas a handle, the second as an anchor.\n\nParameters\n----------\npoints\n    Points (anchor and handle, or just anchor) to add a smooth curve from\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nRaises\n------\nValueError\n    If 0 or more than 2 points are given."
        },
        "add_subpath": {
          "signature": "add_subpath(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_to_back": {
          "signature": "add_to_back(mobjects)",
          "summary": "Add all passed mobjects to the back of the submobjects.",
          "doc": "Add all passed mobjects to the back of the submobjects.\n\nIf :attr:`submobjects` already contains the given mobjects, they just get moved\nto the back instead.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\n\n.. note::\n\n    Technically, this is done by adding (or moving) the mobjects to\n    the head of :attr:`submobjects`. The head of this list is rendered\n    first, which places the corresponding mobjects behind the\n    subsequent list members.\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add`"
        },
        "add_updater": {
          "signature": "add_updater(update_function, index=None, call_updater=False)",
          "summary": "Add an update function to this mobject.",
          "doc": "Add an update function to this mobject.\n\nUpdate functions, or updaters in short, are functions that are applied to the\nMobject in every frame.\n\nParameters\n----------\nupdate_function\n    The update function to be added.\n    Whenever :meth:`update` is called, this update function gets called using\n    ``self`` as the first parameter.\n    The updater can have a second parameter ``dt``. If it uses this parameter,\n    it gets called using a second value ``dt``, usually representing the time\n    in seconds since the last call of :meth:`update`.\nindex\n    The index at which the new updater should be added in ``self.updaters``.\n    In case ``index`` is ``None`` the updater will be added at the end.\ncall_updater\n    Whether or not to call the updater initially. If ``True``, the updater will\n    be called using ``dt=0``.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n.. manim:: NextToUpdater\n\n    class NextToUpdater(Scene):\n        def construct(self):\n            def dot_position(mobject):\n                mobject.set_value(dot.get_center()[0])\n                mobject.next_to(dot)\n\n            dot = Dot(RIGHT*3)\n            label = DecimalNumber()\n            label.add_updater(dot_position)\n            self.add(dot, label)\n\n            self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))\n\n.. manim:: DtUpdater\n\n    class DtUpdater(Scene):\n        def construct(self):\n            square = Square()\n\n            #Let the square rotate 90\u00b0 per second\n            square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n            self.add(square)\n            self.wait(2)\n\nSee also\n--------\n:meth:`get_updaters`\n:meth:`remove_updater`\n:class:`~.UpdateFromFunc`"
        },
        "align_data": {
          "signature": "align_data(mobject, skip_point_alignment=False)",
          "summary": "Aligns the data of this mobject with another mobject.",
          "doc": "Aligns the data of this mobject with another mobject.\n\nAfterwards, the two mobjects will have the same number of submobjects\n(see :meth:`.align_submobjects`), the same parent structure (see\n:meth:`.null_point_align`). If ``skip_point_alignment`` is false,\nthey will also have the same number of points (see :meth:`.align_points`).\n\nParameters\n----------\nmobject\n    The other mobject this mobject should be aligned to.\nskip_point_alignment\n    Controls whether or not the computationally expensive\n    point alignment is skipped (default: False)."
        },
        "align_on_border": {
          "signature": "align_on_border(direction, buff=0.5)",
          "summary": "Direction just needs to be a vector pointing towards side or",
          "doc": "Direction just needs to be a vector pointing towards side or\ncorner in the 2d plane."
        },
        "align_points": {
          "signature": "align_points(vmobject)",
          "summary": "Adds points to self and vmobject so that they both have the same number of subpaths, with",
          "doc": "Adds points to self and vmobject so that they both have the same number of subpaths, with\ncorresponding subpaths each containing the same number of points.\n\nPoints are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting\nof a single point repeated.\n\nParameters\n----------\nvmobject\n    The object to align points with.\n\nReturns\n-------\n:class:`VMobject`\n   ``self``"
        },
        "align_points_with_larger": {
          "signature": "align_points_with_larger(larger_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_rgbas": {
          "signature": "align_rgbas(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_submobjects": {
          "signature": "align_submobjects(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_to": {
          "signature": "align_to(mobject_or_point, direction=[0. 0. 0.])",
          "summary": "Aligns mobject to another :class:`~.Mobject` in a certain direction.",
          "doc": "Aligns mobject to another :class:`~.Mobject` in a certain direction.\n\nExamples:\nmob1.align_to(mob2, UP) moves mob1 vertically so that its\ntop edge lines ups with mob2's top edge."
        },
        "append_points": {
          "signature": "append_points(new_points)",
          "summary": "Append the given ``new_points`` to the end of",
          "doc": "Append the given ``new_points`` to the end of\n:attr:`VMobject.points`.\n\nParameters\n----------\nnew_points\n    An array of 3D points to append.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``new_points``."
        },
        "append_vectorized_mobject": {
          "signature": "append_vectorized_mobject(vectorized_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_complex_function": {
          "signature": "apply_complex_function(function, kwargs)",
          "summary": "Applies a complex function to a :class:`Mobject`.",
          "doc": "Applies a complex function to a :class:`Mobject`.\nThe x and y Point3Ds correspond to the real and imaginary parts respectively.\n\nExample\n-------\n\n.. manim:: ApplyFuncExample\n\n    class ApplyFuncExample(Scene):\n        def construct(self):\n            circ = Circle().scale(1.5)\n            circ_ref = circ.copy()\n            circ.apply_complex_function(\n                lambda x: np.exp(x*1j)\n            )\n            t = ValueTracker(0)\n            circ.add_updater(\n                lambda x: x.become(circ_ref.copy().apply_complex_function(\n                    lambda x: np.exp(x+t.get_value()*1j)\n                )).set_color(BLUE)\n            )\n            self.add(circ_ref)\n            self.play(TransformFromCopy(circ_ref, circ))\n            self.play(t.animate.set_value(TAU), run_time=3)"
        },
        "apply_function": {
          "signature": "apply_function(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_position": {
          "signature": "apply_function_to_position(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_submobject_positions": {
          "signature": "apply_function_to_submobject_positions(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_matrix": {
          "signature": "apply_matrix(matrix, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_over_attr_arrays": {
          "signature": "apply_over_attr_arrays(func)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_points_function_about_point": {
          "signature": "apply_points_function_about_point(func, about_point=None, about_edge=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_style_to_mobject": {
          "signature": "apply_style_to_mobject(mob, shape)",
          "summary": "Apply SVG style information to the converted mobject.",
          "doc": "Apply SVG style information to the converted mobject.\n\nParameters\n----------\nmob\n    The converted mobject.\nshape\n    The parsed SVG element."
        },
        "apply_to_family": {
          "signature": "apply_to_family(func)",
          "summary": "Apply a function to ``self`` and every submobject with points recursively.",
          "doc": "Apply a function to ``self`` and every submobject with points recursively.\n\nParameters\n----------\nfunc\n    The function to apply to each mobject. ``func`` gets passed the respective\n    (sub)mobject as parameter.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`family_members_with_points`"
        },
        "arrange": {
          "signature": "arrange(direction=[1. 0. 0.], buff=0.25, center=True, kwargs)",
          "summary": "Sorts :class:`~.Mobject` next to each other on screen.",
          "doc": "Sorts :class:`~.Mobject` next to each other on screen.\n\nExamples\n--------\n\n.. manim:: Example\n    :save_last_frame:\n\n    class Example(Scene):\n        def construct(self):\n            s1 = Square()\n            s2 = Square()\n            s3 = Square()\n            s4 = Square()\n            x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n            self.add(x)"
        },
        "arrange_in_grid": {
          "signature": "arrange_in_grid(rows=None, cols=None, buff=0.25, cell_alignment=[0. 0. 0.], row_alignments=None, col_alignments=None, row_heights=None, col_widths=None, flow_order='rd', kwargs)",
          "summary": "Arrange submobjects in a grid.",
          "doc": "Arrange submobjects in a grid.\n\nParameters\n----------\nrows\n    The number of rows in the grid.\ncols\n    The number of columns in the grid.\nbuff\n    The gap between grid cells. To specify a different buffer in the horizontal and\n    vertical directions, a tuple of two values can be given - ``(row, col)``.\ncell_alignment\n    The way each submobject is aligned in its grid cell.\nrow_alignments\n    The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n    up, ``\"c\"`` - center, ``\"d\"`` - down.\ncol_alignments\n    The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n    ``\"c\"`` - center, ``\"r\"`` - right.\nrow_heights\n    Defines a list of heights for certain rows (top to bottom). If the list contains\n    ``None``, the corresponding row will fit its height automatically based\n    on the highest element in that row.\ncol_widths\n    Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n    corresponding column will fit its width automatically based on the widest element in that column.\nflow_order\n    The order in which submobjects fill the grid. Can be one of the following values:\n    \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\nValueError\n    If ``rows`` and ``cols`` are too small to fit all submobjects.\nValueError\n    If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n    :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\nNotes\n-----\nIf only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\nenough to fit all submobjects. If neither is set, they will be chosen to be about the same,\ntending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\nIf both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\ndefined, the latter has higher priority.\n\nExamples\n--------\n.. manim:: ExampleBoxes\n    :save_last_frame:\n\n    class ExampleBoxes(Scene):\n        def construct(self):\n            boxes=VGroup(*[Square() for s in range(0,6)])\n            boxes.arrange_in_grid(rows=2, buff=0.1)\n            self.add(boxes)\n\n\n.. manim:: ArrangeInGrid\n    :save_last_frame:\n\n    class ArrangeInGrid(Scene):\n        def construct(self):\n            boxes = VGroup(*[\n                Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n                for i in range(24)\n            ])\n            self.add(boxes)\n\n            boxes.arrange_in_grid(\n                buff=(0.25,0.5),\n                col_alignments=\"lccccr\",\n                row_alignments=\"uccd\",\n                col_widths=[1, *[None]*4, 1],\n                row_heights=[1, None, None, 1],\n                flow_order=\"dr\"\n            )"
        },
        "arrange_submobjects": {
          "signature": "arrange_submobjects(args, kwargs)",
          "summary": "Arrange the position of :attr:`submobjects` with a small buffer.",
          "doc": "Arrange the position of :attr:`submobjects` with a small buffer.\n\nExamples\n--------\n\n.. manim:: ArrangeSumobjectsExample\n    :save_last_frame:\n\n    class ArrangeSumobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n            s.shift(UP).set_color(BLUE)\n            s2= s.copy().set_color(RED)\n            s2.arrange_submobjects()\n            s2.shift(DOWN)\n            self.add(s,s2)"
        },
        "become": {
          "signature": "become(mobject, match_height=False, match_width=False, match_depth=False, match_center=False, stretch=False)",
          "summary": "Edit points, colors and submobjects to be identical",
          "doc": "Edit points, colors and submobjects to be identical\nto another :class:`~.Mobject`\n\n.. note::\n\n    If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`\n    will match the height first and then the width.\n\nParameters\n----------\nmatch_height\n    Whether or not to preserve the height of the original\n    :class:`~.Mobject`.\nmatch_width\n    Whether or not to preserve the width of the original\n    :class:`~.Mobject`.\nmatch_depth\n    Whether or not to preserve the depth of the original\n    :class:`~.Mobject`.\nmatch_center\n    Whether or not to preserve the center of the original\n    :class:`~.Mobject`.\nstretch\n    Whether or not to stretch the target mobject to match the\n    the proportions of the original :class:`~.Mobject`.\n\nExamples\n--------\n.. manim:: BecomeScene\n\n    class BecomeScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            circ.become(square)\n            self.wait(0.5)\n\n\nThe following examples illustrate how mobject measurements\nchange when using the ``match_...`` and ``stretch`` arguments.\nWe start with a rectangle that is 2 units high and 4 units wide,\nwhich we want to turn into a circle of radius 3::\n\n    >>> from manim import Rectangle, Circle\n    >>> import numpy as np\n    >>> rect = Rectangle(height=2, width=4)\n    >>> circ = Circle(radius=3)\n\nWith ``stretch=True``, the target circle is deformed to match\nthe proportions of the rectangle, which results in the target\nmobject being an ellipse with height 2 and width 4. We can\ncheck that the resulting points satisfy the ellipse equation\n:math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`\nbeing the semi-axes::\n\n    >>> result = rect.copy().become(circ, stretch=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(4.0))\n    >>> ellipse_points = np.array(result.get_anchors())\n    >>> ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)\n    >>> np.allclose(ellipse_eq, 1)\n    True\n\nWith ``match_height=True`` and ``match_width=True`` the circle is\nscaled such that the height or the width of the rectangle will\nbe preserved, respectively.\nThe points of the resulting mobject satisfy the circle equation\n:math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::\n\n    >>> result = rect.copy().become(circ, match_height=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(2.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 1)\n    True\n    >>> result = rect.copy().become(circ, match_width=True)\n    >>> result.height, result.width\n    (np.float64(4.0), np.float64(4.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 2**2)\n    True\n\nWith ``match_center=True``, the resulting mobject is moved such that\nits center is the same as the center of the original mobject::\n\n    >>> rect = rect.shift(np.array([0, 1, 0]))\n    >>> np.allclose(rect.get_center(), circ.get_center())\n    False\n    >>> result = rect.copy().become(circ, match_center=True)\n    >>> np.allclose(rect.get_center(), result.get_center())\n    True"
        },
        "center": {
          "signature": "center()",
          "summary": "Moves the center of the mobject to the center of the scene.",
          "doc": "Moves the center of the mobject to the center of the scene.\n\nReturns\n-------\n:class:`.Mobject`\n    The centered mobject."
        },
        "change_anchor_mode": {
          "signature": "change_anchor_mode(mode)",
          "summary": "Changes the anchor mode of the bezier curves.",
          "doc": "Changes the anchor mode of the bezier curves. This will modify the handles.\n\nThere can be only two modes, \"jagged\", and \"smooth\".\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "clear_points": {
          "signature": "clear_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "clear_updaters": {
          "signature": "clear_updaters(recursive=True)",
          "summary": "Remove every updater.",
          "doc": "Remove every updater.\n\nParameters\n----------\nrecursive\n    Whether to recursively call ``clear_updaters`` on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`remove_updater`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "close_path": {
          "signature": "close_path()",
          "summary": "No documentation available.",
          "doc": null
        },
        "color_using_background_image": {
          "signature": "color_using_background_image(background_image)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals": {
          "signature": "consider_points_equals(p0, p1)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals_2d": {
          "signature": "consider_points_equals_2d(p0, p1)",
          "summary": "Determine if two points are close enough to be considered equal.",
          "doc": "Determine if two points are close enough to be considered equal.\n\nThis uses the algorithm from np.isclose(), but expanded here for the\n2D point case. NumPy is overkill for such a small question.\nParameters\n----------\np0\n    first point\np1\n    second point\n\nReturns\n-------\nbool\n    whether two points considered close."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create and return an identical copy of the :class:`Mobject` including all",
          "doc": "Create and return an identical copy of the :class:`Mobject` including all\n:attr:`submobjects`.\n\nReturns\n-------\n:class:`Mobject`\n    The copy.\n\nNote\n----\nThe clone is initially not visible in the Scene, even if the original was."
        },
        "ellipse_to_mobject": {
          "signature": "ellipse_to_mobject(ellipse)",
          "summary": "Convert an ellipse or circle element to a vectorized mobject.",
          "doc": "Convert an ellipse or circle element to a vectorized mobject.\n\nParameters\n----------\nellipse\n    The parsed SVG ellipse or circle."
        },
        "fade": {
          "signature": "fade(darkness=0.5, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "fade_to": {
          "signature": "fade_to(color, alpha, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "family_members_with_points": {
          "signature": "family_members_with_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "flip": {
          "signature": "flip(axis=[0. 1. 0.], kwargs)",
          "summary": "Flips/Mirrors an mobject about its center.",
          "doc": "Flips/Mirrors an mobject about its center.\n\nExamples\n--------\n\n.. manim:: FlipExample\n    :save_last_frame:\n\n    class FlipExample(Scene):\n        def construct(self):\n            s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n            self.add(s)\n            s2= s.copy().flip()\n            self.add(s2)"
        },
        "force_direction": {
          "signature": "force_direction(target_direction)",
          "summary": "Makes sure that points are either directed clockwise or",
          "doc": "Makes sure that points are either directed clockwise or\ncounterclockwise.\n\nParameters\n----------\ntarget_direction\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "gen_cubic_bezier_tuples_from_points": {
          "signature": "gen_cubic_bezier_tuples_from_points(points)",
          "summary": "Returns the bezier tuples from an array of points.",
          "doc": "Returns the bezier tuples from an array of points.\n\nself.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])\nThis algorithm basically retrieve them by taking an element every n, where n is the number of control points\nof the bezier curve.\n\n\nParameters\n----------\npoints\n    Points from which control points will be extracted.\n\nReturns\n-------\ntuple\n    Bezier control points."
        },
        "gen_subpaths_from_points_2d": {
          "signature": "gen_subpaths_from_points_2d(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "generate_config_style_dict": {
          "signature": "generate_config_style_dict()",
          "summary": "Generate a dictionary holding the default style information.",
          "doc": "Generate a dictionary holding the default style information."
        },
        "generate_mobject": {
          "signature": "generate_mobject()",
          "summary": "Parse the SVG and translate its elements to submobjects.",
          "doc": "Parse the SVG and translate its elements to submobjects."
        },
        "generate_points": {
          "signature": "generate_points()",
          "summary": "Initializes :attr:`points` and therefore the shape.",
          "doc": "Initializes :attr:`points` and therefore the shape.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "generate_rgbas_array": {
          "signature": "generate_rgbas_array(color, opacity)",
          "summary": "First arg can be either a color, or a tuple/list of colors.",
          "doc": "First arg can be either a color, or a tuple/list of colors.\nLikewise, opacity can either be a float, or a tuple of floats.\nIf self.sheen_factor is not zero, and only\none color was passed in, a second slightly light color\nwill automatically be added for the gradient"
        },
        "generate_target": {
          "signature": "generate_target(use_deepcopy=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_points": {
          "signature": "get_all_points()",
          "summary": "Return all points from this mobject and all submobjects.",
          "doc": "Return all points from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_anchors": {
          "signature": "get_anchors()",
          "summary": "Returns the anchors of the curves forming the VMobject.",
          "doc": "Returns the anchors of the curves forming the VMobject.\n\nReturns\n-------\nPoint3D_Array\n    The anchors."
        },
        "get_anchors_and_handles": {
          "signature": "get_anchors_and_handles()",
          "summary": "Returns anchors1, handles1, handles2, anchors2,",
          "doc": "Returns anchors1, handles1, handles2, anchors2,\nwhere (anchors1[i], handles1[i], handles2[i], anchors2[i])\nwill be four points defining a cubic bezier curve\nfor any i in range(0, len(anchors1))\n\nReturns\n-------\n`list[Point3D_Array]`\n    Iterable of the anchors and handles."
        },
        "get_arc_length": {
          "signature": "get_arc_length(sample_points_per_curve=None)",
          "summary": "Return the approximated length of the whole curve.",
          "doc": "Return the approximated length of the whole curve.\n\nParameters\n----------\nsample_points_per_curve\n    Number of sample points per curve used to approximate the length. More points result in a better approximation.\n\nReturns\n-------\nfloat\n    The length of the :class:`VMobject`."
        },
        "get_array_attrs": {
          "signature": "get_array_attrs()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_background_image": {
          "signature": "get_background_image()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_bottom": {
          "signature": "get_bottom()",
          "summary": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_boundary_point": {
          "signature": "get_boundary_point(direction)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_center": {
          "signature": "get_center()",
          "summary": "Get center Point3Ds",
          "doc": "Get center Point3Ds"
        },
        "get_center_of_mass": {
          "signature": "get_center_of_mass()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_color": {
          "signature": "get_color()",
          "summary": "Returns the color of the :class:`~.Mobject` Examples",
          "doc": "Returns the color of the :class:`~.Mobject`\n\nExamples\n--------\n::\n\n    >>> from manim import Square, RED\n    >>> Square(color=RED).get_color() == RED\n    True"
        },
        "get_coord": {
          "signature": "get_coord(dim, direction=[0. 0. 0.])",
          "summary": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``",
          "doc": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``"
        },
        "get_corner": {
          "signature": "get_corner(direction)",
          "summary": "Get corner Point3Ds for certain direction.",
          "doc": "Get corner Point3Ds for certain direction."
        },
        "get_critical_point": {
          "signature": "get_critical_point(direction)",
          "summary": "Picture a box bounding the :class:`~.Mobject`.",
          "doc": "Picture a box bounding the :class:`~.Mobject`.  Such a box has\n9 'critical points': 4 corners, 4 edge center, the\ncenter. This returns one of them, along the given direction.\n\n::\n\n    sample = Arc(start_angle=PI / 7, angle=PI / 5)\n\n    # These are all equivalent\n    max_y_1 = sample.get_top()[1]\n    max_y_2 = sample.get_critical_point(UP)[1]\n    max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)"
        },
        "get_cubic_bezier_tuples": {
          "signature": "get_cubic_bezier_tuples()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_cubic_bezier_tuples_from_points": {
          "signature": "get_cubic_bezier_tuples_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_curve_functions": {
          "signature": "get_curve_functions()",
          "summary": "Gets the functions for the curves of the mobject.",
          "doc": "Gets the functions for the curves of the mobject.\n\nReturns\n-------\nIterable[Callable[[float], Point3D]]\n    The functions for the curves."
        },
        "get_curve_functions_with_lengths": {
          "signature": "get_curve_functions_with_lengths(kwargs)",
          "summary": "Gets the functions and lengths of the curves for the mobject.",
          "doc": "Gets the functions and lengths of the curves for the mobject.\n\nParameters\n----------\n**kwargs\n    The keyword arguments passed to :meth:`get_nth_curve_function_with_length`\n\nReturns\n-------\nIterable[tuple[Callable[[float], Point3D], float]]\n    The functions and lengths of the curves."
        },
        "get_direction": {
          "signature": "get_direction()",
          "summary": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.",
          "doc": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.\nThe direction of points determines in which direction the\nobject is drawn, clockwise or counterclockwise.\n\nExamples\n--------\nThe default direction of a :class:`~.Circle` is counterclockwise::\n\n    >>> from manim import Circle\n    >>> Circle().get_direction()\n    'CCW'\n\nReturns\n-------\n:class:`str`\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "get_edge_center": {
          "signature": "get_edge_center(direction)",
          "summary": "Get edge Point3Ds for certain direction.",
          "doc": "Get edge Point3Ds for certain direction."
        },
        "get_end": {
          "signature": "get_end()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends."
        },
        "get_end_anchors": {
          "signature": "get_end_anchors()",
          "summary": "Return the end anchors of the bezier curves.",
          "doc": "Return the end anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_extremum_along_dim": {
          "signature": "get_extremum_along_dim(points=None, dim=0, key=0)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family": {
          "signature": "get_family(recurse=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family_updaters": {
          "signature": "get_family_updaters()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_file_path": {
          "signature": "get_file_path()",
          "summary": "Search for an existing file based on the specified file name.",
          "doc": "Search for an existing file based on the specified file name."
        },
        "get_fill_color": {
          "signature": "get_fill_color()",
          "summary": "If there are multiple colors (for gradient)",
          "doc": "If there are multiple colors (for gradient)\nthis returns the first one"
        },
        "get_fill_colors": {
          "signature": "get_fill_colors()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacities": {
          "signature": "get_fill_opacities()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacity": {
          "signature": "get_fill_opacity()",
          "summary": "If there are multiple opacities, this returns the",
          "doc": "If there are multiple opacities, this returns the\nfirst"
        },
        "get_fill_rgbas": {
          "signature": "get_fill_rgbas()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_gradient_start_and_end_points": {
          "signature": "get_gradient_start_and_end_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_group_class": {
          "signature": "get_group_class()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_image": {
          "signature": "get_image(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_last_point": {
          "signature": "get_last_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_left": {
          "signature": "get_left()",
          "summary": "Get left Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get left Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_merged_array": {
          "signature": "get_merged_array(array_attr)",
          "summary": "Return all of a given attribute from this mobject and all submobjects.",
          "doc": "Return all of a given attribute from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_midpoint": {
          "signature": "get_midpoint()",
          "summary": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.",
          "doc": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.\n\nExamples\n--------\n\n.. manim:: AngleMidPoint\n    :save_last_frame:\n\n    class AngleMidPoint(Scene):\n        def construct(self):\n            line1 = Line(ORIGIN, 2*RIGHT)\n            line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n            a = Angle(line1, line2, radius=1.5, other_angle=False)\n            d = Dot(a.get_midpoint()).set_color(RED)\n\n            self.add(line1, line2, a, d)\n            self.wait()"
        },
        "get_mobject_type_class": {
          "signature": "get_mobject_type_class()",
          "summary": "Return the base class of this mobject type.",
          "doc": "Return the base class of this mobject type."
        },
        "get_mobjects_from": {
          "signature": "get_mobjects_from(svg)",
          "summary": "Convert the elements of the SVG to a list of mobjects.",
          "doc": "Convert the elements of the SVG to a list of mobjects.\n\nParameters\n----------\nsvg\n    The parsed SVG file."
        },
        "get_nadir": {
          "signature": "get_nadir()",
          "summary": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "get_nth_curve_function": {
          "signature": "get_nth_curve_function(n)",
          "summary": "Returns the expression of the nth curve.",
          "doc": "Returns the expression of the nth curve.\n\nParameters\n----------\nn\n    index of the desired curve.\n\nReturns\n-------\nCallable[float, Point3D]\n    expression of the nth bezier curve."
        },
        "get_nth_curve_function_with_length": {
          "signature": "get_nth_curve_function_with_length(n, sample_points=None)",
          "summary": "Returns the expression of the nth curve along with its (approximate) length.",
          "doc": "Returns the expression of the nth curve along with its (approximate) length.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\ncurve : Callable[[float], Point3D]\n    The function for the nth curve.\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length": {
          "signature": "get_nth_curve_length(n, sample_points=None)",
          "summary": "Returns the (approximate) length of the nth curve.",
          "doc": "Returns the (approximate) length of the nth curve.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length_pieces": {
          "signature": "get_nth_curve_length_pieces(n, sample_points=None)",
          "summary": "Returns the array of short line lengths used for length approximation.",
          "doc": "Returns the array of short line lengths used for length approximation.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\n    The short length-pieces of the nth curve."
        },
        "get_nth_curve_points": {
          "signature": "get_nth_curve_points(n)",
          "summary": "Returns the points defining the nth curve of the vmobject.",
          "doc": "Returns the points defining the nth curve of the vmobject.\n\nParameters\n----------\nn\n    index of the desired bezier curve.\n\nReturns\n-------\nCubicBezierPoints\n    points defining the nth bezier curve (anchors, handles)"
        },
        "get_num_curves": {
          "signature": "get_num_curves()",
          "summary": "Returns the number of curves of the vmobject.",
          "doc": "Returns the number of curves of the vmobject.\n\nReturns\n-------\nint\n    number of curves of the vmobject."
        },
        "get_num_points": {
          "signature": "get_num_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_pieces": {
          "signature": "get_pieces(n_pieces)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_point_mobject": {
          "signature": "get_point_mobject(center=None)",
          "summary": "The simplest :class:`~.Mobject` to be transformed to or from self.",
          "doc": "The simplest :class:`~.Mobject` to be transformed to or from self.\nShould by a point of the appropriate type"
        },
        "get_points_defining_boundary": {
          "signature": "get_points_defining_boundary()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_right": {
          "signature": "get_right()",
          "summary": "Get right Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get right Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_sheen_direction": {
          "signature": "get_sheen_direction()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_sheen_factor": {
          "signature": "get_sheen_factor()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_start": {
          "signature": "get_start()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts."
        },
        "get_start_anchors": {
          "signature": "get_start_anchors()",
          "summary": "Returns the start anchors of the bezier curves.",
          "doc": "Returns the start anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_start_and_end": {
          "signature": "get_start_and_end()",
          "summary": "Returns starting and ending point of a stroke as a ``tuple``.",
          "doc": "Returns starting and ending point of a stroke as a ``tuple``."
        },
        "get_stroke_color": {
          "signature": "get_stroke_color(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_colors": {
          "signature": "get_stroke_colors(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacities": {
          "signature": "get_stroke_opacities(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacity": {
          "signature": "get_stroke_opacity(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_rgbas": {
          "signature": "get_stroke_rgbas(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_width": {
          "signature": "get_stroke_width(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_style": {
          "signature": "get_style(simple=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_subcurve": {
          "signature": "get_subcurve(a, b)",
          "summary": "Returns the subcurve of the VMobject between the interval [a, b].",
          "doc": "Returns the subcurve of the VMobject between the interval [a, b].\nThe curve is a VMobject itself.\n\nParameters\n----------\n\na\n    The lower bound.\nb\n    The upper bound.\n\nReturns\n-------\nVMobject\n    The subcurve between of [a, b]"
        },
        "get_subpaths": {
          "signature": "get_subpaths()",
          "summary": "Returns subpaths formed by the curves of the VMobject.",
          "doc": "Returns subpaths formed by the curves of the VMobject.\n\nSubpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.\n\nReturns\n-------\nlist[CubicSpline]\n    subpaths."
        },
        "get_subpaths_from_points": {
          "signature": "get_subpaths_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_time_based_updaters": {
          "signature": "get_time_based_updaters()",
          "summary": "Return all updaters using the ``dt`` parameter.",
          "doc": "Return all updaters using the ``dt`` parameter.\n\nThe updaters use this parameter as the input for difference in time.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of time based updaters.\n\nSee Also\n--------\n:meth:`get_updaters`\n:meth:`has_time_based_updater`"
        },
        "get_top": {
          "signature": "get_top()",
          "summary": "Get top Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get top Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_updaters": {
          "signature": "get_updaters()",
          "summary": "Return all updaters.",
          "doc": "Return all updaters.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of updaters.\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_time_based_updaters`"
        },
        "get_x": {
          "signature": "get_x(direction=[0. 0. 0.])",
          "summary": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_y": {
          "signature": "get_y(direction=[0. 0. 0.])",
          "summary": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z": {
          "signature": "get_z(direction=[0. 0. 0.])",
          "summary": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z_index_reference_point": {
          "signature": "get_z_index_reference_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_zenith": {
          "signature": "get_zenith()",
          "summary": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "handle_transform": {
          "signature": "handle_transform(mob, matrix)",
          "summary": "Apply SVG transformations to the converted mobject.",
          "doc": "Apply SVG transformations to the converted mobject.\n\nParameters\n----------\nmob\n    The converted mobject.\nmatrix\n    The transformation matrix determined from the SVG\n    transformation."
        },
        "has_new_path_started": {
          "signature": "has_new_path_started()",
          "summary": "No documentation available.",
          "doc": null
        },
        "has_no_points": {
          "signature": "has_no_points()",
          "summary": "Check if :class:`~.Mobject` *does not* contains points.",
          "doc": "Check if :class:`~.Mobject` *does not* contains points."
        },
        "has_points": {
          "signature": "has_points()",
          "summary": "Check if :class:`~.Mobject` contains points.",
          "doc": "Check if :class:`~.Mobject` contains points."
        },
        "has_time_based_updater": {
          "signature": "has_time_based_updater()",
          "summary": "Test if ``self`` has a time based updater.",
          "doc": "Test if ``self`` has a time based updater.\n\nReturns\n-------\n:class:`bool`\n    ``True`` if at least one updater uses the ``dt`` parameter, ``False``\n    otherwise.\n\nSee Also\n--------\n:meth:`get_time_based_updaters`"
        },
        "init_colors": {
          "signature": "init_colors(propagate_colors=True)",
          "summary": "Initializes the colors.",
          "doc": "Initializes the colors.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "init_svg_mobject": {
          "signature": "init_svg_mobject(use_svg_cache)",
          "summary": "Checks whether the SVG has already been imported and",
          "doc": "Checks whether the SVG has already been imported and\ngenerates it if not.\n\nSee also\n--------\n:meth:`.SVGMobject.generate_mobject`"
        },
        "insert": {
          "signature": "insert(index, mobject)",
          "summary": "Inserts a mobject at a specific position into self.submobjects Effectively just calls  ``self.submobjects.insert(index, mobject)``,",
          "doc": "Inserts a mobject at a specific position into self.submobjects\n\nEffectively just calls  ``self.submobjects.insert(index, mobject)``,\nwhere ``self.submobjects`` is a list.\n\nHighly adapted from ``Mobject.add``.\n\nParameters\n----------\nindex\n    The index at which\nmobject\n    The mobject to be inserted."
        },
        "insert_n_curves": {
          "signature": "insert_n_curves(n)",
          "summary": "Inserts n curves to the bezier curves of the vmobject.",
          "doc": "Inserts n curves to the bezier curves of the vmobject.\n\nParameters\n----------\nn\n    Number of curves to insert.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "insert_n_curves_to_point_list": {
          "signature": "insert_n_curves_to_point_list(n, points)",
          "summary": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.",
          "doc": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.\n\nParameters\n----------\nn\n    Number of desired curves.\npoints\n    Starting points.\n\nReturns\n-------\n    Points generated."
        },
        "interpolate": {
          "signature": "interpolate(mobject1, mobject2, alpha, path_func=<function interpolate at 0x109973f60>)",
          "summary": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``",
          "doc": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``\nand ``mobject2``.\n\nExamples\n--------\n\n.. manim:: DotInterpolation\n    :save_last_frame:\n\n    class DotInterpolation(Scene):\n        def construct(self):\n            dotR = Dot(color=DARK_GREY)\n            dotR.shift(2 * RIGHT)\n            dotL = Dot(color=WHITE)\n            dotL.shift(2 * LEFT)\n\n            dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n            self.add(dotL, dotR, dotMiddle)"
        },
        "interpolate_color": {
          "signature": "interpolate_color(mobject1, mobject2, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "invert": {
          "signature": "invert(recursive=False)",
          "summary": "Inverts the list of :attr:`submobjects`.",
          "doc": "Inverts the list of :attr:`submobjects`.\n\nParameters\n----------\nrecursive\n    If ``True``, all submobject lists of this mobject's family are inverted.\n\nExamples\n--------\n\n.. manim:: InvertSumobjectsExample\n\n    class InvertSumobjectsExample(Scene):\n        def construct(self):\n            s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2 = s.copy()\n            s2.invert()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "is_closed": {
          "signature": "is_closed()",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_off_screen": {
          "signature": "is_off_screen()",
          "summary": "No documentation available.",
          "doc": null
        },
        "length_over_dim": {
          "signature": "length_over_dim(dim)",
          "summary": "Measure the length of an :class:`~.Mobject` in a certain direction.",
          "doc": "Measure the length of an :class:`~.Mobject` in a certain direction."
        },
        "line_to_mobject": {
          "signature": "line_to_mobject(line)",
          "summary": "Convert a line element to a vectorized mobject.",
          "doc": "Convert a line element to a vectorized mobject.\n\nParameters\n----------\nline\n    The parsed SVG line."
        },
        "make_jagged": {
          "signature": "make_jagged()",
          "summary": "No documentation available.",
          "doc": null
        },
        "make_smooth": {
          "signature": "make_smooth()",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_background_image": {
          "signature": "match_background_image(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_color": {
          "signature": "match_color(mobject)",
          "summary": "Match the color with the color of another :class:`~.Mobject`.",
          "doc": "Match the color with the color of another :class:`~.Mobject`."
        },
        "match_coord": {
          "signature": "match_coord(mobject, dim, direction=[0. 0. 0.])",
          "summary": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`.",
          "doc": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`."
        },
        "match_depth": {
          "signature": "match_depth(mobject, kwargs)",
          "summary": "Match the depth with the depth of another :class:`~.Mobject`.",
          "doc": "Match the depth with the depth of another :class:`~.Mobject`."
        },
        "match_dim_size": {
          "signature": "match_dim_size(mobject, dim, kwargs)",
          "summary": "Match the specified dimension with the dimension of another :class:`~.Mobject`.",
          "doc": "Match the specified dimension with the dimension of another :class:`~.Mobject`."
        },
        "match_height": {
          "signature": "match_height(mobject, kwargs)",
          "summary": "Match the height with the height of another :class:`~.Mobject`.",
          "doc": "Match the height with the height of another :class:`~.Mobject`."
        },
        "match_points": {
          "signature": "match_points(mobject, copy_submobjects=True)",
          "summary": "Edit points, positions, and submobjects to be identical",
          "doc": "Edit points, positions, and submobjects to be identical\nto another :class:`~.Mobject`, while keeping the style unchanged.\n\nExamples\n--------\n.. manim:: MatchPointsScene\n\n    class MatchPointsScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)"
        },
        "match_style": {
          "signature": "match_style(vmobject, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_updaters": {
          "signature": "match_updaters(mobject)",
          "summary": "Match the updaters of the given mobject.",
          "doc": "Match the updaters of the given mobject.\n\nParameters\n----------\nmobject\n    The mobject whose updaters get matched.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nNote\n----\nAll updaters from submobjects are removed, but only updaters of the given\nmobject are matched, not those of it's submobjects.\n\nSee also\n--------\n:meth:`add_updater`\n:meth:`clear_updaters`"
        },
        "match_width": {
          "signature": "match_width(mobject, kwargs)",
          "summary": "Match the width with the width of another :class:`~.Mobject`.",
          "doc": "Match the width with the width of another :class:`~.Mobject`."
        },
        "match_x": {
          "signature": "match_x(mobject, direction=[0. 0. 0.])",
          "summary": "Match x coord.",
          "doc": "Match x coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_y": {
          "signature": "match_y(mobject, direction=[0. 0. 0.])",
          "summary": "Match y coord.",
          "doc": "Match y coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_z": {
          "signature": "match_z(mobject, direction=[0. 0. 0.])",
          "summary": "Match z coord.",
          "doc": "Match z coord. to the x coord. of another :class:`~.Mobject`."
        },
        "modify_xml_tree": {
          "signature": "modify_xml_tree(element_tree)",
          "summary": "Modifies the SVG element tree to include default",
          "doc": "Modifies the SVG element tree to include default\nstyle information.\n\nParameters\n----------\nelement_tree\n    The parsed element tree from the SVG file."
        },
        "move_into_position": {
          "signature": "move_into_position()",
          "summary": "Scale and move the generated mobject into position.",
          "doc": "Scale and move the generated mobject into position."
        },
        "move_to": {
          "signature": "move_to(point_or_mobject, aligned_edge=[0. 0. 0.], coor_mask=[1 1 1])",
          "summary": "Move center of the :class:`~.Mobject` to certain Point3D.",
          "doc": "Move center of the :class:`~.Mobject` to certain Point3D."
        },
        "next_to": {
          "signature": "next_to(mobject_or_point, direction=[1. 0. 0.], buff=0.25, aligned_edge=[0. 0. 0.], submobject_to_align=None, index_of_submobject_to_align=None, coor_mask=[1 1 1])",
          "summary": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.",
          "doc": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.\n\nExamples\n--------\n\n.. manim:: GeometricShapes\n    :save_last_frame:\n\n    class GeometricShapes(Scene):\n        def construct(self):\n            d = Dot()\n            c = Circle()\n            s = Square()\n            t = Triangle()\n            d.next_to(c, RIGHT)\n            s.next_to(c, LEFT)\n            t.next_to(c, DOWN)\n            self.add(d, c, s, t)"
        },
        "nonempty_submobjects": {
          "signature": "nonempty_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "null_point_align": {
          "signature": "null_point_align(mobject)",
          "summary": "If a :class:`~.Mobject` with points is being aligned to",
          "doc": "If a :class:`~.Mobject` with points is being aligned to\none without, treat both as groups, and push\nthe one with points into its own submobjects\nlist.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``"
        },
        "path_to_mobject": {
          "signature": "path_to_mobject(path)",
          "summary": "Convert a path element to a vectorized mobject.",
          "doc": "Convert a path element to a vectorized mobject.\n\nParameters\n----------\npath\n    The parsed SVG path."
        },
        "point_from_proportion": {
          "signature": "point_from_proportion(alpha)",
          "summary": "Gets the point at a proportion along the path of the :class:`VMobject`.",
          "doc": "Gets the point at a proportion along the path of the :class:`VMobject`.\n\nParameters\n----------\nalpha\n    The proportion along the the path of the :class:`VMobject`.\n\nReturns\n-------\n:class:`numpy.ndarray`\n    The point on the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``alpha`` is not between 0 and 1.\n:exc:`Exception`\n    If the :class:`VMobject` has no points.\n\nExample\n-------\n.. manim:: PointFromProportion\n    :save_last_frame:\n\n    class PointFromProportion(Scene):\n        def construct(self):\n            line = Line(2*DL, 2*UR)\n            self.add(line)\n            colors = (RED, BLUE, YELLOW)\n            proportions = (1/4, 1/2, 3/4)\n            for color, proportion in zip(colors, proportions):\n                self.add(Dot(color=color).move_to(\n                        line.point_from_proportion(proportion)\n                ))"
        },
        "pointwise_become_partial": {
          "signature": "pointwise_become_partial(vmobject, a, b)",
          "summary": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and",
          "doc": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and\nan upper bound ``b``, modify this :class:`.VMobject`'s points to\nmatch the portion of the B\u00e9zier spline described by ``vmobject.points``\nwith the parameter ``t`` between ``a`` and ``b``.\n\nParameters\n----------\nvmobject\n    The :class:`.VMobject` that will serve as a model.\na\n    The lower bound for ``t``.\nb\n    The upper bound for ``t``\n\nReturns\n-------\n:class:`.VMobject`\n    The :class:`.VMobject` itself, after the transformation.\n\nRaises\n------\nTypeError\n    If ``vmobject`` is not an instance of :class:`VMobject`."
        },
        "polygon_to_mobject": {
          "signature": "polygon_to_mobject(polygon)",
          "summary": "Convert a polygon element to a vectorized mobject.",
          "doc": "Convert a polygon element to a vectorized mobject.\n\nParameters\n----------\npolygon\n    The parsed SVG polygon."
        },
        "polyline_to_mobject": {
          "signature": "polyline_to_mobject(polyline)",
          "summary": "Convert a polyline element to a vectorized mobject.",
          "doc": "Convert a polyline element to a vectorized mobject.\n\nParameters\n----------\npolyline\n    The parsed SVG polyline."
        },
        "pose_at_angle": {
          "signature": "pose_at_angle(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "proportion_from_point": {
          "signature": "proportion_from_point(point)",
          "summary": "Returns the proportion along the path of the :class:`VMobject`",
          "doc": "Returns the proportion along the path of the :class:`VMobject`\na particular given point is at.\n\nParameters\n----------\npoint\n    The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`\n\nReturns\n-------\nfloat\n    The proportion along the path of the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``point`` does not lie on the curve.\n:exc:`Exception`\n    If the :class:`VMobject` has no points."
        },
        "push_self_into_submobjects": {
          "signature": "push_self_into_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "put_start_and_end_on": {
          "signature": "put_start_and_end_on(start, end)",
          "summary": "No documentation available.",
          "doc": null
        },
        "rect_to_mobject": {
          "signature": "rect_to_mobject(rect)",
          "summary": "Convert a rectangle element to a vectorized mobject.",
          "doc": "Convert a rectangle element to a vectorized mobject.\n\nParameters\n----------\nrect\n    The parsed SVG rectangle."
        },
        "reduce_across_dimension": {
          "signature": "reduce_across_dimension(reduce_func, dim)",
          "summary": "Find the min or max value from a dimension across all points in this and submobjects.",
          "doc": "Find the min or max value from a dimension across all points in this and submobjects."
        },
        "remove": {
          "signature": "remove(mobjects)",
          "summary": "Remove :attr:`submobjects`.",
          "doc": "Remove :attr:`submobjects`.\n\nThe mobjects are removed from :attr:`submobjects`, if they exist.\n\nSubclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to remove.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add`"
        },
        "remove_updater": {
          "signature": "remove_updater(update_function)",
          "summary": "Remove an updater.",
          "doc": "Remove an updater.\n\nIf the same updater is applied multiple times, every instance gets removed.\n\nParameters\n----------\nupdate_function\n    The update function to be removed.\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`clear_updaters`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "repeat": {
          "signature": "repeat(count)",
          "summary": "This can make transition animations nicer",
          "doc": "This can make transition animations nicer"
        },
        "repeat_submobject": {
          "signature": "repeat_submobject(submob)",
          "summary": "No documentation available.",
          "doc": null
        },
        "replace": {
          "signature": "replace(mobject, dim_to_match=0, stretch=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "rescale_to_fit": {
          "signature": "rescale_to_fit(length, dim, stretch=False, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reset_points": {
          "signature": "reset_points()",
          "summary": "Sets :attr:`points` to be an empty array.",
          "doc": "Sets :attr:`points` to be an empty array."
        },
        "resize_points": {
          "signature": "resize_points(new_length, resize_func=<function resize_array at 0x1056ab380>)",
          "summary": "Resize the array of anchor points and handles to have",
          "doc": "Resize the array of anchor points and handles to have\nthe specified size.\n\nParameters\n----------\nnew_length\n    The new (total) number of points.\nresize_func\n    A function mapping a Numpy array (the points) and an integer\n    (the target size) to a Numpy array. The default implementation\n    is based on Numpy's ``resize`` function."
        },
        "restore": {
          "signature": "restore()",
          "summary": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`.",
          "doc": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`."
        },
        "resume_updating": {
          "signature": "resume_updating(recursive=True)",
          "summary": "Enable updating from updaters and animations.",
          "doc": "Enable updating from updaters and animations.\n\nParameters\n----------\nrecursive\n    Whether to recursively enable updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`suspend_updating`\n:meth:`add_updater`"
        },
        "reverse_direction": {
          "signature": "reverse_direction()",
          "summary": "Reverts the point direction by inverting the point order.",
          "doc": "Reverts the point direction by inverting the point order.\n\nReturns\n-------\n:class:`VMobject`\n    Returns self.\n\nExamples\n--------\n.. manim:: ChangeOfDirection\n\n    class ChangeOfDirection(Scene):\n        def construct(self):\n            ccw = RegularPolygon(5)\n            ccw.shift(LEFT)\n            cw = RegularPolygon(5)\n            cw.shift(RIGHT).reverse_direction()\n\n            self.play(Create(ccw), Create(cw),\n            run_time=4)"
        },
        "reverse_points": {
          "signature": "reverse_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "rotate": {
          "signature": "rotate(angle, axis=[0. 0. 1.], about_point=None, kwargs)",
          "summary": "Rotates the :class:`~.Mobject` about a certain point.",
          "doc": "Rotates the :class:`~.Mobject` about a certain point."
        },
        "rotate_about_origin": {
          "signature": "rotate_about_origin(angle, axis=[0. 0. 1.], axes=[])",
          "summary": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0].",
          "doc": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0]."
        },
        "rotate_sheen_direction": {
          "signature": "rotate_sheen_direction(angle, axis=[0. 0. 1.], family=True)",
          "summary": "Rotates the direction of the applied sheen.",
          "doc": "Rotates the direction of the applied sheen.\n\nParameters\n----------\nangle\n    Angle by which the direction of sheen is rotated.\naxis\n    Axis of rotation.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen_direction`"
        },
        "save_image": {
          "signature": "save_image(name=None)",
          "summary": "Saves an image of only this :class:`Mobject` at its position to a png",
          "doc": "Saves an image of only this :class:`Mobject` at its position to a png\nfile."
        },
        "save_state": {
          "signature": "save_state()",
          "summary": "Save the current state (position, color & size).",
          "doc": "Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`."
        },
        "scale": {
          "signature": "scale(scale_factor, scale_stroke=False, kwargs)",
          "summary": "Scale the size by a factor.",
          "doc": "Scale the size by a factor.\n\nDefault behavior is to scale about the center of the vmobject.\n\nParameters\n----------\nscale_factor\n    The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n    will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n    if :math:`\\alpha < 0`, the mobject is also flipped.\nscale_stroke\n    Boolean determining if the object's outline is scaled when the object is scaled.\n    If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.\nkwargs\n    Additional keyword arguments passed to\n    :meth:`~.Mobject.scale`.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n\n.. manim:: MobjectScaleExample\n    :save_last_frame:\n\n    class MobjectScaleExample(Scene):\n        def construct(self):\n            c1 = Circle(1, RED).set_x(-1)\n            c2 = Circle(1, GREEN).set_x(1)\n\n            vg = VGroup(c1, c2)\n            vg.set_stroke(width=50)\n            self.add(vg)\n\n            self.play(\n                c1.animate.scale(.25),\n                c2.animate.scale(.25,\n                    scale_stroke=True)\n            )\n\nSee also\n--------\n:meth:`move_to`"
        },
        "scale_handle_to_anchor_distances": {
          "signature": "scale_handle_to_anchor_distances(factor)",
          "summary": "If the distance between a given handle point H and its associated",
          "doc": "If the distance between a given handle point H and its associated\nanchor point A is d, then it changes H to be a distances factor*d\naway from A, but so that the line from A to H doesn't change.\nThis is mostly useful in the context of applying a (differentiable)\nfunction, to preserve tangency properties.  One would pull all the\nhandles closer to their anchors, apply the function then push them out\nagain.\n\nParameters\n----------\nfactor\n    The factor used for scaling.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "scale_to_fit_depth": {
          "signature": "scale_to_fit_depth(depth, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional."
        },
        "scale_to_fit_height": {
          "signature": "scale_to_fit_height(height, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.scale_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(5.0)"
        },
        "scale_to_fit_width": {
          "signature": "scale_to_fit_width(width, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.scale_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(5.0)"
        },
        "set": {
          "signature": "set(kwargs)",
          "summary": "Sets attributes.",
          "doc": "Sets attributes.\n\nI.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.\n\nThis is a convenience to be used along with :attr:`animate` to\nanimate setting attributes.\n\nIn addition to this method, there is a compatibility\nlayer that allows ``get_*`` and ``set_*`` methods to\nget and set generic attributes. For instance::\n\n    >>> mob = Mobject()\n    >>> mob.set_foo(0)\n    Mobject\n    >>> mob.get_foo()\n    0\n    >>> mob.foo\n    0\n\nThis compatibility layer does not interfere with any\n``get_*`` or ``set_*`` methods that are explicitly\ndefined.\n\n.. warning::\n\n    This compatibility layer is for backwards compatibility\n    and is not guaranteed to stay around. Where applicable,\n    please prefer getting/setting attributes normally or with\n    the :meth:`set` method.\n\nParameters\n----------\n**kwargs\n    The attributes and corresponding values to set.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> mob = Mobject()\n    >>> mob.set(foo=0)\n    Mobject\n    >>> mob.foo\n    0"
        },
        "set_anchors_and_handles": {
          "signature": "set_anchors_and_handles(anchors1, handles1, handles2, anchors2)",
          "summary": "Given two sets of anchors and handles, process them to set them as anchors",
          "doc": "Given two sets of anchors and handles, process them to set them as anchors\nand handles of the VMobject.\n\nanchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier\ncurve of the vmobject. There are four hardcoded parameters and this is a\nproblem as it makes the number of points per cubic curve unchangeable from 4\n(two anchors and two handles).\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "set_background_stroke": {
          "signature": "set_background_stroke(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_cap_style": {
          "signature": "set_cap_style(cap_style)",
          "summary": "Sets the cap style of the :class:`VMobject`.",
          "doc": "Sets the cap style of the :class:`VMobject`.\n\nParameters\n----------\ncap_style\n    The cap style to be set. See :class:`.CapStyleType` for options.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: CapStyleExample\n    :save_last_frame:\n\n    class CapStyleExample(Scene):\n        def construct(self):\n            line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n            line.set_cap_style(CapStyleType.ROUND)\n            self.add(line)"
        },
        "set_color": {
          "signature": "set_color(color, family=True)",
          "summary": "Condition is function which takes in one arguments, (x, y, z).",
          "doc": "Condition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color"
        },
        "set_color_by_gradient": {
          "signature": "set_color_by_gradient(colors)",
          "summary": "Parameters",
          "doc": "Parameters\n----------\ncolors\n    The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.\n\nself.color = ManimColor.parse(color)\nreturn self"
        },
        "set_colors_by_radial_gradient": {
          "signature": "set_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_coord": {
          "signature": "set_coord(value, dim, direction=[0. 0. 0.])",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_fill": {
          "signature": "set_fill(color=None, opacity=None, family=True)",
          "summary": "Set the fill color and fill opacity of a :class:`VMobject`.",
          "doc": "Set the fill color and fill opacity of a :class:`VMobject`.\n\nParameters\n----------\ncolor\n    Fill color of the :class:`VMobject`.\nopacity\n    Fill opacity of the :class:`VMobject`.\nfamily\n    If ``True``, the fill color of all submobjects is also set.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: SetFill\n    :save_last_frame:\n\n    class SetFill(Scene):\n        def construct(self):\n            square = Square().scale(2).set_fill(WHITE,1)\n            circle1 = Circle().set_fill(GREEN,0.8)\n            circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n            circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n            group = Group(circle1,circle2,circle3).arrange()\n            self.add(square)\n            self.add(group)\n\nSee Also\n--------\n:meth:`~.VMobject.set_style`"
        },
        "set_opacity": {
          "signature": "set_opacity(opacity, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_points": {
          "signature": "set_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_points_as_corners": {
          "signature": "set_points_as_corners(points)",
          "summary": "Given an array of points, set them as corners of the",
          "doc": "Given an array of points, set them as corners of the\n:class:`VMobject`.\n\nTo achieve that, this algorithm sets handles aligned with the anchors\nsuch that the resultant B\u00e9zier curve will be the segment between the\ntwo anchors.\n\nParameters\n----------\npoints\n    Array of points that will be set as corners.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after setting the new points as corners.\n\n\nExamples\n--------\n.. manim:: PointsAsCornersExample\n    :save_last_frame:\n\n    class PointsAsCornersExample(Scene):\n        def construct(self):\n            corners = (\n                # create square\n                UR, UL,\n                DL, DR,\n                UR,\n                # create crosses\n                DL, UL,\n                DR\n            )\n            vmob = VMobject(stroke_color=RED)\n            vmob.set_points_as_corners(corners).scale(2)\n            self.add(vmob)"
        },
        "set_points_smoothly": {
          "signature": "set_points_smoothly(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_shade_in_3d": {
          "signature": "set_shade_in_3d(value=True, z_index_as_group=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_sheen": {
          "signature": "set_sheen(factor, direction=None, family=True)",
          "summary": "Applies a color gradient from a direction.",
          "doc": "Applies a color gradient from a direction.\n\nParameters\n----------\nfactor\n    The extent of lustre/gradient to apply. If negative, the gradient\n    starts from black, if positive the gradient starts from white and\n    changes to the current color.\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\n.. manim:: SetSheen\n    :save_last_frame:\n\n    class SetSheen(Scene):\n        def construct(self):\n            circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n            self.add(circle)"
        },
        "set_sheen_direction": {
          "signature": "set_sheen_direction(direction, family=True)",
          "summary": "Sets the direction of the applied sheen.",
          "doc": "Sets the direction of the applied sheen.\n\nParameters\n----------\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen`\n:meth:`~.VMobject.rotate_sheen_direction`"
        },
        "set_stroke": {
          "signature": "set_stroke(color=None, width=None, opacity=None, background=False, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_style": {
          "signature": "set_style(fill_color=None, fill_opacity=None, stroke_color=None, stroke_width=None, stroke_opacity=None, background_stroke_color=None, background_stroke_width=None, background_stroke_opacity=None, sheen_factor=None, sheen_direction=None, background_image=None, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_gradient": {
          "signature": "set_submobject_colors_by_gradient(colors)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_radial_gradient": {
          "signature": "set_submobject_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_x": {
          "signature": "set_x(x, direction=[0. 0. 0.])",
          "summary": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_y": {
          "signature": "set_y(y, direction=[0. 0. 0.])",
          "summary": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z": {
          "signature": "set_z(z, direction=[0. 0. 0.])",
          "summary": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z_index": {
          "signature": "set_z_index(z_index_value, family=True)",
          "summary": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.",
          "doc": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.\n\nParameters\n----------\nz_index_value\n    The new value of :attr:`z_index` set.\nfamily\n    If ``True``, the :attr:`z_index` value of all submobjects is also set.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)\n\nExamples\n--------\n.. manim:: SetZIndex\n    :save_last_frame:\n\n    class SetZIndex(Scene):\n        def construct(self):\n            text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n            square = Square(2, fill_opacity=1).set_z_index(2)\n            tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n            circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n            # Displaying order is now defined by z_index values\n            self.add(text)\n            self.add(square)\n            self.add(tex)\n            self.add(circle)"
        },
        "set_z_index_by_z_Point3D": {
          "signature": "set_z_index_by_z_Point3D()",
          "summary": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.",
          "doc": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)"
        },
        "shift": {
          "signature": "shift(vectors)",
          "summary": "Shift by the given vectors.",
          "doc": "Shift by the given vectors.\n\nParameters\n----------\nvectors\n    Vectors to shift by. If multiple vectors are given, they are added\n    together.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`move_to`"
        },
        "shift_onto_screen": {
          "signature": "shift_onto_screen(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "show": {
          "signature": "show(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "shuffle": {
          "signature": "shuffle(recursive=False)",
          "summary": "Shuffles the list of :attr:`submobjects`.",
          "doc": "Shuffles the list of :attr:`submobjects`."
        },
        "shuffle_submobjects": {
          "signature": "shuffle_submobjects(args, kwargs)",
          "summary": "Shuffles the order of :attr:`submobjects` Examples",
          "doc": "Shuffles the order of :attr:`submobjects`\n\nExamples\n--------\n\n.. manim:: ShuffleSubmobjectsExample\n\n    class ShuffleSubmobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2= s.copy()\n            s2.shuffle_submobjects()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "sort": {
          "signature": "sort(point_to_num_func=<function Mobject.<lambda> at 0x10a232660>, submob_func=None)",
          "summary": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.",
          "doc": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."
        },
        "sort_submobjects": {
          "signature": "sort_submobjects(args, kwargs)",
          "summary": "Sort the :attr:`submobjects`",
          "doc": "Sort the :attr:`submobjects`"
        },
        "space_out_submobjects": {
          "signature": "space_out_submobjects(factor=1.5, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "split": {
          "signature": "split()",
          "summary": "No documentation available.",
          "doc": null
        },
        "start_new_path": {
          "signature": "start_new_path(point)",
          "summary": "Append a ``point`` to the :attr:`VMobject.points`, which will be the",
          "doc": "Append a ``point`` to the :attr:`VMobject.points`, which will be the\nbeginning of a new B\u00e9zier curve in the path given by the points. If\nthere's an unfinished curve at the end of :attr:`VMobject.points`,\ncomplete it by appending the last B\u00e9zier curve's start anchor as many\ntimes as needed.\n\nParameters\n----------\npoint\n    A 3D point to append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``point`` and starting a new\n    curve."
        },
        "stretch": {
          "signature": "stretch(factor, dim, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_about_point": {
          "signature": "stretch_about_point(factor, dim, point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_to_fit_depth": {
          "signature": "stretch_to_fit_depth(depth, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional."
        },
        "stretch_to_fit_height": {
          "signature": "stretch_to_fit_height(height, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(2.0)"
        },
        "stretch_to_fit_width": {
          "signature": "stretch_to_fit_width(width, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(2.0)"
        },
        "surround": {
          "signature": "surround(mobject, dim_to_match=0, stretch=False, buff=0.25)",
          "summary": "No documentation available.",
          "doc": null
        },
        "suspend_updating": {
          "signature": "suspend_updating(recursive=True)",
          "summary": "Disable updating from updaters and animations.",
          "doc": "Disable updating from updaters and animations.\n\n\nParameters\n----------\nrecursive\n    Whether to recursively suspend updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`resume_updating`\n:meth:`add_updater`"
        },
        "text_to_mobject": {
          "signature": "text_to_mobject(text)",
          "summary": "Convert a text element to a vectorized mobject.",
          "doc": "Convert a text element to a vectorized mobject.\n\n.. warning::\n\n    Not yet implemented.\n\nParameters\n----------\ntext\n    The parsed SVG text."
        },
        "throw_error_if_no_points": {
          "signature": "throw_error_if_no_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "to_corner": {
          "signature": "to_corner(corner=[-1. -1.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given corner of the screen.",
          "doc": "Moves this :class:`~.Mobject` to the given corner of the screen.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToCornerExample\n    :save_last_frame:\n\n    class ToCornerExample(Scene):\n        def construct(self):\n            c = Circle()\n            c.to_corner(UR)\n            t = Tex(\"To the corner!\")\n            t2 = MathTex(\"x^3\").shift(DOWN)\n            self.add(c,t,t2)\n            t.to_corner(DL, buff=0)\n            t2.to_corner(UL, buff=1.5)"
        },
        "to_edge": {
          "signature": "to_edge(edge=[-1.  0.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given edge of the screen,",
          "doc": "Moves this :class:`~.Mobject` to the given edge of the screen,\nwithout affecting its position in the other dimension.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToEdgeExample\n    :save_last_frame:\n\n    class ToEdgeExample(Scene):\n        def construct(self):\n            tex_top = Tex(\"I am at the top!\")\n            tex_top.to_edge(UP)\n            tex_side = Tex(\"I am moving to the side!\")\n            c = Circle().shift(2*DOWN)\n            self.add(tex_top, tex_side, c)\n            tex_side.to_edge(LEFT)\n            c.to_edge(RIGHT, buff=0)"
        },
        "to_original_color": {
          "signature": "to_original_color()",
          "summary": "No documentation available.",
          "doc": null
        },
        "update": {
          "signature": "update(dt=0, recursive=True)",
          "summary": "Apply all updaters.",
          "doc": "Apply all updaters.\n\nDoes nothing if updating is suspended.\n\nParameters\n----------\ndt\n    The parameter ``dt`` to pass to the update functions. Usually this is the\n    time in seconds since the last call of ``update``.\nrecursive\n    Whether to recursively update all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "update_rgbas_array": {
          "signature": "update_rgbas_array(array_name, color=None, opacity=None)",
          "summary": "No documentation available.",
          "doc": null
        }
      },
      "doc": "Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.\n\nText objects behave like a :class:`.VGroup`-like iterable of all characters\nin the given text. In particular, slicing is possible.\n\nParameters\n----------\ntext\n    The text that needs to be created as a mobject.\nfont\n    The font family to be used to render the text. This is either a system font or\n    one loaded with `register_font()`. Note that font family names may be different\n    across operating systems.\nwarn_missing_font\n    If True (default), Manim will issue a warning if the font does not exist in the\n    (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.\n\nReturns\n-------\n:class:`Text`\n    The mobject-like :class:`.VGroup`.\n\nExamples\n---------\n\n.. manim:: Example1Text\n    :save_last_frame:\n\n    class Example1Text(Scene):\n        def construct(self):\n            text = Text('Hello world').scale(3)\n            self.add(text)\n\n.. manim:: TextColorExample\n    :save_last_frame:\n\n    class TextColorExample(Scene):\n        def construct(self):\n            text1 = Text('Hello world', color=BLUE).scale(3)\n            text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)\n            self.add(text1, text2)\n\n.. manim:: TextItalicAndBoldExample\n    :save_last_frame:\n\n    class TextItalicAndBoldExample(Scene):\n        def construct(self):\n            text1 = Text(\"Hello world\", slant=ITALIC)\n            text2 = Text(\"Hello world\", t2s={'world':ITALIC})\n            text3 = Text(\"Hello world\", weight=BOLD)\n            text4 = Text(\"Hello world\", t2w={'world':BOLD})\n            text5 = Text(\"Hello world\", t2c={'o':YELLOW}, disable_ligatures=True)\n            text6 = Text(\n                \"Visit us at docs.manim.community\",\n                t2c={\"docs.manim.community\": YELLOW},\n                disable_ligatures=True,\n           )\n            text6.scale(1.3).shift(DOWN)\n            self.add(text1, text2, text3, text4, text5 , text6)\n            Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)\n\n.. manim:: TextMoreCustomization\n        :save_last_frame:\n\n        class TextMoreCustomization(Scene):\n            def construct(self):\n                text1 = Text(\n                    'Google',\n                    t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',\n                         '[2:3]': '#fbb003', '[3:4]': '#3174f0',\n                         '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)\n                self.add(text1)\n\nAs :class:`Text` uses Pango to render text, rendering non-English\ncharacters is easily possible:\n\n.. manim:: MultipleFonts\n    :save_last_frame:\n\n    class MultipleFonts(Scene):\n        def construct(self):\n            morning = Text(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")\n            japanese = Text(\n                \"\u65e5\u672c\u3078\u3088\u3046\u3053\u305d\", t2c={\"\u65e5\u672c\": BLUE}\n            )  # works same as ``Text``.\n            mess = Text(\"Multi-Language\", weight=BOLD)\n            russ = Text(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \u092e\u0938 \u0928\u092e \u092e \", font=\"sans-serif\")\n            hin = Text(\"\u0928\u092e\u0938\u094d\u0924\u0947\", font=\"sans-serif\")\n            arb = Text(\n                \"\u0635\u0628\u0627\u062d \u0627\u0644\u062e\u064a\u0631 \\n \u062a\u0634\u0631\u0641\u062a \u0628\u0645\u0642\u0627\u0628\u0644\u062a\u0643\", font=\"sans-serif\"\n            )  # don't mix RTL and LTR languages nothing shows up then ;-)\n            chinese = Text(\"\u81c2\u733f\u300c\u9edb\u6bd4\u300d\u5e36\u8457\u5b69\u5b50\", font=\"sans-serif\")\n            self.add(morning, japanese, mess, russ, hin, arb, chinese)\n            for i,mobj in enumerate(self.mobjects):\n                mobj.shift(DOWN*(i-3))\n\n\n.. manim:: PangoRender\n    :quality: low\n\n    class PangoRender(Scene):\n        def construct(self):\n            morning = Text(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")\n            self.play(Write(morning))\n            self.wait(2)\n\nTests\n-----\n\nCheck that the creation of :class:`~.Text` works::\n\n    >>> Text('The horse does not eat cucumber salad.')\n    Text('The horse does not eat cucumber salad.')"
    },
    "MathTex": {
      "module": "manim.mobject.text.tex_mobject",
      "summary": "A string compiled with LaTeX in math mode.",
      "bases": [
        "SingleStringMathTex"
      ],
      "methods": {
        "__add__": {
          "signature": "__add__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__deepcopy__": {
          "signature": "__deepcopy__(clone_from_id)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getattr__": {
          "signature": "__getattr__(attr)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__getitem__": {
          "signature": "__getitem__(value)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iadd__": {
          "signature": "__iadd__(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__init__": {
          "signature": "__init__(tex_strings, arg_separator=' ', substrings_to_isolate=None, tex_to_color_map=None, tex_environment='align*', kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__isub__": {
          "signature": "__isub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "__iter__": {
          "signature": "__iter__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__len__": {
          "signature": "__len__()",
          "summary": "No documentation available.",
          "doc": null
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__sub__": {
          "signature": "__sub__(other)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add": {
          "signature": "add(mobjects)",
          "summary": "Add mobjects as submobjects.",
          "doc": "Add mobjects as submobjects.\n\nThe mobjects are added to :attr:`submobjects`.\n\nSubclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add_to_back`\n\nExamples\n--------\n::\n\n    >>> outer = Mobject()\n    >>> inner = Mobject()\n    >>> outer = outer.add(inner)\n\nDuplicates are not added again::\n\n    >>> outer = outer.add(inner)\n    >>> len(outer.submobjects)\n    1\n\nOnly Mobjects can be added::\n\n    >>> outer.add(3)\n    Traceback (most recent call last):\n    ...\n    TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.\n\nAdding an object to itself raises an error::\n\n    >>> outer.add(outer)\n    Traceback (most recent call last):\n    ...\n    ValueError: Cannot add Mobject as a submobject of itself (at index 0).\n\nA given mobject cannot be added as a submobject\ntwice to some parent::\n\n    >>> parent = Mobject(name=\"parent\")\n    >>> child = Mobject(name=\"child\")\n    >>> parent.add(child, child)\n    [...] WARNING  ...\n    parent\n    >>> parent.submobjects\n    [child]"
        },
        "add_background_rectangle": {
          "signature": "add_background_rectangle(color=None, opacity=0.75, kwargs)",
          "summary": "Add a BackgroundRectangle as submobject.",
          "doc": "Add a BackgroundRectangle as submobject.\n\nThe BackgroundRectangle is added behind other submobjects.\n\nThis can be used to increase the mobjects visibility in front of a noisy background.\n\nParameters\n----------\ncolor\n    The color of the BackgroundRectangle\nopacity\n    The opacity of the BackgroundRectangle\nkwargs\n    Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_to_back`\n:class:`~.BackgroundRectangle`"
        },
        "add_background_rectangle_to_family_members_with_points": {
          "signature": "add_background_rectangle_to_family_members_with_points(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_background_rectangle_to_submobjects": {
          "signature": "add_background_rectangle_to_submobjects(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve": {
          "signature": "add_cubic_bezier_curve(anchor1, handle1, handle2, anchor2)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_cubic_bezier_curve_to": {
          "signature": "add_cubic_bezier_curve_to(handle1, handle2, anchor)",
          "summary": "Add cubic bezier curve to the path.",
          "doc": "Add cubic bezier curve to the path.\n\nNOTE : the first anchor is not a parameter as by default the end of the last sub-path!\n\nParameters\n----------\nhandle1\n    first handle\nhandle2\n    second handle\nanchor\n    anchor\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_cubic_bezier_curves": {
          "signature": "add_cubic_bezier_curves(curves)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_line_to": {
          "signature": "add_line_to(point)",
          "summary": "Add a straight line from the last point of VMobject to the given point.",
          "doc": "Add a straight line from the last point of VMobject to the given point.\n\nParameters\n----------\n\npoint\n    The end of the straight line.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_n_more_submobjects": {
          "signature": "add_n_more_submobjects(n)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_points_as_corners": {
          "signature": "add_points_as_corners(points)",
          "summary": "Append multiple straight lines at the end of",
          "doc": "Append multiple straight lines at the end of\n:attr:`VMobject.points`, which connect the given ``points`` in order\nstarting from the end of the current path. These ``points`` would be\ntherefore the corners of the new polyline appended to the path.\n\nParameters\n----------\npoints\n    An array of 3D points representing the corners of the polyline to\n    append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending the straight lines to its\n    path."
        },
        "add_quadratic_bezier_curve_to": {
          "signature": "add_quadratic_bezier_curve_to(handle, anchor)",
          "summary": "Add Quadratic bezier curve to the path.",
          "doc": "Add Quadratic bezier curve to the path.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "add_smooth_curve_to": {
          "signature": "add_smooth_curve_to(points)",
          "summary": "Creates a smooth curve from given points and add it to the VMobject.",
          "doc": "Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted\nas a handle, the second as an anchor.\n\nParameters\n----------\npoints\n    Points (anchor and handle, or just anchor) to add a smooth curve from\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nRaises\n------\nValueError\n    If 0 or more than 2 points are given."
        },
        "add_subpath": {
          "signature": "add_subpath(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "add_to_back": {
          "signature": "add_to_back(mobjects)",
          "summary": "Add all passed mobjects to the back of the submobjects.",
          "doc": "Add all passed mobjects to the back of the submobjects.\n\nIf :attr:`submobjects` already contains the given mobjects, they just get moved\nto the back instead.\n\nParameters\n----------\nmobjects\n    The mobjects to add.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\n\n.. note::\n\n    Technically, this is done by adding (or moving) the mobjects to\n    the head of :attr:`submobjects`. The head of this list is rendered\n    first, which places the corresponding mobjects behind the\n    subsequent list members.\n\nRaises\n------\n:class:`ValueError`\n    When a mobject tries to add itself.\n:class:`TypeError`\n    When trying to add an object that is not an instance of :class:`Mobject`.\n\nNotes\n-----\nA mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene).\n\nSee Also\n--------\n:meth:`remove`\n:meth:`add`"
        },
        "add_updater": {
          "signature": "add_updater(update_function, index=None, call_updater=False)",
          "summary": "Add an update function to this mobject.",
          "doc": "Add an update function to this mobject.\n\nUpdate functions, or updaters in short, are functions that are applied to the\nMobject in every frame.\n\nParameters\n----------\nupdate_function\n    The update function to be added.\n    Whenever :meth:`update` is called, this update function gets called using\n    ``self`` as the first parameter.\n    The updater can have a second parameter ``dt``. If it uses this parameter,\n    it gets called using a second value ``dt``, usually representing the time\n    in seconds since the last call of :meth:`update`.\nindex\n    The index at which the new updater should be added in ``self.updaters``.\n    In case ``index`` is ``None`` the updater will be added at the end.\ncall_updater\n    Whether or not to call the updater initially. If ``True``, the updater will\n    be called using ``dt=0``.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n.. manim:: NextToUpdater\n\n    class NextToUpdater(Scene):\n        def construct(self):\n            def dot_position(mobject):\n                mobject.set_value(dot.get_center()[0])\n                mobject.next_to(dot)\n\n            dot = Dot(RIGHT*3)\n            label = DecimalNumber()\n            label.add_updater(dot_position)\n            self.add(dot, label)\n\n            self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))\n\n.. manim:: DtUpdater\n\n    class DtUpdater(Scene):\n        def construct(self):\n            square = Square()\n\n            #Let the square rotate 90\u00b0 per second\n            square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n            self.add(square)\n            self.wait(2)\n\nSee also\n--------\n:meth:`get_updaters`\n:meth:`remove_updater`\n:class:`~.UpdateFromFunc`"
        },
        "align_data": {
          "signature": "align_data(mobject, skip_point_alignment=False)",
          "summary": "Aligns the data of this mobject with another mobject.",
          "doc": "Aligns the data of this mobject with another mobject.\n\nAfterwards, the two mobjects will have the same number of submobjects\n(see :meth:`.align_submobjects`), the same parent structure (see\n:meth:`.null_point_align`). If ``skip_point_alignment`` is false,\nthey will also have the same number of points (see :meth:`.align_points`).\n\nParameters\n----------\nmobject\n    The other mobject this mobject should be aligned to.\nskip_point_alignment\n    Controls whether or not the computationally expensive\n    point alignment is skipped (default: False)."
        },
        "align_on_border": {
          "signature": "align_on_border(direction, buff=0.5)",
          "summary": "Direction just needs to be a vector pointing towards side or",
          "doc": "Direction just needs to be a vector pointing towards side or\ncorner in the 2d plane."
        },
        "align_points": {
          "signature": "align_points(vmobject)",
          "summary": "Adds points to self and vmobject so that they both have the same number of subpaths, with",
          "doc": "Adds points to self and vmobject so that they both have the same number of subpaths, with\ncorresponding subpaths each containing the same number of points.\n\nPoints are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting\nof a single point repeated.\n\nParameters\n----------\nvmobject\n    The object to align points with.\n\nReturns\n-------\n:class:`VMobject`\n   ``self``"
        },
        "align_points_with_larger": {
          "signature": "align_points_with_larger(larger_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_rgbas": {
          "signature": "align_rgbas(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_submobjects": {
          "signature": "align_submobjects(mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "align_to": {
          "signature": "align_to(mobject_or_point, direction=[0. 0. 0.])",
          "summary": "Aligns mobject to another :class:`~.Mobject` in a certain direction.",
          "doc": "Aligns mobject to another :class:`~.Mobject` in a certain direction.\n\nExamples:\nmob1.align_to(mob2, UP) moves mob1 vertically so that its\ntop edge lines ups with mob2's top edge."
        },
        "append_points": {
          "signature": "append_points(new_points)",
          "summary": "Append the given ``new_points`` to the end of",
          "doc": "Append the given ``new_points`` to the end of\n:attr:`VMobject.points`.\n\nParameters\n----------\nnew_points\n    An array of 3D points to append.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``new_points``."
        },
        "append_vectorized_mobject": {
          "signature": "append_vectorized_mobject(vectorized_mobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_complex_function": {
          "signature": "apply_complex_function(function, kwargs)",
          "summary": "Applies a complex function to a :class:`Mobject`.",
          "doc": "Applies a complex function to a :class:`Mobject`.\nThe x and y Point3Ds correspond to the real and imaginary parts respectively.\n\nExample\n-------\n\n.. manim:: ApplyFuncExample\n\n    class ApplyFuncExample(Scene):\n        def construct(self):\n            circ = Circle().scale(1.5)\n            circ_ref = circ.copy()\n            circ.apply_complex_function(\n                lambda x: np.exp(x*1j)\n            )\n            t = ValueTracker(0)\n            circ.add_updater(\n                lambda x: x.become(circ_ref.copy().apply_complex_function(\n                    lambda x: np.exp(x+t.get_value()*1j)\n                )).set_color(BLUE)\n            )\n            self.add(circ_ref)\n            self.play(TransformFromCopy(circ_ref, circ))\n            self.play(t.animate.set_value(TAU), run_time=3)"
        },
        "apply_function": {
          "signature": "apply_function(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_position": {
          "signature": "apply_function_to_position(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_function_to_submobject_positions": {
          "signature": "apply_function_to_submobject_positions(function)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_matrix": {
          "signature": "apply_matrix(matrix, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_over_attr_arrays": {
          "signature": "apply_over_attr_arrays(func)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_points_function_about_point": {
          "signature": "apply_points_function_about_point(func, about_point=None, about_edge=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "apply_style_to_mobject": {
          "signature": "apply_style_to_mobject(mob, shape)",
          "summary": "Apply SVG style information to the converted mobject.",
          "doc": "Apply SVG style information to the converted mobject.\n\nParameters\n----------\nmob\n    The converted mobject.\nshape\n    The parsed SVG element."
        },
        "apply_to_family": {
          "signature": "apply_to_family(func)",
          "summary": "Apply a function to ``self`` and every submobject with points recursively.",
          "doc": "Apply a function to ``self`` and every submobject with points recursively.\n\nParameters\n----------\nfunc\n    The function to apply to each mobject. ``func`` gets passed the respective\n    (sub)mobject as parameter.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`family_members_with_points`"
        },
        "arrange": {
          "signature": "arrange(direction=[1. 0. 0.], buff=0.25, center=True, kwargs)",
          "summary": "Sorts :class:`~.Mobject` next to each other on screen.",
          "doc": "Sorts :class:`~.Mobject` next to each other on screen.\n\nExamples\n--------\n\n.. manim:: Example\n    :save_last_frame:\n\n    class Example(Scene):\n        def construct(self):\n            s1 = Square()\n            s2 = Square()\n            s3 = Square()\n            s4 = Square()\n            x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n            self.add(x)"
        },
        "arrange_in_grid": {
          "signature": "arrange_in_grid(rows=None, cols=None, buff=0.25, cell_alignment=[0. 0. 0.], row_alignments=None, col_alignments=None, row_heights=None, col_widths=None, flow_order='rd', kwargs)",
          "summary": "Arrange submobjects in a grid.",
          "doc": "Arrange submobjects in a grid.\n\nParameters\n----------\nrows\n    The number of rows in the grid.\ncols\n    The number of columns in the grid.\nbuff\n    The gap between grid cells. To specify a different buffer in the horizontal and\n    vertical directions, a tuple of two values can be given - ``(row, col)``.\ncell_alignment\n    The way each submobject is aligned in its grid cell.\nrow_alignments\n    The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n    up, ``\"c\"`` - center, ``\"d\"`` - down.\ncol_alignments\n    The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n    ``\"c\"`` - center, ``\"r\"`` - right.\nrow_heights\n    Defines a list of heights for certain rows (top to bottom). If the list contains\n    ``None``, the corresponding row will fit its height automatically based\n    on the highest element in that row.\ncol_widths\n    Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n    corresponding column will fit its width automatically based on the widest element in that column.\nflow_order\n    The order in which submobjects fill the grid. Can be one of the following values:\n    \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nRaises\n------\nValueError\n    If ``rows`` and ``cols`` are too small to fit all submobjects.\nValueError\n    If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n    :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\nNotes\n-----\nIf only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\nenough to fit all submobjects. If neither is set, they will be chosen to be about the same,\ntending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\nIf both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\ndefined, the latter has higher priority.\n\nExamples\n--------\n.. manim:: ExampleBoxes\n    :save_last_frame:\n\n    class ExampleBoxes(Scene):\n        def construct(self):\n            boxes=VGroup(*[Square() for s in range(0,6)])\n            boxes.arrange_in_grid(rows=2, buff=0.1)\n            self.add(boxes)\n\n\n.. manim:: ArrangeInGrid\n    :save_last_frame:\n\n    class ArrangeInGrid(Scene):\n        def construct(self):\n            boxes = VGroup(*[\n                Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n                for i in range(24)\n            ])\n            self.add(boxes)\n\n            boxes.arrange_in_grid(\n                buff=(0.25,0.5),\n                col_alignments=\"lccccr\",\n                row_alignments=\"uccd\",\n                col_widths=[1, *[None]*4, 1],\n                row_heights=[1, None, None, 1],\n                flow_order=\"dr\"\n            )"
        },
        "arrange_submobjects": {
          "signature": "arrange_submobjects(args, kwargs)",
          "summary": "Arrange the position of :attr:`submobjects` with a small buffer.",
          "doc": "Arrange the position of :attr:`submobjects` with a small buffer.\n\nExamples\n--------\n\n.. manim:: ArrangeSumobjectsExample\n    :save_last_frame:\n\n    class ArrangeSumobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n            s.shift(UP).set_color(BLUE)\n            s2= s.copy().set_color(RED)\n            s2.arrange_submobjects()\n            s2.shift(DOWN)\n            self.add(s,s2)"
        },
        "become": {
          "signature": "become(mobject, match_height=False, match_width=False, match_depth=False, match_center=False, stretch=False)",
          "summary": "Edit points, colors and submobjects to be identical",
          "doc": "Edit points, colors and submobjects to be identical\nto another :class:`~.Mobject`\n\n.. note::\n\n    If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`\n    will match the height first and then the width.\n\nParameters\n----------\nmatch_height\n    Whether or not to preserve the height of the original\n    :class:`~.Mobject`.\nmatch_width\n    Whether or not to preserve the width of the original\n    :class:`~.Mobject`.\nmatch_depth\n    Whether or not to preserve the depth of the original\n    :class:`~.Mobject`.\nmatch_center\n    Whether or not to preserve the center of the original\n    :class:`~.Mobject`.\nstretch\n    Whether or not to stretch the target mobject to match the\n    the proportions of the original :class:`~.Mobject`.\n\nExamples\n--------\n.. manim:: BecomeScene\n\n    class BecomeScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            circ.become(square)\n            self.wait(0.5)\n\n\nThe following examples illustrate how mobject measurements\nchange when using the ``match_...`` and ``stretch`` arguments.\nWe start with a rectangle that is 2 units high and 4 units wide,\nwhich we want to turn into a circle of radius 3::\n\n    >>> from manim import Rectangle, Circle\n    >>> import numpy as np\n    >>> rect = Rectangle(height=2, width=4)\n    >>> circ = Circle(radius=3)\n\nWith ``stretch=True``, the target circle is deformed to match\nthe proportions of the rectangle, which results in the target\nmobject being an ellipse with height 2 and width 4. We can\ncheck that the resulting points satisfy the ellipse equation\n:math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`\nbeing the semi-axes::\n\n    >>> result = rect.copy().become(circ, stretch=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(4.0))\n    >>> ellipse_points = np.array(result.get_anchors())\n    >>> ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)\n    >>> np.allclose(ellipse_eq, 1)\n    True\n\nWith ``match_height=True`` and ``match_width=True`` the circle is\nscaled such that the height or the width of the rectangle will\nbe preserved, respectively.\nThe points of the resulting mobject satisfy the circle equation\n:math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::\n\n    >>> result = rect.copy().become(circ, match_height=True)\n    >>> result.height, result.width\n    (np.float64(2.0), np.float64(2.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 1)\n    True\n    >>> result = rect.copy().become(circ, match_width=True)\n    >>> result.height, result.width\n    (np.float64(4.0), np.float64(4.0))\n    >>> circle_points = np.array(result.get_anchors())\n    >>> circle_eq = np.sum(circle_points**2, axis=1)\n    >>> np.allclose(circle_eq, 2**2)\n    True\n\nWith ``match_center=True``, the resulting mobject is moved such that\nits center is the same as the center of the original mobject::\n\n    >>> rect = rect.shift(np.array([0, 1, 0]))\n    >>> np.allclose(rect.get_center(), circ.get_center())\n    False\n    >>> result = rect.copy().become(circ, match_center=True)\n    >>> np.allclose(rect.get_center(), result.get_center())\n    True"
        },
        "center": {
          "signature": "center()",
          "summary": "Moves the center of the mobject to the center of the scene.",
          "doc": "Moves the center of the mobject to the center of the scene.\n\nReturns\n-------\n:class:`.Mobject`\n    The centered mobject."
        },
        "change_anchor_mode": {
          "signature": "change_anchor_mode(mode)",
          "summary": "Changes the anchor mode of the bezier curves.",
          "doc": "Changes the anchor mode of the bezier curves. This will modify the handles.\n\nThere can be only two modes, \"jagged\", and \"smooth\".\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "clear_points": {
          "signature": "clear_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "clear_updaters": {
          "signature": "clear_updaters(recursive=True)",
          "summary": "Remove every updater.",
          "doc": "Remove every updater.\n\nParameters\n----------\nrecursive\n    Whether to recursively call ``clear_updaters`` on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`remove_updater`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "close_path": {
          "signature": "close_path()",
          "summary": "No documentation available.",
          "doc": null
        },
        "color_using_background_image": {
          "signature": "color_using_background_image(background_image)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals": {
          "signature": "consider_points_equals(p0, p1)",
          "summary": "No documentation available.",
          "doc": null
        },
        "consider_points_equals_2d": {
          "signature": "consider_points_equals_2d(p0, p1)",
          "summary": "Determine if two points are close enough to be considered equal.",
          "doc": "Determine if two points are close enough to be considered equal.\n\nThis uses the algorithm from np.isclose(), but expanded here for the\n2D point case. NumPy is overkill for such a small question.\nParameters\n----------\np0\n    first point\np1\n    second point\n\nReturns\n-------\nbool\n    whether two points considered close."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create and return an identical copy of the :class:`Mobject` including all",
          "doc": "Create and return an identical copy of the :class:`Mobject` including all\n:attr:`submobjects`.\n\nReturns\n-------\n:class:`Mobject`\n    The copy.\n\nNote\n----\nThe clone is initially not visible in the Scene, even if the original was."
        },
        "ellipse_to_mobject": {
          "signature": "ellipse_to_mobject(ellipse)",
          "summary": "Convert an ellipse or circle element to a vectorized mobject.",
          "doc": "Convert an ellipse or circle element to a vectorized mobject.\n\nParameters\n----------\nellipse\n    The parsed SVG ellipse or circle."
        },
        "fade": {
          "signature": "fade(darkness=0.5, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "fade_to": {
          "signature": "fade_to(color, alpha, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "family_members_with_points": {
          "signature": "family_members_with_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "flip": {
          "signature": "flip(axis=[0. 1. 0.], kwargs)",
          "summary": "Flips/Mirrors an mobject about its center.",
          "doc": "Flips/Mirrors an mobject about its center.\n\nExamples\n--------\n\n.. manim:: FlipExample\n    :save_last_frame:\n\n    class FlipExample(Scene):\n        def construct(self):\n            s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n            self.add(s)\n            s2= s.copy().flip()\n            self.add(s2)"
        },
        "force_direction": {
          "signature": "force_direction(target_direction)",
          "summary": "Makes sure that points are either directed clockwise or",
          "doc": "Makes sure that points are either directed clockwise or\ncounterclockwise.\n\nParameters\n----------\ntarget_direction\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "gen_cubic_bezier_tuples_from_points": {
          "signature": "gen_cubic_bezier_tuples_from_points(points)",
          "summary": "Returns the bezier tuples from an array of points.",
          "doc": "Returns the bezier tuples from an array of points.\n\nself.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])\nThis algorithm basically retrieve them by taking an element every n, where n is the number of control points\nof the bezier curve.\n\n\nParameters\n----------\npoints\n    Points from which control points will be extracted.\n\nReturns\n-------\ntuple\n    Bezier control points."
        },
        "gen_subpaths_from_points_2d": {
          "signature": "gen_subpaths_from_points_2d(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "generate_config_style_dict": {
          "signature": "generate_config_style_dict()",
          "summary": "Generate a dictionary holding the default style information.",
          "doc": "Generate a dictionary holding the default style information."
        },
        "generate_mobject": {
          "signature": "generate_mobject()",
          "summary": "Parse the SVG and translate its elements to submobjects.",
          "doc": "Parse the SVG and translate its elements to submobjects."
        },
        "generate_points": {
          "signature": "generate_points()",
          "summary": "Initializes :attr:`points` and therefore the shape.",
          "doc": "Initializes :attr:`points` and therefore the shape.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "generate_rgbas_array": {
          "signature": "generate_rgbas_array(color, opacity)",
          "summary": "First arg can be either a color, or a tuple/list of colors.",
          "doc": "First arg can be either a color, or a tuple/list of colors.\nLikewise, opacity can either be a float, or a tuple of floats.\nIf self.sheen_factor is not zero, and only\none color was passed in, a second slightly light color\nwill automatically be added for the gradient"
        },
        "generate_target": {
          "signature": "generate_target(use_deepcopy=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_points": {
          "signature": "get_all_points()",
          "summary": "Return all points from this mobject and all submobjects.",
          "doc": "Return all points from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_anchors": {
          "signature": "get_anchors()",
          "summary": "Returns the anchors of the curves forming the VMobject.",
          "doc": "Returns the anchors of the curves forming the VMobject.\n\nReturns\n-------\nPoint3D_Array\n    The anchors."
        },
        "get_anchors_and_handles": {
          "signature": "get_anchors_and_handles()",
          "summary": "Returns anchors1, handles1, handles2, anchors2,",
          "doc": "Returns anchors1, handles1, handles2, anchors2,\nwhere (anchors1[i], handles1[i], handles2[i], anchors2[i])\nwill be four points defining a cubic bezier curve\nfor any i in range(0, len(anchors1))\n\nReturns\n-------\n`list[Point3D_Array]`\n    Iterable of the anchors and handles."
        },
        "get_arc_length": {
          "signature": "get_arc_length(sample_points_per_curve=None)",
          "summary": "Return the approximated length of the whole curve.",
          "doc": "Return the approximated length of the whole curve.\n\nParameters\n----------\nsample_points_per_curve\n    Number of sample points per curve used to approximate the length. More points result in a better approximation.\n\nReturns\n-------\nfloat\n    The length of the :class:`VMobject`."
        },
        "get_array_attrs": {
          "signature": "get_array_attrs()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_background_image": {
          "signature": "get_background_image()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_bottom": {
          "signature": "get_bottom()",
          "summary": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get bottom Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_boundary_point": {
          "signature": "get_boundary_point(direction)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_center": {
          "signature": "get_center()",
          "summary": "Get center Point3Ds",
          "doc": "Get center Point3Ds"
        },
        "get_center_of_mass": {
          "signature": "get_center_of_mass()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_color": {
          "signature": "get_color()",
          "summary": "Returns the color of the :class:`~.Mobject` Examples",
          "doc": "Returns the color of the :class:`~.Mobject`\n\nExamples\n--------\n::\n\n    >>> from manim import Square, RED\n    >>> Square(color=RED).get_color() == RED\n    True"
        },
        "get_coord": {
          "signature": "get_coord(dim, direction=[0. 0. 0.])",
          "summary": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``",
          "doc": "Meant to generalize ``get_x``, ``get_y`` and ``get_z``"
        },
        "get_corner": {
          "signature": "get_corner(direction)",
          "summary": "Get corner Point3Ds for certain direction.",
          "doc": "Get corner Point3Ds for certain direction."
        },
        "get_critical_point": {
          "signature": "get_critical_point(direction)",
          "summary": "Picture a box bounding the :class:`~.Mobject`.",
          "doc": "Picture a box bounding the :class:`~.Mobject`.  Such a box has\n9 'critical points': 4 corners, 4 edge center, the\ncenter. This returns one of them, along the given direction.\n\n::\n\n    sample = Arc(start_angle=PI / 7, angle=PI / 5)\n\n    # These are all equivalent\n    max_y_1 = sample.get_top()[1]\n    max_y_2 = sample.get_critical_point(UP)[1]\n    max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)"
        },
        "get_cubic_bezier_tuples": {
          "signature": "get_cubic_bezier_tuples()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_cubic_bezier_tuples_from_points": {
          "signature": "get_cubic_bezier_tuples_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_curve_functions": {
          "signature": "get_curve_functions()",
          "summary": "Gets the functions for the curves of the mobject.",
          "doc": "Gets the functions for the curves of the mobject.\n\nReturns\n-------\nIterable[Callable[[float], Point3D]]\n    The functions for the curves."
        },
        "get_curve_functions_with_lengths": {
          "signature": "get_curve_functions_with_lengths(kwargs)",
          "summary": "Gets the functions and lengths of the curves for the mobject.",
          "doc": "Gets the functions and lengths of the curves for the mobject.\n\nParameters\n----------\n**kwargs\n    The keyword arguments passed to :meth:`get_nth_curve_function_with_length`\n\nReturns\n-------\nIterable[tuple[Callable[[float], Point3D], float]]\n    The functions and lengths of the curves."
        },
        "get_direction": {
          "signature": "get_direction()",
          "summary": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.",
          "doc": "Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.\nThe direction of points determines in which direction the\nobject is drawn, clockwise or counterclockwise.\n\nExamples\n--------\nThe default direction of a :class:`~.Circle` is counterclockwise::\n\n    >>> from manim import Circle\n    >>> Circle().get_direction()\n    'CCW'\n\nReturns\n-------\n:class:`str`\n    Either ``\"CW\"`` or ``\"CCW\"``."
        },
        "get_edge_center": {
          "signature": "get_edge_center(direction)",
          "summary": "Get edge Point3Ds for certain direction.",
          "doc": "Get edge Point3Ds for certain direction."
        },
        "get_end": {
          "signature": "get_end()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends."
        },
        "get_end_anchors": {
          "signature": "get_end_anchors()",
          "summary": "Return the end anchors of the bezier curves.",
          "doc": "Return the end anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_extremum_along_dim": {
          "signature": "get_extremum_along_dim(points=None, dim=0, key=0)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family": {
          "signature": "get_family(recurse=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_family_updaters": {
          "signature": "get_family_updaters()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_file_path": {
          "signature": "get_file_path()",
          "summary": "Search for an existing file based on the specified file name.",
          "doc": "Search for an existing file based on the specified file name."
        },
        "get_fill_color": {
          "signature": "get_fill_color()",
          "summary": "If there are multiple colors (for gradient)",
          "doc": "If there are multiple colors (for gradient)\nthis returns the first one"
        },
        "get_fill_colors": {
          "signature": "get_fill_colors()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacities": {
          "signature": "get_fill_opacities()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_fill_opacity": {
          "signature": "get_fill_opacity()",
          "summary": "If there are multiple opacities, this returns the",
          "doc": "If there are multiple opacities, this returns the\nfirst"
        },
        "get_fill_rgbas": {
          "signature": "get_fill_rgbas()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_gradient_start_and_end_points": {
          "signature": "get_gradient_start_and_end_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_group_class": {
          "signature": "get_group_class()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_image": {
          "signature": "get_image(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_last_point": {
          "signature": "get_last_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_left": {
          "signature": "get_left()",
          "summary": "Get left Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get left Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_merged_array": {
          "signature": "get_merged_array(array_attr)",
          "summary": "Return all of a given attribute from this mobject and all submobjects.",
          "doc": "Return all of a given attribute from this mobject and all submobjects.\n\nMay contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects."
        },
        "get_midpoint": {
          "signature": "get_midpoint()",
          "summary": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.",
          "doc": "Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.\n\nExamples\n--------\n\n.. manim:: AngleMidPoint\n    :save_last_frame:\n\n    class AngleMidPoint(Scene):\n        def construct(self):\n            line1 = Line(ORIGIN, 2*RIGHT)\n            line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n            a = Angle(line1, line2, radius=1.5, other_angle=False)\n            d = Dot(a.get_midpoint()).set_color(RED)\n\n            self.add(line1, line2, a, d)\n            self.wait()"
        },
        "get_mobject_type_class": {
          "signature": "get_mobject_type_class()",
          "summary": "Return the base class of this mobject type.",
          "doc": "Return the base class of this mobject type."
        },
        "get_mobjects_from": {
          "signature": "get_mobjects_from(svg)",
          "summary": "Convert the elements of the SVG to a list of mobjects.",
          "doc": "Convert the elements of the SVG to a list of mobjects.\n\nParameters\n----------\nsvg\n    The parsed SVG file."
        },
        "get_nadir": {
          "signature": "get_nadir()",
          "summary": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "get_nth_curve_function": {
          "signature": "get_nth_curve_function(n)",
          "summary": "Returns the expression of the nth curve.",
          "doc": "Returns the expression of the nth curve.\n\nParameters\n----------\nn\n    index of the desired curve.\n\nReturns\n-------\nCallable[float, Point3D]\n    expression of the nth bezier curve."
        },
        "get_nth_curve_function_with_length": {
          "signature": "get_nth_curve_function_with_length(n, sample_points=None)",
          "summary": "Returns the expression of the nth curve along with its (approximate) length.",
          "doc": "Returns the expression of the nth curve along with its (approximate) length.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\ncurve : Callable[[float], Point3D]\n    The function for the nth curve.\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length": {
          "signature": "get_nth_curve_length(n, sample_points=None)",
          "summary": "Returns the (approximate) length of the nth curve.",
          "doc": "Returns the (approximate) length of the nth curve.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\nlength : :class:`float`\n    The length of the nth curve."
        },
        "get_nth_curve_length_pieces": {
          "signature": "get_nth_curve_length_pieces(n, sample_points=None)",
          "summary": "Returns the array of short line lengths used for length approximation.",
          "doc": "Returns the array of short line lengths used for length approximation.\n\nParameters\n----------\nn\n    The index of the desired curve.\nsample_points\n    The number of points to sample to find the length.\n\nReturns\n-------\n    The short length-pieces of the nth curve."
        },
        "get_nth_curve_points": {
          "signature": "get_nth_curve_points(n)",
          "summary": "Returns the points defining the nth curve of the vmobject.",
          "doc": "Returns the points defining the nth curve of the vmobject.\n\nParameters\n----------\nn\n    index of the desired bezier curve.\n\nReturns\n-------\nCubicBezierPoints\n    points defining the nth bezier curve (anchors, handles)"
        },
        "get_num_curves": {
          "signature": "get_num_curves()",
          "summary": "Returns the number of curves of the vmobject.",
          "doc": "Returns the number of curves of the vmobject.\n\nReturns\n-------\nint\n    number of curves of the vmobject."
        },
        "get_num_points": {
          "signature": "get_num_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_part_by_tex": {
          "signature": "get_part_by_tex(tex, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_parts_by_tex": {
          "signature": "get_parts_by_tex(tex, substring=True, case_sensitive=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_pieces": {
          "signature": "get_pieces(n_pieces)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_point_mobject": {
          "signature": "get_point_mobject(center=None)",
          "summary": "The simplest :class:`~.Mobject` to be transformed to or from self.",
          "doc": "The simplest :class:`~.Mobject` to be transformed to or from self.\nShould by a point of the appropriate type"
        },
        "get_points_defining_boundary": {
          "signature": "get_points_defining_boundary()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_right": {
          "signature": "get_right()",
          "summary": "Get right Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get right Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_sheen_direction": {
          "signature": "get_sheen_direction()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_sheen_factor": {
          "signature": "get_sheen_factor()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_start": {
          "signature": "get_start()",
          "summary": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts.",
          "doc": "Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts."
        },
        "get_start_anchors": {
          "signature": "get_start_anchors()",
          "summary": "Returns the start anchors of the bezier curves.",
          "doc": "Returns the start anchors of the bezier curves.\n\nReturns\n-------\nPoint3D_Array\n    Starting anchors"
        },
        "get_start_and_end": {
          "signature": "get_start_and_end()",
          "summary": "Returns starting and ending point of a stroke as a ``tuple``.",
          "doc": "Returns starting and ending point of a stroke as a ``tuple``."
        },
        "get_stroke_color": {
          "signature": "get_stroke_color(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_colors": {
          "signature": "get_stroke_colors(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacities": {
          "signature": "get_stroke_opacities(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_opacity": {
          "signature": "get_stroke_opacity(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_rgbas": {
          "signature": "get_stroke_rgbas(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_stroke_width": {
          "signature": "get_stroke_width(background=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_style": {
          "signature": "get_style(simple=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_subcurve": {
          "signature": "get_subcurve(a, b)",
          "summary": "Returns the subcurve of the VMobject between the interval [a, b].",
          "doc": "Returns the subcurve of the VMobject between the interval [a, b].\nThe curve is a VMobject itself.\n\nParameters\n----------\n\na\n    The lower bound.\nb\n    The upper bound.\n\nReturns\n-------\nVMobject\n    The subcurve between of [a, b]"
        },
        "get_subpaths": {
          "signature": "get_subpaths()",
          "summary": "Returns subpaths formed by the curves of the VMobject.",
          "doc": "Returns subpaths formed by the curves of the VMobject.\n\nSubpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.\n\nReturns\n-------\nlist[CubicSpline]\n    subpaths."
        },
        "get_subpaths_from_points": {
          "signature": "get_subpaths_from_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_tex_string": {
          "signature": "get_tex_string()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_time_based_updaters": {
          "signature": "get_time_based_updaters()",
          "summary": "Return all updaters using the ``dt`` parameter.",
          "doc": "Return all updaters using the ``dt`` parameter.\n\nThe updaters use this parameter as the input for difference in time.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of time based updaters.\n\nSee Also\n--------\n:meth:`get_updaters`\n:meth:`has_time_based_updater`"
        },
        "get_top": {
          "signature": "get_top()",
          "summary": "Get top Point3Ds of a box bounding the :class:`~.Mobject`",
          "doc": "Get top Point3Ds of a box bounding the :class:`~.Mobject`"
        },
        "get_updaters": {
          "signature": "get_updaters()",
          "summary": "Return all updaters.",
          "doc": "Return all updaters.\n\nReturns\n-------\nList[:class:`Callable`]\n    The list of updaters.\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_time_based_updaters`"
        },
        "get_x": {
          "signature": "get_x(direction=[0. 0. 0.])",
          "summary": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns x Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_y": {
          "signature": "get_y(direction=[0. 0. 0.])",
          "summary": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns y Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z": {
          "signature": "get_z(direction=[0. 0. 0.])",
          "summary": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``",
          "doc": "Returns z Point3D of the center of the :class:`~.Mobject` as ``float``"
        },
        "get_z_index_reference_point": {
          "signature": "get_z_index_reference_point()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_zenith": {
          "signature": "get_zenith()",
          "summary": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`.",
          "doc": "Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`."
        },
        "handle_transform": {
          "signature": "handle_transform(mob, matrix)",
          "summary": "Apply SVG transformations to the converted mobject.",
          "doc": "Apply SVG transformations to the converted mobject.\n\nParameters\n----------\nmob\n    The converted mobject.\nmatrix\n    The transformation matrix determined from the SVG\n    transformation."
        },
        "has_new_path_started": {
          "signature": "has_new_path_started()",
          "summary": "No documentation available.",
          "doc": null
        },
        "has_no_points": {
          "signature": "has_no_points()",
          "summary": "Check if :class:`~.Mobject` *does not* contains points.",
          "doc": "Check if :class:`~.Mobject` *does not* contains points."
        },
        "has_points": {
          "signature": "has_points()",
          "summary": "Check if :class:`~.Mobject` contains points.",
          "doc": "Check if :class:`~.Mobject` contains points."
        },
        "has_time_based_updater": {
          "signature": "has_time_based_updater()",
          "summary": "Test if ``self`` has a time based updater.",
          "doc": "Test if ``self`` has a time based updater.\n\nReturns\n-------\n:class:`bool`\n    ``True`` if at least one updater uses the ``dt`` parameter, ``False``\n    otherwise.\n\nSee Also\n--------\n:meth:`get_time_based_updaters`"
        },
        "index_of_part": {
          "signature": "index_of_part(part)",
          "summary": "No documentation available.",
          "doc": null
        },
        "index_of_part_by_tex": {
          "signature": "index_of_part_by_tex(tex, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "init_colors": {
          "signature": "init_colors(propagate_colors=True)",
          "summary": "Initializes the colors.",
          "doc": "Initializes the colors.\n\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses."
        },
        "init_svg_mobject": {
          "signature": "init_svg_mobject(use_svg_cache)",
          "summary": "Checks whether the SVG has already been imported and",
          "doc": "Checks whether the SVG has already been imported and\ngenerates it if not.\n\nSee also\n--------\n:meth:`.SVGMobject.generate_mobject`"
        },
        "insert": {
          "signature": "insert(index, mobject)",
          "summary": "Inserts a mobject at a specific position into self.submobjects Effectively just calls  ``self.submobjects.insert(index, mobject)``,",
          "doc": "Inserts a mobject at a specific position into self.submobjects\n\nEffectively just calls  ``self.submobjects.insert(index, mobject)``,\nwhere ``self.submobjects`` is a list.\n\nHighly adapted from ``Mobject.add``.\n\nParameters\n----------\nindex\n    The index at which\nmobject\n    The mobject to be inserted."
        },
        "insert_n_curves": {
          "signature": "insert_n_curves(n)",
          "summary": "Inserts n curves to the bezier curves of the vmobject.",
          "doc": "Inserts n curves to the bezier curves of the vmobject.\n\nParameters\n----------\nn\n    Number of curves to insert.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "insert_n_curves_to_point_list": {
          "signature": "insert_n_curves_to_point_list(n, points)",
          "summary": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.",
          "doc": "Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.\n\nParameters\n----------\nn\n    Number of desired curves.\npoints\n    Starting points.\n\nReturns\n-------\n    Points generated."
        },
        "interpolate": {
          "signature": "interpolate(mobject1, mobject2, alpha, path_func=<function interpolate at 0x109973f60>)",
          "summary": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``",
          "doc": "Turns this :class:`~.Mobject` into an interpolation between ``mobject1``\nand ``mobject2``.\n\nExamples\n--------\n\n.. manim:: DotInterpolation\n    :save_last_frame:\n\n    class DotInterpolation(Scene):\n        def construct(self):\n            dotR = Dot(color=DARK_GREY)\n            dotR.shift(2 * RIGHT)\n            dotL = Dot(color=WHITE)\n            dotL.shift(2 * LEFT)\n\n            dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n            self.add(dotL, dotR, dotMiddle)"
        },
        "interpolate_color": {
          "signature": "interpolate_color(mobject1, mobject2, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "invert": {
          "signature": "invert(recursive=False)",
          "summary": "Inverts the list of :attr:`submobjects`.",
          "doc": "Inverts the list of :attr:`submobjects`.\n\nParameters\n----------\nrecursive\n    If ``True``, all submobject lists of this mobject's family are inverted.\n\nExamples\n--------\n\n.. manim:: InvertSumobjectsExample\n\n    class InvertSumobjectsExample(Scene):\n        def construct(self):\n            s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2 = s.copy()\n            s2.invert()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "is_closed": {
          "signature": "is_closed()",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_off_screen": {
          "signature": "is_off_screen()",
          "summary": "No documentation available.",
          "doc": null
        },
        "length_over_dim": {
          "signature": "length_over_dim(dim)",
          "summary": "Measure the length of an :class:`~.Mobject` in a certain direction.",
          "doc": "Measure the length of an :class:`~.Mobject` in a certain direction."
        },
        "line_to_mobject": {
          "signature": "line_to_mobject(line)",
          "summary": "Convert a line element to a vectorized mobject.",
          "doc": "Convert a line element to a vectorized mobject.\n\nParameters\n----------\nline\n    The parsed SVG line."
        },
        "make_jagged": {
          "signature": "make_jagged()",
          "summary": "No documentation available.",
          "doc": null
        },
        "make_smooth": {
          "signature": "make_smooth()",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_background_image": {
          "signature": "match_background_image(vmobject)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_color": {
          "signature": "match_color(mobject)",
          "summary": "Match the color with the color of another :class:`~.Mobject`.",
          "doc": "Match the color with the color of another :class:`~.Mobject`."
        },
        "match_coord": {
          "signature": "match_coord(mobject, dim, direction=[0. 0. 0.])",
          "summary": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`.",
          "doc": "Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`."
        },
        "match_depth": {
          "signature": "match_depth(mobject, kwargs)",
          "summary": "Match the depth with the depth of another :class:`~.Mobject`.",
          "doc": "Match the depth with the depth of another :class:`~.Mobject`."
        },
        "match_dim_size": {
          "signature": "match_dim_size(mobject, dim, kwargs)",
          "summary": "Match the specified dimension with the dimension of another :class:`~.Mobject`.",
          "doc": "Match the specified dimension with the dimension of another :class:`~.Mobject`."
        },
        "match_height": {
          "signature": "match_height(mobject, kwargs)",
          "summary": "Match the height with the height of another :class:`~.Mobject`.",
          "doc": "Match the height with the height of another :class:`~.Mobject`."
        },
        "match_points": {
          "signature": "match_points(mobject, copy_submobjects=True)",
          "summary": "Edit points, positions, and submobjects to be identical",
          "doc": "Edit points, positions, and submobjects to be identical\nto another :class:`~.Mobject`, while keeping the style unchanged.\n\nExamples\n--------\n.. manim:: MatchPointsScene\n\n    class MatchPointsScene(Scene):\n        def construct(self):\n            circ = Circle(fill_color=RED, fill_opacity=0.8)\n            square = Square(fill_color=BLUE, fill_opacity=0.2)\n            self.add(circ)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)"
        },
        "match_style": {
          "signature": "match_style(vmobject, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "match_updaters": {
          "signature": "match_updaters(mobject)",
          "summary": "Match the updaters of the given mobject.",
          "doc": "Match the updaters of the given mobject.\n\nParameters\n----------\nmobject\n    The mobject whose updaters get matched.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nNote\n----\nAll updaters from submobjects are removed, but only updaters of the given\nmobject are matched, not those of it's submobjects.\n\nSee also\n--------\n:meth:`add_updater`\n:meth:`clear_updaters`"
        },
        "match_width": {
          "signature": "match_width(mobject, kwargs)",
          "summary": "Match the width with the width of another :class:`~.Mobject`.",
          "doc": "Match the width with the width of another :class:`~.Mobject`."
        },
        "match_x": {
          "signature": "match_x(mobject, direction=[0. 0. 0.])",
          "summary": "Match x coord.",
          "doc": "Match x coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_y": {
          "signature": "match_y(mobject, direction=[0. 0. 0.])",
          "summary": "Match y coord.",
          "doc": "Match y coord. to the x coord. of another :class:`~.Mobject`."
        },
        "match_z": {
          "signature": "match_z(mobject, direction=[0. 0. 0.])",
          "summary": "Match z coord.",
          "doc": "Match z coord. to the x coord. of another :class:`~.Mobject`."
        },
        "modify_xml_tree": {
          "signature": "modify_xml_tree(element_tree)",
          "summary": "Modifies the SVG element tree to include default",
          "doc": "Modifies the SVG element tree to include default\nstyle information.\n\nParameters\n----------\nelement_tree\n    The parsed element tree from the SVG file."
        },
        "move_into_position": {
          "signature": "move_into_position()",
          "summary": "Scale and move the generated mobject into position.",
          "doc": "Scale and move the generated mobject into position."
        },
        "move_to": {
          "signature": "move_to(point_or_mobject, aligned_edge=[0. 0. 0.], coor_mask=[1 1 1])",
          "summary": "Move center of the :class:`~.Mobject` to certain Point3D.",
          "doc": "Move center of the :class:`~.Mobject` to certain Point3D."
        },
        "next_to": {
          "signature": "next_to(mobject_or_point, direction=[1. 0. 0.], buff=0.25, aligned_edge=[0. 0. 0.], submobject_to_align=None, index_of_submobject_to_align=None, coor_mask=[1 1 1])",
          "summary": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.",
          "doc": "Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.\n\nExamples\n--------\n\n.. manim:: GeometricShapes\n    :save_last_frame:\n\n    class GeometricShapes(Scene):\n        def construct(self):\n            d = Dot()\n            c = Circle()\n            s = Square()\n            t = Triangle()\n            d.next_to(c, RIGHT)\n            s.next_to(c, LEFT)\n            t.next_to(c, DOWN)\n            self.add(d, c, s, t)"
        },
        "nonempty_submobjects": {
          "signature": "nonempty_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "null_point_align": {
          "signature": "null_point_align(mobject)",
          "summary": "If a :class:`~.Mobject` with points is being aligned to",
          "doc": "If a :class:`~.Mobject` with points is being aligned to\none without, treat both as groups, and push\nthe one with points into its own submobjects\nlist.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``"
        },
        "path_to_mobject": {
          "signature": "path_to_mobject(path)",
          "summary": "Convert a path element to a vectorized mobject.",
          "doc": "Convert a path element to a vectorized mobject.\n\nParameters\n----------\npath\n    The parsed SVG path."
        },
        "point_from_proportion": {
          "signature": "point_from_proportion(alpha)",
          "summary": "Gets the point at a proportion along the path of the :class:`VMobject`.",
          "doc": "Gets the point at a proportion along the path of the :class:`VMobject`.\n\nParameters\n----------\nalpha\n    The proportion along the the path of the :class:`VMobject`.\n\nReturns\n-------\n:class:`numpy.ndarray`\n    The point on the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``alpha`` is not between 0 and 1.\n:exc:`Exception`\n    If the :class:`VMobject` has no points.\n\nExample\n-------\n.. manim:: PointFromProportion\n    :save_last_frame:\n\n    class PointFromProportion(Scene):\n        def construct(self):\n            line = Line(2*DL, 2*UR)\n            self.add(line)\n            colors = (RED, BLUE, YELLOW)\n            proportions = (1/4, 1/2, 3/4)\n            for color, proportion in zip(colors, proportions):\n                self.add(Dot(color=color).move_to(\n                        line.point_from_proportion(proportion)\n                ))"
        },
        "pointwise_become_partial": {
          "signature": "pointwise_become_partial(vmobject, a, b)",
          "summary": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and",
          "doc": "Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and\nan upper bound ``b``, modify this :class:`.VMobject`'s points to\nmatch the portion of the B\u00e9zier spline described by ``vmobject.points``\nwith the parameter ``t`` between ``a`` and ``b``.\n\nParameters\n----------\nvmobject\n    The :class:`.VMobject` that will serve as a model.\na\n    The lower bound for ``t``.\nb\n    The upper bound for ``t``\n\nReturns\n-------\n:class:`.VMobject`\n    The :class:`.VMobject` itself, after the transformation.\n\nRaises\n------\nTypeError\n    If ``vmobject`` is not an instance of :class:`VMobject`."
        },
        "polygon_to_mobject": {
          "signature": "polygon_to_mobject(polygon)",
          "summary": "Convert a polygon element to a vectorized mobject.",
          "doc": "Convert a polygon element to a vectorized mobject.\n\nParameters\n----------\npolygon\n    The parsed SVG polygon."
        },
        "polyline_to_mobject": {
          "signature": "polyline_to_mobject(polyline)",
          "summary": "Convert a polyline element to a vectorized mobject.",
          "doc": "Convert a polyline element to a vectorized mobject.\n\nParameters\n----------\npolyline\n    The parsed SVG polyline."
        },
        "pose_at_angle": {
          "signature": "pose_at_angle(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "proportion_from_point": {
          "signature": "proportion_from_point(point)",
          "summary": "Returns the proportion along the path of the :class:`VMobject`",
          "doc": "Returns the proportion along the path of the :class:`VMobject`\na particular given point is at.\n\nParameters\n----------\npoint\n    The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`\n\nReturns\n-------\nfloat\n    The proportion along the path of the :class:`VMobject`.\n\nRaises\n------\n:exc:`ValueError`\n    If ``point`` does not lie on the curve.\n:exc:`Exception`\n    If the :class:`VMobject` has no points."
        },
        "push_self_into_submobjects": {
          "signature": "push_self_into_submobjects()",
          "summary": "No documentation available.",
          "doc": null
        },
        "put_start_and_end_on": {
          "signature": "put_start_and_end_on(start, end)",
          "summary": "No documentation available.",
          "doc": null
        },
        "rect_to_mobject": {
          "signature": "rect_to_mobject(rect)",
          "summary": "Convert a rectangle element to a vectorized mobject.",
          "doc": "Convert a rectangle element to a vectorized mobject.\n\nParameters\n----------\nrect\n    The parsed SVG rectangle."
        },
        "reduce_across_dimension": {
          "signature": "reduce_across_dimension(reduce_func, dim)",
          "summary": "Find the min or max value from a dimension across all points in this and submobjects.",
          "doc": "Find the min or max value from a dimension across all points in this and submobjects."
        },
        "remove": {
          "signature": "remove(mobjects)",
          "summary": "Remove :attr:`submobjects`.",
          "doc": "Remove :attr:`submobjects`.\n\nThe mobjects are removed from :attr:`submobjects`, if they exist.\n\nSubclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\nParameters\n----------\nmobjects\n    The mobjects to remove.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add`"
        },
        "remove_updater": {
          "signature": "remove_updater(update_function)",
          "summary": "Remove an updater.",
          "doc": "Remove an updater.\n\nIf the same updater is applied multiple times, every instance gets removed.\n\nParameters\n----------\nupdate_function\n    The update function to be removed.\n\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`clear_updaters`\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "repeat": {
          "signature": "repeat(count)",
          "summary": "This can make transition animations nicer",
          "doc": "This can make transition animations nicer"
        },
        "repeat_submobject": {
          "signature": "repeat_submobject(submob)",
          "summary": "No documentation available.",
          "doc": null
        },
        "replace": {
          "signature": "replace(mobject, dim_to_match=0, stretch=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "rescale_to_fit": {
          "signature": "rescale_to_fit(length, dim, stretch=False, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "reset_points": {
          "signature": "reset_points()",
          "summary": "Sets :attr:`points` to be an empty array.",
          "doc": "Sets :attr:`points` to be an empty array."
        },
        "resize_points": {
          "signature": "resize_points(new_length, resize_func=<function resize_array at 0x1056ab380>)",
          "summary": "Resize the array of anchor points and handles to have",
          "doc": "Resize the array of anchor points and handles to have\nthe specified size.\n\nParameters\n----------\nnew_length\n    The new (total) number of points.\nresize_func\n    A function mapping a Numpy array (the points) and an integer\n    (the target size) to a Numpy array. The default implementation\n    is based on Numpy's ``resize`` function."
        },
        "restore": {
          "signature": "restore()",
          "summary": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`.",
          "doc": "Restores the state that was previously saved with :meth:`~.Mobject.save_state`."
        },
        "resume_updating": {
          "signature": "resume_updating(recursive=True)",
          "summary": "Enable updating from updaters and animations.",
          "doc": "Enable updating from updaters and animations.\n\nParameters\n----------\nrecursive\n    Whether to recursively enable updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`suspend_updating`\n:meth:`add_updater`"
        },
        "reverse_direction": {
          "signature": "reverse_direction()",
          "summary": "Reverts the point direction by inverting the point order.",
          "doc": "Reverts the point direction by inverting the point order.\n\nReturns\n-------\n:class:`VMobject`\n    Returns self.\n\nExamples\n--------\n.. manim:: ChangeOfDirection\n\n    class ChangeOfDirection(Scene):\n        def construct(self):\n            ccw = RegularPolygon(5)\n            ccw.shift(LEFT)\n            cw = RegularPolygon(5)\n            cw.shift(RIGHT).reverse_direction()\n\n            self.play(Create(ccw), Create(cw),\n            run_time=4)"
        },
        "reverse_points": {
          "signature": "reverse_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "rotate": {
          "signature": "rotate(angle, axis=[0. 0. 1.], about_point=None, kwargs)",
          "summary": "Rotates the :class:`~.Mobject` about a certain point.",
          "doc": "Rotates the :class:`~.Mobject` about a certain point."
        },
        "rotate_about_origin": {
          "signature": "rotate_about_origin(angle, axis=[0. 0. 1.], axes=[])",
          "summary": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0].",
          "doc": "Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0]."
        },
        "rotate_sheen_direction": {
          "signature": "rotate_sheen_direction(angle, axis=[0. 0. 1.], family=True)",
          "summary": "Rotates the direction of the applied sheen.",
          "doc": "Rotates the direction of the applied sheen.\n\nParameters\n----------\nangle\n    Angle by which the direction of sheen is rotated.\naxis\n    Axis of rotation.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen_direction`"
        },
        "save_image": {
          "signature": "save_image(name=None)",
          "summary": "Saves an image of only this :class:`Mobject` at its position to a png",
          "doc": "Saves an image of only this :class:`Mobject` at its position to a png\nfile."
        },
        "save_state": {
          "signature": "save_state()",
          "summary": "Save the current state (position, color & size).",
          "doc": "Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`."
        },
        "scale": {
          "signature": "scale(scale_factor, scale_stroke=False, kwargs)",
          "summary": "Scale the size by a factor.",
          "doc": "Scale the size by a factor.\n\nDefault behavior is to scale about the center of the vmobject.\n\nParameters\n----------\nscale_factor\n    The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n    will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n    if :math:`\\alpha < 0`, the mobject is also flipped.\nscale_stroke\n    Boolean determining if the object's outline is scaled when the object is scaled.\n    If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.\nkwargs\n    Additional keyword arguments passed to\n    :meth:`~.Mobject.scale`.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n\n.. manim:: MobjectScaleExample\n    :save_last_frame:\n\n    class MobjectScaleExample(Scene):\n        def construct(self):\n            c1 = Circle(1, RED).set_x(-1)\n            c2 = Circle(1, GREEN).set_x(1)\n\n            vg = VGroup(c1, c2)\n            vg.set_stroke(width=50)\n            self.add(vg)\n\n            self.play(\n                c1.animate.scale(.25),\n                c2.animate.scale(.25,\n                    scale_stroke=True)\n            )\n\nSee also\n--------\n:meth:`move_to`"
        },
        "scale_handle_to_anchor_distances": {
          "signature": "scale_handle_to_anchor_distances(factor)",
          "summary": "If the distance between a given handle point H and its associated",
          "doc": "If the distance between a given handle point H and its associated\nanchor point A is d, then it changes H to be a distances factor*d\naway from A, but so that the line from A to H doesn't change.\nThis is mostly useful in the context of applying a (differentiable)\nfunction, to preserve tangency properties.  One would pull all the\nhandles closer to their anchors, apply the function then push them out\nagain.\n\nParameters\n----------\nfactor\n    The factor used for scaling.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "scale_to_fit_depth": {
          "signature": "scale_to_fit_depth(depth, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional."
        },
        "scale_to_fit_height": {
          "signature": "scale_to_fit_height(height, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.scale_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(5.0)"
        },
        "scale_to_fit_width": {
          "signature": "scale_to_fit_width(width, kwargs)",
          "summary": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.",
          "doc": "Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.scale_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(5.0)"
        },
        "set": {
          "signature": "set(kwargs)",
          "summary": "Sets attributes.",
          "doc": "Sets attributes.\n\nI.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.\n\nThis is a convenience to be used along with :attr:`animate` to\nanimate setting attributes.\n\nIn addition to this method, there is a compatibility\nlayer that allows ``get_*`` and ``set_*`` methods to\nget and set generic attributes. For instance::\n\n    >>> mob = Mobject()\n    >>> mob.set_foo(0)\n    Mobject\n    >>> mob.get_foo()\n    0\n    >>> mob.foo\n    0\n\nThis compatibility layer does not interfere with any\n``get_*`` or ``set_*`` methods that are explicitly\ndefined.\n\n.. warning::\n\n    This compatibility layer is for backwards compatibility\n    and is not guaranteed to stay around. Where applicable,\n    please prefer getting/setting attributes normally or with\n    the :meth:`set` method.\n\nParameters\n----------\n**kwargs\n    The attributes and corresponding values to set.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> mob = Mobject()\n    >>> mob.set(foo=0)\n    Mobject\n    >>> mob.foo\n    0"
        },
        "set_anchors_and_handles": {
          "signature": "set_anchors_and_handles(anchors1, handles1, handles2, anchors2)",
          "summary": "Given two sets of anchors and handles, process them to set them as anchors",
          "doc": "Given two sets of anchors and handles, process them to set them as anchors\nand handles of the VMobject.\n\nanchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier\ncurve of the vmobject. There are four hardcoded parameters and this is a\nproblem as it makes the number of points per cubic curve unchangeable from 4\n(two anchors and two handles).\n\nReturns\n-------\n:class:`VMobject`\n    ``self``"
        },
        "set_background_stroke": {
          "signature": "set_background_stroke(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_cap_style": {
          "signature": "set_cap_style(cap_style)",
          "summary": "Sets the cap style of the :class:`VMobject`.",
          "doc": "Sets the cap style of the :class:`VMobject`.\n\nParameters\n----------\ncap_style\n    The cap style to be set. See :class:`.CapStyleType` for options.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: CapStyleExample\n    :save_last_frame:\n\n    class CapStyleExample(Scene):\n        def construct(self):\n            line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n            line.set_cap_style(CapStyleType.ROUND)\n            self.add(line)"
        },
        "set_color": {
          "signature": "set_color(color, family=True)",
          "summary": "Condition is function which takes in one arguments, (x, y, z).",
          "doc": "Condition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color"
        },
        "set_color_by_gradient": {
          "signature": "set_color_by_gradient(colors)",
          "summary": "Parameters",
          "doc": "Parameters\n----------\ncolors\n    The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.\n\nself.color = ManimColor.parse(color)\nreturn self"
        },
        "set_color_by_tex": {
          "signature": "set_color_by_tex(tex, color, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_color_by_tex_to_color_map": {
          "signature": "set_color_by_tex_to_color_map(texs_to_color_map, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_colors_by_radial_gradient": {
          "signature": "set_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_coord": {
          "signature": "set_coord(value, dim, direction=[0. 0. 0.])",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_fill": {
          "signature": "set_fill(color=None, opacity=None, family=True)",
          "summary": "Set the fill color and fill opacity of a :class:`VMobject`.",
          "doc": "Set the fill color and fill opacity of a :class:`VMobject`.\n\nParameters\n----------\ncolor\n    Fill color of the :class:`VMobject`.\nopacity\n    Fill opacity of the :class:`VMobject`.\nfamily\n    If ``True``, the fill color of all submobjects is also set.\n\nReturns\n-------\n:class:`VMobject`\n    ``self``\n\nExamples\n--------\n.. manim:: SetFill\n    :save_last_frame:\n\n    class SetFill(Scene):\n        def construct(self):\n            square = Square().scale(2).set_fill(WHITE,1)\n            circle1 = Circle().set_fill(GREEN,0.8)\n            circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n            circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n            group = Group(circle1,circle2,circle3).arrange()\n            self.add(square)\n            self.add(group)\n\nSee Also\n--------\n:meth:`~.VMobject.set_style`"
        },
        "set_opacity": {
          "signature": "set_opacity(opacity, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_opacity_by_tex": {
          "signature": "set_opacity_by_tex(tex, opacity=0.5, remaining_opacity=None, kwargs)",
          "summary": "Sets the opacity of the tex specified.",
          "doc": "Sets the opacity of the tex specified. If 'remaining_opacity' is specified,\nthen the remaining tex will be set to that opacity.\n\nParameters\n----------\ntex\n    The tex to set the opacity of.\nopacity\n    Default 0.5. The opacity to set the tex to\nremaining_opacity\n    Default None. The opacity to set the remaining tex to.\n    If None, then the remaining tex will not be changed"
        },
        "set_points": {
          "signature": "set_points(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_points_as_corners": {
          "signature": "set_points_as_corners(points)",
          "summary": "Given an array of points, set them as corners of the",
          "doc": "Given an array of points, set them as corners of the\n:class:`VMobject`.\n\nTo achieve that, this algorithm sets handles aligned with the anchors\nsuch that the resultant B\u00e9zier curve will be the segment between the\ntwo anchors.\n\nParameters\n----------\npoints\n    Array of points that will be set as corners.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after setting the new points as corners.\n\n\nExamples\n--------\n.. manim:: PointsAsCornersExample\n    :save_last_frame:\n\n    class PointsAsCornersExample(Scene):\n        def construct(self):\n            corners = (\n                # create square\n                UR, UL,\n                DL, DR,\n                UR,\n                # create crosses\n                DL, UL,\n                DR\n            )\n            vmob = VMobject(stroke_color=RED)\n            vmob.set_points_as_corners(corners).scale(2)\n            self.add(vmob)"
        },
        "set_points_smoothly": {
          "signature": "set_points_smoothly(points)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_shade_in_3d": {
          "signature": "set_shade_in_3d(value=True, z_index_as_group=False)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_sheen": {
          "signature": "set_sheen(factor, direction=None, family=True)",
          "summary": "Applies a color gradient from a direction.",
          "doc": "Applies a color gradient from a direction.\n\nParameters\n----------\nfactor\n    The extent of lustre/gradient to apply. If negative, the gradient\n    starts from black, if positive the gradient starts from white and\n    changes to the current color.\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\n.. manim:: SetSheen\n    :save_last_frame:\n\n    class SetSheen(Scene):\n        def construct(self):\n            circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n            self.add(circle)"
        },
        "set_sheen_direction": {
          "signature": "set_sheen_direction(direction, family=True)",
          "summary": "Sets the direction of the applied sheen.",
          "doc": "Sets the direction of the applied sheen.\n\nParameters\n----------\ndirection\n    Direction from where the gradient is applied.\n\nExamples\n--------\nNormal usage::\n\n    Circle().set_sheen_direction(UP)\n\nSee Also\n--------\n:meth:`~.VMobject.set_sheen`\n:meth:`~.VMobject.rotate_sheen_direction`"
        },
        "set_stroke": {
          "signature": "set_stroke(color=None, width=None, opacity=None, background=False, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_style": {
          "signature": "set_style(fill_color=None, fill_opacity=None, stroke_color=None, stroke_width=None, stroke_opacity=None, background_stroke_color=None, background_stroke_width=None, background_stroke_opacity=None, sheen_factor=None, sheen_direction=None, background_image=None, family=True)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_gradient": {
          "signature": "set_submobject_colors_by_gradient(colors)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_submobject_colors_by_radial_gradient": {
          "signature": "set_submobject_colors_by_radial_gradient(center=None, radius=1, inner_color=#FFFFFF, outer_color=#000000)",
          "summary": "No documentation available.",
          "doc": null
        },
        "set_x": {
          "signature": "set_x(x, direction=[0. 0. 0.])",
          "summary": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_y": {
          "signature": "set_y(y, direction=[0. 0. 0.])",
          "summary": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z": {
          "signature": "set_z(z, direction=[0. 0. 0.])",
          "summary": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)",
          "doc": "Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)"
        },
        "set_z_index": {
          "signature": "set_z_index(z_index_value, family=True)",
          "summary": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.",
          "doc": "Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.\n\nParameters\n----------\nz_index_value\n    The new value of :attr:`z_index` set.\nfamily\n    If ``True``, the :attr:`z_index` value of all submobjects is also set.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)\n\nExamples\n--------\n.. manim:: SetZIndex\n    :save_last_frame:\n\n    class SetZIndex(Scene):\n        def construct(self):\n            text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n            square = Square(2, fill_opacity=1).set_z_index(2)\n            tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n            circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n            # Displaying order is now defined by z_index values\n            self.add(text)\n            self.add(square)\n            self.add(tex)\n            self.add(circle)"
        },
        "set_z_index_by_z_Point3D": {
          "signature": "set_z_index_by_z_Point3D()",
          "summary": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.",
          "doc": "Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.\n\nReturns\n-------\n:class:`Mobject`\n    The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)"
        },
        "shift": {
          "signature": "shift(vectors)",
          "summary": "Shift by the given vectors.",
          "doc": "Shift by the given vectors.\n\nParameters\n----------\nvectors\n    Vectors to shift by. If multiple vectors are given, they are added\n    together.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`move_to`"
        },
        "shift_onto_screen": {
          "signature": "shift_onto_screen(kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "show": {
          "signature": "show(camera=None)",
          "summary": "No documentation available.",
          "doc": null
        },
        "shuffle": {
          "signature": "shuffle(recursive=False)",
          "summary": "Shuffles the list of :attr:`submobjects`.",
          "doc": "Shuffles the list of :attr:`submobjects`."
        },
        "shuffle_submobjects": {
          "signature": "shuffle_submobjects(args, kwargs)",
          "summary": "Shuffles the order of :attr:`submobjects` Examples",
          "doc": "Shuffles the order of :attr:`submobjects`\n\nExamples\n--------\n\n.. manim:: ShuffleSubmobjectsExample\n\n    class ShuffleSubmobjectsExample(Scene):\n        def construct(self):\n            s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n            s2= s.copy()\n            s2.shuffle_submobjects()\n            s2.shift(DOWN)\n            self.play(Write(s), Write(s2))"
        },
        "sort": {
          "signature": "sort(point_to_num_func=<function Mobject.<lambda> at 0x10a232660>, submob_func=None)",
          "summary": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.",
          "doc": "Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."
        },
        "sort_alphabetically": {
          "signature": "sort_alphabetically()",
          "summary": "No documentation available.",
          "doc": null
        },
        "sort_submobjects": {
          "signature": "sort_submobjects(args, kwargs)",
          "summary": "Sort the :attr:`submobjects`",
          "doc": "Sort the :attr:`submobjects`"
        },
        "space_out_submobjects": {
          "signature": "space_out_submobjects(factor=1.5, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "split": {
          "signature": "split()",
          "summary": "No documentation available.",
          "doc": null
        },
        "start_new_path": {
          "signature": "start_new_path(point)",
          "summary": "Append a ``point`` to the :attr:`VMobject.points`, which will be the",
          "doc": "Append a ``point`` to the :attr:`VMobject.points`, which will be the\nbeginning of a new B\u00e9zier curve in the path given by the points. If\nthere's an unfinished curve at the end of :attr:`VMobject.points`,\ncomplete it by appending the last B\u00e9zier curve's start anchor as many\ntimes as needed.\n\nParameters\n----------\npoint\n    A 3D point to append to :attr:`VMobject.points`.\n\nReturns\n-------\n:class:`VMobject`\n    The VMobject itself, after appending ``point`` and starting a new\n    curve."
        },
        "stretch": {
          "signature": "stretch(factor, dim, kwargs)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_about_point": {
          "signature": "stretch_about_point(factor, dim, point)",
          "summary": "No documentation available.",
          "doc": null
        },
        "stretch_to_fit_depth": {
          "signature": "stretch_to_fit_depth(depth, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional."
        },
        "stretch_to_fit_height": {
          "signature": "stretch_to_fit_height(height, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.width\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_height(5)\n    Square\n    >>> sq.height\n    np.float64(5.0)\n    >>> sq.width\n    np.float64(2.0)"
        },
        "stretch_to_fit_width": {
          "signature": "stretch_to_fit_width(width, kwargs)",
          "summary": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.",
          "doc": "Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nExamples\n--------\n::\n\n    >>> from manim import *\n    >>> sq = Square()\n    >>> sq.height\n    np.float64(2.0)\n    >>> sq.stretch_to_fit_width(5)\n    Square\n    >>> sq.width\n    np.float64(5.0)\n    >>> sq.height\n    np.float64(2.0)"
        },
        "surround": {
          "signature": "surround(mobject, dim_to_match=0, stretch=False, buff=0.25)",
          "summary": "No documentation available.",
          "doc": null
        },
        "suspend_updating": {
          "signature": "suspend_updating(recursive=True)",
          "summary": "Disable updating from updaters and animations.",
          "doc": "Disable updating from updaters and animations.\n\n\nParameters\n----------\nrecursive\n    Whether to recursively suspend updating on all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee also\n--------\n:meth:`resume_updating`\n:meth:`add_updater`"
        },
        "text_to_mobject": {
          "signature": "text_to_mobject(text)",
          "summary": "Convert a text element to a vectorized mobject.",
          "doc": "Convert a text element to a vectorized mobject.\n\n.. warning::\n\n    Not yet implemented.\n\nParameters\n----------\ntext\n    The parsed SVG text."
        },
        "throw_error_if_no_points": {
          "signature": "throw_error_if_no_points()",
          "summary": "No documentation available.",
          "doc": null
        },
        "to_corner": {
          "signature": "to_corner(corner=[-1. -1.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given corner of the screen.",
          "doc": "Moves this :class:`~.Mobject` to the given corner of the screen.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToCornerExample\n    :save_last_frame:\n\n    class ToCornerExample(Scene):\n        def construct(self):\n            c = Circle()\n            c.to_corner(UR)\n            t = Tex(\"To the corner!\")\n            t2 = MathTex(\"x^3\").shift(DOWN)\n            self.add(c,t,t2)\n            t.to_corner(DL, buff=0)\n            t2.to_corner(UL, buff=1.5)"
        },
        "to_edge": {
          "signature": "to_edge(edge=[-1.  0.  0.], buff=0.5)",
          "summary": "Moves this :class:`~.Mobject` to the given edge of the screen,",
          "doc": "Moves this :class:`~.Mobject` to the given edge of the screen,\nwithout affecting its position in the other dimension.\n\nReturns\n-------\n:class:`.Mobject`\n    The newly positioned mobject.\n\nExamples\n--------\n\n.. manim:: ToEdgeExample\n    :save_last_frame:\n\n    class ToEdgeExample(Scene):\n        def construct(self):\n            tex_top = Tex(\"I am at the top!\")\n            tex_top.to_edge(UP)\n            tex_side = Tex(\"I am moving to the side!\")\n            c = Circle().shift(2*DOWN)\n            self.add(tex_top, tex_side, c)\n            tex_side.to_edge(LEFT)\n            c.to_edge(RIGHT, buff=0)"
        },
        "to_original_color": {
          "signature": "to_original_color()",
          "summary": "No documentation available.",
          "doc": null
        },
        "update": {
          "signature": "update(dt=0, recursive=True)",
          "summary": "Apply all updaters.",
          "doc": "Apply all updaters.\n\nDoes nothing if updating is suspended.\n\nParameters\n----------\ndt\n    The parameter ``dt`` to pass to the update functions. Usually this is the\n    time in seconds since the last call of ``update``.\nrecursive\n    Whether to recursively update all submobjects.\n\nReturns\n-------\n:class:`Mobject`\n    ``self``\n\nSee Also\n--------\n:meth:`add_updater`\n:meth:`get_updaters`"
        },
        "update_rgbas_array": {
          "signature": "update_rgbas_array(array_name, color=None, opacity=None)",
          "summary": "No documentation available.",
          "doc": null
        }
      },
      "doc": "A string compiled with LaTeX in math mode.\n\nExamples\n--------\n.. manim:: Formula\n    :save_last_frame:\n\n    class Formula(Scene):\n        def construct(self):\n            t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")\n            self.add(t)\n\nTests\n-----\nCheck that creating a :class:`~.MathTex` works::\n\n    >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP\n    MathTex('a^2 + b^2 = c^2')\n\nCheck that double brace group splitting works correctly::\n\n    >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP\n    >>> len(t1.submobjects) # doctest: +SKIP\n    5\n    >>> t2 = MathTex(r\"\\frac{1}{a+b\\sqrt{2}}\") # doctest: +SKIP\n    >>> len(t2.submobjects) # doctest: +SKIP\n    1"
    },
    "Animation": {
      "module": "manim.animation.animation",
      "summary": "An animation.",
      "bases": [],
      "methods": {
        "__init__": {
          "signature": "__init__(mobject, lag_ratio=0.0, run_time=1.0, rate_func=<function smooth at 0x10a233ec0>, reverse_rate_function=False, name=None, remover=False, suspend_mobject_updating=True, introducer=False, _on_finish=<function Animation.<lambda> at 0x10a23f4c0>, kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__new__": {
          "signature": "__new__(mobject=None, args, use_override=True, kwargs)",
          "summary": "Create and return a new object.",
          "doc": "Create and return a new object.  See help(type) for accurate signature."
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__str__": {
          "signature": "__str__()",
          "summary": "Return str(self).",
          "doc": "Return str(self)."
        },
        "begin": {
          "signature": "begin()",
          "summary": "Begin the animation.",
          "doc": "Begin the animation.\n\nThis method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod."
        },
        "clean_up_from_scene": {
          "signature": "clean_up_from_scene(scene)",
          "summary": "Clean up the :class:`~.Scene` after finishing the animation.",
          "doc": "Clean up the :class:`~.Scene` after finishing the animation.\n\nThis includes to :meth:`~.Scene.remove` the Animation's\n:class:`~.Mobject` if the animation is a remover.\n\nParameters\n----------\nscene\n    The scene the animation should be cleaned up from."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create a copy of the animation.",
          "doc": "Create a copy of the animation.\n\nReturns\n-------\nAnimation\n    A copy of ``self``"
        },
        "create_starting_mobject": {
          "signature": "create_starting_mobject()",
          "summary": "No documentation available.",
          "doc": null
        },
        "finish": {
          "signature": "finish()",
          "summary": "Finish the animation.",
          "doc": "Finish the animation.\n\nThis method gets called when the animation is over."
        },
        "get_all_families_zipped": {
          "signature": "get_all_families_zipped()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_mobjects": {
          "signature": "get_all_mobjects()",
          "summary": "Get all mobjects involved in the animation.",
          "doc": "Get all mobjects involved in the animation.\n\nOrdering must match the ordering of arguments to interpolate_submobject\n\nReturns\n-------\nSequence[Mobject]\n    The sequence of mobjects."
        },
        "get_all_mobjects_to_update": {
          "signature": "get_all_mobjects_to_update()",
          "summary": "Get all mobjects to be updated during the animation.",
          "doc": "Get all mobjects to be updated during the animation.\n\nReturns\n-------\nList[Mobject]\n    The list of mobjects to be updated during the animation."
        },
        "get_rate_func": {
          "signature": "get_rate_func()",
          "summary": "Get the rate function of the animation.",
          "doc": "Get the rate function of the animation.\n\nReturns\n-------\nCallable[[float], float]\n    The rate function of the animation."
        },
        "get_run_time": {
          "signature": "get_run_time()",
          "summary": "Get the run time of the animation.",
          "doc": "Get the run time of the animation.\n\nReturns\n-------\nfloat\n    The time the animation takes in seconds."
        },
        "get_sub_alpha": {
          "signature": "get_sub_alpha(alpha, index, num_submobjects)",
          "summary": "Get the animation progress of any submobjects subanimation.",
          "doc": "Get the animation progress of any submobjects subanimation.\n\nParameters\n----------\nalpha\n    The overall animation progress\nindex\n    The index of the subanimation.\nnum_submobjects\n    The total count of subanimations.\n\nReturns\n-------\nfloat\n    The progress of the subanimation."
        },
        "interpolate": {
          "signature": "interpolate(alpha)",
          "summary": "Set the animation progress.",
          "doc": "Set the animation progress.\n\nThis method gets called for every frame during an animation.\n\nParameters\n----------\nalpha\n    The relative time to set the animation to, 0 meaning the start, 1 meaning\n    the end."
        },
        "interpolate_mobject": {
          "signature": "interpolate_mobject(alpha)",
          "summary": "Interpolates the mobject of the :class:`Animation` based on alpha value.",
          "doc": "Interpolates the mobject of the :class:`Animation` based on alpha value.\n\nParameters\n----------\nalpha\n    A float between 0 and 1 expressing the ratio to which the animation\n    is completed. For example, alpha-values of 0, 0.5, and 1 correspond\n    to the animation being completed 0%, 50%, and 100%, respectively."
        },
        "interpolate_submobject": {
          "signature": "interpolate_submobject(submobject, starting_submobject, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_introducer": {
          "signature": "is_introducer()",
          "summary": "Test if the animation is an introducer.",
          "doc": "Test if the animation is an introducer.\n\nReturns\n-------\nbool\n    ``True`` if the animation is an introducer, ``False`` otherwise."
        },
        "is_remover": {
          "signature": "is_remover()",
          "summary": "Test if the animation is a remover.",
          "doc": "Test if the animation is a remover.\n\nReturns\n-------\nbool\n    ``True`` if the animation is a remover, ``False`` otherwise."
        },
        "set_name": {
          "signature": "set_name(name)",
          "summary": "Set the name of the animation.",
          "doc": "Set the name of the animation.\n\nParameters\n----------\nname\n    The new name of the animation.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_rate_func": {
          "signature": "set_rate_func(rate_func)",
          "summary": "Set the rate function of the animation.",
          "doc": "Set the rate function of the animation.\n\nParameters\n----------\nrate_func\n    The new function defining the animation progress based on the\n    relative runtime (see :mod:`~.rate_functions`).\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_run_time": {
          "signature": "set_run_time(run_time)",
          "summary": "Set the run time of the animation.",
          "doc": "Set the run time of the animation.\n\nParameters\n----------\nrun_time\n    The new time the animation should take in seconds.\n\n.. note::\n\n    The run_time of an animation should not be changed while it is already\n    running.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "update_mobjects": {
          "signature": "update_mobjects(dt)",
          "summary": "Updates things like starting_mobject, and (for",
          "doc": "Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject."
        }
      },
      "doc": "An animation.\n\nAnimations have a fixed time span.\n\nParameters\n----------\nmobject\n    The mobject to be animated. This is not required for all types of animations.\nlag_ratio\n    Defines the delay after which the animation is applied to submobjects. This lag\n    is relative to the duration of the animation.\n\n    This does not influence the total\n    runtime of the animation. Instead the runtime of individual animations is\n    adjusted so that the complete animation has the defined run time.\n\nrun_time\n    The duration of the animation in seconds.\nrate_func\n    The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .\n\n    For example ``rate_func(0.5)`` is the proportion of the animation that is done\n    after half of the animations run time.\n\n\nreverse_rate_function\n    Reverses the rate function of the animation. Setting ``reverse_rate_function``\n    does not have any effect on ``remover`` or ``introducer``. These need to be\n    set explicitly if an introducer-animation should be turned into a remover one\n    and vice versa.\nname\n    The name of the animation. This gets displayed while rendering the animation.\n    Defaults to <class-name>(<Mobject-name>).\nremover\n    Whether the given mobject should be removed from the scene after this animation.\nsuspend_mobject_updating\n    Whether updaters of the mobject should be suspended during the animation.\n\n\n.. NOTE::\n\n    In the current implementation of this class, the specified rate function is applied\n    within :meth:`.Animation.interpolate_mobject` call as part of the call to\n    :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`\n    that are implemented by overriding :meth:`interpolate_mobject`, the rate function\n    has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead\n    of just ``alpha``).\n\n\nExamples\n--------\n\n.. manim:: LagRatios\n\n    class LagRatios(Scene):\n        def construct(self):\n            ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n            # Create dot groups\n            group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n            groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n            self.add(groups)\n\n            # Label groups\n            self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n            for group, ratio in zip(groups, ratios):\n                self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n            #Animate groups with different lag_ratios\n            self.play(AnimationGroup(*[\n                group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n                for group, ratio in zip(groups, ratios)\n            ]))\n\n            # lag_ratio also works recursively on nested submobjects:\n            self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
    },
    "Create": {
      "module": "manim.animation.creation",
      "summary": "Incrementally show a VMobject.",
      "bases": [
        "ShowPartial"
      ],
      "methods": {
        "__init__": {
          "signature": "__init__(mobject, lag_ratio=1.0, introducer=True, kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__new__": {
          "signature": "__new__(mobject=None, args, use_override=True, kwargs)",
          "summary": "Create and return a new object.",
          "doc": "Create and return a new object.  See help(type) for accurate signature."
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__str__": {
          "signature": "__str__()",
          "summary": "Return str(self).",
          "doc": "Return str(self)."
        },
        "begin": {
          "signature": "begin()",
          "summary": "Begin the animation.",
          "doc": "Begin the animation.\n\nThis method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod."
        },
        "clean_up_from_scene": {
          "signature": "clean_up_from_scene(scene)",
          "summary": "Clean up the :class:`~.Scene` after finishing the animation.",
          "doc": "Clean up the :class:`~.Scene` after finishing the animation.\n\nThis includes to :meth:`~.Scene.remove` the Animation's\n:class:`~.Mobject` if the animation is a remover.\n\nParameters\n----------\nscene\n    The scene the animation should be cleaned up from."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create a copy of the animation.",
          "doc": "Create a copy of the animation.\n\nReturns\n-------\nAnimation\n    A copy of ``self``"
        },
        "create_starting_mobject": {
          "signature": "create_starting_mobject()",
          "summary": "No documentation available.",
          "doc": null
        },
        "finish": {
          "signature": "finish()",
          "summary": "Finish the animation.",
          "doc": "Finish the animation.\n\nThis method gets called when the animation is over."
        },
        "get_all_families_zipped": {
          "signature": "get_all_families_zipped()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_mobjects": {
          "signature": "get_all_mobjects()",
          "summary": "Get all mobjects involved in the animation.",
          "doc": "Get all mobjects involved in the animation.\n\nOrdering must match the ordering of arguments to interpolate_submobject\n\nReturns\n-------\nSequence[Mobject]\n    The sequence of mobjects."
        },
        "get_all_mobjects_to_update": {
          "signature": "get_all_mobjects_to_update()",
          "summary": "Get all mobjects to be updated during the animation.",
          "doc": "Get all mobjects to be updated during the animation.\n\nReturns\n-------\nList[Mobject]\n    The list of mobjects to be updated during the animation."
        },
        "get_rate_func": {
          "signature": "get_rate_func()",
          "summary": "Get the rate function of the animation.",
          "doc": "Get the rate function of the animation.\n\nReturns\n-------\nCallable[[float], float]\n    The rate function of the animation."
        },
        "get_run_time": {
          "signature": "get_run_time()",
          "summary": "Get the run time of the animation.",
          "doc": "Get the run time of the animation.\n\nReturns\n-------\nfloat\n    The time the animation takes in seconds."
        },
        "get_sub_alpha": {
          "signature": "get_sub_alpha(alpha, index, num_submobjects)",
          "summary": "Get the animation progress of any submobjects subanimation.",
          "doc": "Get the animation progress of any submobjects subanimation.\n\nParameters\n----------\nalpha\n    The overall animation progress\nindex\n    The index of the subanimation.\nnum_submobjects\n    The total count of subanimations.\n\nReturns\n-------\nfloat\n    The progress of the subanimation."
        },
        "interpolate": {
          "signature": "interpolate(alpha)",
          "summary": "Set the animation progress.",
          "doc": "Set the animation progress.\n\nThis method gets called for every frame during an animation.\n\nParameters\n----------\nalpha\n    The relative time to set the animation to, 0 meaning the start, 1 meaning\n    the end."
        },
        "interpolate_mobject": {
          "signature": "interpolate_mobject(alpha)",
          "summary": "Interpolates the mobject of the :class:`Animation` based on alpha value.",
          "doc": "Interpolates the mobject of the :class:`Animation` based on alpha value.\n\nParameters\n----------\nalpha\n    A float between 0 and 1 expressing the ratio to which the animation\n    is completed. For example, alpha-values of 0, 0.5, and 1 correspond\n    to the animation being completed 0%, 50%, and 100%, respectively."
        },
        "interpolate_submobject": {
          "signature": "interpolate_submobject(submobject, starting_submobject, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_introducer": {
          "signature": "is_introducer()",
          "summary": "Test if the animation is an introducer.",
          "doc": "Test if the animation is an introducer.\n\nReturns\n-------\nbool\n    ``True`` if the animation is an introducer, ``False`` otherwise."
        },
        "is_remover": {
          "signature": "is_remover()",
          "summary": "Test if the animation is a remover.",
          "doc": "Test if the animation is a remover.\n\nReturns\n-------\nbool\n    ``True`` if the animation is a remover, ``False`` otherwise."
        },
        "set_name": {
          "signature": "set_name(name)",
          "summary": "Set the name of the animation.",
          "doc": "Set the name of the animation.\n\nParameters\n----------\nname\n    The new name of the animation.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_rate_func": {
          "signature": "set_rate_func(rate_func)",
          "summary": "Set the rate function of the animation.",
          "doc": "Set the rate function of the animation.\n\nParameters\n----------\nrate_func\n    The new function defining the animation progress based on the\n    relative runtime (see :mod:`~.rate_functions`).\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_run_time": {
          "signature": "set_run_time(run_time)",
          "summary": "Set the run time of the animation.",
          "doc": "Set the run time of the animation.\n\nParameters\n----------\nrun_time\n    The new time the animation should take in seconds.\n\n.. note::\n\n    The run_time of an animation should not be changed while it is already\n    running.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "update_mobjects": {
          "signature": "update_mobjects(dt)",
          "summary": "Updates things like starting_mobject, and (for",
          "doc": "Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject."
        }
      },
      "doc": "Incrementally show a VMobject.\n\nParameters\n----------\nmobject\n    The VMobject to animate.\n\nRaises\n------\n:class:`TypeError`\n    If ``mobject`` is not an instance of :class:`~.VMobject`.\n\nExamples\n--------\n.. manim:: CreateScene\n\n    class CreateScene(Scene):\n        def construct(self):\n            self.play(Create(Square()))\n\nSee Also\n--------\n:class:`~.ShowPassingFlash`"
    },
    "FadeOut": {
      "module": "manim.animation.fading",
      "summary": "Fade out :class:`~.Mobject` s.",
      "bases": [
        "_Fade"
      ],
      "methods": {
        "__init__": {
          "signature": "__init__(mobjects, kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__new__": {
          "signature": "__new__(mobject=None, args, use_override=True, kwargs)",
          "summary": "Create and return a new object.",
          "doc": "Create and return a new object.  See help(type) for accurate signature."
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__str__": {
          "signature": "__str__()",
          "summary": "Return str(self).",
          "doc": "Return str(self)."
        },
        "begin": {
          "signature": "begin()",
          "summary": "Begin the animation.",
          "doc": "Begin the animation.\n\nThis method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod."
        },
        "clean_up_from_scene": {
          "signature": "clean_up_from_scene(scene=None)",
          "summary": "Clean up the :class:`~.Scene` after finishing the animation.",
          "doc": "Clean up the :class:`~.Scene` after finishing the animation.\n\nThis includes to :meth:`~.Scene.remove` the Animation's\n:class:`~.Mobject` if the animation is a remover.\n\nParameters\n----------\nscene\n    The scene the animation should be cleaned up from."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create a copy of the animation.",
          "doc": "Create a copy of the animation.\n\nReturns\n-------\nAnimation\n    A copy of ``self``"
        },
        "create_starting_mobject": {
          "signature": "create_starting_mobject()",
          "summary": "No documentation available.",
          "doc": null
        },
        "create_target": {
          "signature": "create_target()",
          "summary": "No documentation available.",
          "doc": null
        },
        "finish": {
          "signature": "finish()",
          "summary": "Finish the animation.",
          "doc": "Finish the animation.\n\nThis method gets called when the animation is over."
        },
        "get_all_families_zipped": {
          "signature": "get_all_families_zipped()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_mobjects": {
          "signature": "get_all_mobjects()",
          "summary": "Get all mobjects involved in the animation.",
          "doc": "Get all mobjects involved in the animation.\n\nOrdering must match the ordering of arguments to interpolate_submobject\n\nReturns\n-------\nSequence[Mobject]\n    The sequence of mobjects."
        },
        "get_all_mobjects_to_update": {
          "signature": "get_all_mobjects_to_update()",
          "summary": "Get all mobjects to be updated during the animation.",
          "doc": "Get all mobjects to be updated during the animation.\n\nReturns\n-------\nList[Mobject]\n    The list of mobjects to be updated during the animation."
        },
        "get_rate_func": {
          "signature": "get_rate_func()",
          "summary": "Get the rate function of the animation.",
          "doc": "Get the rate function of the animation.\n\nReturns\n-------\nCallable[[float], float]\n    The rate function of the animation."
        },
        "get_run_time": {
          "signature": "get_run_time()",
          "summary": "Get the run time of the animation.",
          "doc": "Get the run time of the animation.\n\nReturns\n-------\nfloat\n    The time the animation takes in seconds."
        },
        "get_sub_alpha": {
          "signature": "get_sub_alpha(alpha, index, num_submobjects)",
          "summary": "Get the animation progress of any submobjects subanimation.",
          "doc": "Get the animation progress of any submobjects subanimation.\n\nParameters\n----------\nalpha\n    The overall animation progress\nindex\n    The index of the subanimation.\nnum_submobjects\n    The total count of subanimations.\n\nReturns\n-------\nfloat\n    The progress of the subanimation."
        },
        "interpolate": {
          "signature": "interpolate(alpha)",
          "summary": "Set the animation progress.",
          "doc": "Set the animation progress.\n\nThis method gets called for every frame during an animation.\n\nParameters\n----------\nalpha\n    The relative time to set the animation to, 0 meaning the start, 1 meaning\n    the end."
        },
        "interpolate_mobject": {
          "signature": "interpolate_mobject(alpha)",
          "summary": "Interpolates the mobject of the :class:`Animation` based on alpha value.",
          "doc": "Interpolates the mobject of the :class:`Animation` based on alpha value.\n\nParameters\n----------\nalpha\n    A float between 0 and 1 expressing the ratio to which the animation\n    is completed. For example, alpha-values of 0, 0.5, and 1 correspond\n    to the animation being completed 0%, 50%, and 100%, respectively."
        },
        "interpolate_submobject": {
          "signature": "interpolate_submobject(submobject, starting_submobject, target_copy, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_introducer": {
          "signature": "is_introducer()",
          "summary": "Test if the animation is an introducer.",
          "doc": "Test if the animation is an introducer.\n\nReturns\n-------\nbool\n    ``True`` if the animation is an introducer, ``False`` otherwise."
        },
        "is_remover": {
          "signature": "is_remover()",
          "summary": "Test if the animation is a remover.",
          "doc": "Test if the animation is a remover.\n\nReturns\n-------\nbool\n    ``True`` if the animation is a remover, ``False`` otherwise."
        },
        "set_name": {
          "signature": "set_name(name)",
          "summary": "Set the name of the animation.",
          "doc": "Set the name of the animation.\n\nParameters\n----------\nname\n    The new name of the animation.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_rate_func": {
          "signature": "set_rate_func(rate_func)",
          "summary": "Set the rate function of the animation.",
          "doc": "Set the rate function of the animation.\n\nParameters\n----------\nrate_func\n    The new function defining the animation progress based on the\n    relative runtime (see :mod:`~.rate_functions`).\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_run_time": {
          "signature": "set_run_time(run_time)",
          "summary": "Set the run time of the animation.",
          "doc": "Set the run time of the animation.\n\nParameters\n----------\nrun_time\n    The new time the animation should take in seconds.\n\n.. note::\n\n    The run_time of an animation should not be changed while it is already\n    running.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "update_mobjects": {
          "signature": "update_mobjects(dt)",
          "summary": "Updates things like starting_mobject, and (for",
          "doc": "Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject."
        }
      },
      "doc": "Fade out :class:`~.Mobject` s.\n\nParameters\n----------\nmobjects\n    The mobjects to be faded out.\nshift\n    The vector by which the mobject shifts while being faded out.\ntarget_position\n    The position to which the mobject moves while being faded out. In case another\n    mobject is given as target position, its center is used.\nscale\n    The factor by which the mobject is scaled while being faded out.\n\nExamples\n--------\n\n.. manim :: FadeInExample\n\n    class FadeInExample(Scene):\n        def construct(self):\n            dot = Dot(UP * 2 + LEFT)\n            self.add(dot)\n            tex = Tex(\n                \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n            ).scale(1)\n            animations = [\n                FadeOut(tex[0]),\n                FadeOut(tex[1], shift=DOWN),\n                FadeOut(tex[2], target_position=dot),\n                FadeOut(tex[3], scale=0.5),\n            ]\n            self.play(AnimationGroup(*animations, lag_ratio=0.5))"
    },
    "Transform": {
      "module": "manim.animation.transform",
      "summary": "A Transform transforms a Mobject into a target Mobject.",
      "bases": [
        "Animation"
      ],
      "methods": {
        "__init__": {
          "signature": "__init__(mobject, target_mobject=None, path_func=None, path_arc=0, path_arc_axis=[0. 0. 1.], path_arc_centers=None, replace_mobject_with_target_in_scene=False, kwargs)",
          "summary": "Initialize self.",
          "doc": "Initialize self.  See help(type(self)) for accurate signature."
        },
        "__new__": {
          "signature": "__new__(mobject=None, args, use_override=True, kwargs)",
          "summary": "Create and return a new object.",
          "doc": "Create and return a new object.  See help(type) for accurate signature."
        },
        "__repr__": {
          "signature": "__repr__()",
          "summary": "Return repr(self).",
          "doc": "Return repr(self)."
        },
        "__str__": {
          "signature": "__str__()",
          "summary": "Return str(self).",
          "doc": "Return str(self)."
        },
        "begin": {
          "signature": "begin()",
          "summary": "Begin the animation.",
          "doc": "Begin the animation.\n\nThis method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod."
        },
        "clean_up_from_scene": {
          "signature": "clean_up_from_scene(scene)",
          "summary": "Clean up the :class:`~.Scene` after finishing the animation.",
          "doc": "Clean up the :class:`~.Scene` after finishing the animation.\n\nThis includes to :meth:`~.Scene.remove` the Animation's\n:class:`~.Mobject` if the animation is a remover.\n\nParameters\n----------\nscene\n    The scene the animation should be cleaned up from."
        },
        "copy": {
          "signature": "copy()",
          "summary": "Create a copy of the animation.",
          "doc": "Create a copy of the animation.\n\nReturns\n-------\nAnimation\n    A copy of ``self``"
        },
        "create_starting_mobject": {
          "signature": "create_starting_mobject()",
          "summary": "No documentation available.",
          "doc": null
        },
        "create_target": {
          "signature": "create_target()",
          "summary": "No documentation available.",
          "doc": null
        },
        "finish": {
          "signature": "finish()",
          "summary": "Finish the animation.",
          "doc": "Finish the animation.\n\nThis method gets called when the animation is over."
        },
        "get_all_families_zipped": {
          "signature": "get_all_families_zipped()",
          "summary": "No documentation available.",
          "doc": null
        },
        "get_all_mobjects": {
          "signature": "get_all_mobjects()",
          "summary": "Get all mobjects involved in the animation.",
          "doc": "Get all mobjects involved in the animation.\n\nOrdering must match the ordering of arguments to interpolate_submobject\n\nReturns\n-------\nSequence[Mobject]\n    The sequence of mobjects."
        },
        "get_all_mobjects_to_update": {
          "signature": "get_all_mobjects_to_update()",
          "summary": "Get all mobjects to be updated during the animation.",
          "doc": "Get all mobjects to be updated during the animation.\n\nReturns\n-------\nList[Mobject]\n    The list of mobjects to be updated during the animation."
        },
        "get_rate_func": {
          "signature": "get_rate_func()",
          "summary": "Get the rate function of the animation.",
          "doc": "Get the rate function of the animation.\n\nReturns\n-------\nCallable[[float], float]\n    The rate function of the animation."
        },
        "get_run_time": {
          "signature": "get_run_time()",
          "summary": "Get the run time of the animation.",
          "doc": "Get the run time of the animation.\n\nReturns\n-------\nfloat\n    The time the animation takes in seconds."
        },
        "get_sub_alpha": {
          "signature": "get_sub_alpha(alpha, index, num_submobjects)",
          "summary": "Get the animation progress of any submobjects subanimation.",
          "doc": "Get the animation progress of any submobjects subanimation.\n\nParameters\n----------\nalpha\n    The overall animation progress\nindex\n    The index of the subanimation.\nnum_submobjects\n    The total count of subanimations.\n\nReturns\n-------\nfloat\n    The progress of the subanimation."
        },
        "interpolate": {
          "signature": "interpolate(alpha)",
          "summary": "Set the animation progress.",
          "doc": "Set the animation progress.\n\nThis method gets called for every frame during an animation.\n\nParameters\n----------\nalpha\n    The relative time to set the animation to, 0 meaning the start, 1 meaning\n    the end."
        },
        "interpolate_mobject": {
          "signature": "interpolate_mobject(alpha)",
          "summary": "Interpolates the mobject of the :class:`Animation` based on alpha value.",
          "doc": "Interpolates the mobject of the :class:`Animation` based on alpha value.\n\nParameters\n----------\nalpha\n    A float between 0 and 1 expressing the ratio to which the animation\n    is completed. For example, alpha-values of 0, 0.5, and 1 correspond\n    to the animation being completed 0%, 50%, and 100%, respectively."
        },
        "interpolate_submobject": {
          "signature": "interpolate_submobject(submobject, starting_submobject, target_copy, alpha)",
          "summary": "No documentation available.",
          "doc": null
        },
        "is_introducer": {
          "signature": "is_introducer()",
          "summary": "Test if the animation is an introducer.",
          "doc": "Test if the animation is an introducer.\n\nReturns\n-------\nbool\n    ``True`` if the animation is an introducer, ``False`` otherwise."
        },
        "is_remover": {
          "signature": "is_remover()",
          "summary": "Test if the animation is a remover.",
          "doc": "Test if the animation is a remover.\n\nReturns\n-------\nbool\n    ``True`` if the animation is a remover, ``False`` otherwise."
        },
        "set_name": {
          "signature": "set_name(name)",
          "summary": "Set the name of the animation.",
          "doc": "Set the name of the animation.\n\nParameters\n----------\nname\n    The new name of the animation.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_rate_func": {
          "signature": "set_rate_func(rate_func)",
          "summary": "Set the rate function of the animation.",
          "doc": "Set the rate function of the animation.\n\nParameters\n----------\nrate_func\n    The new function defining the animation progress based on the\n    relative runtime (see :mod:`~.rate_functions`).\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "set_run_time": {
          "signature": "set_run_time(run_time)",
          "summary": "Set the run time of the animation.",
          "doc": "Set the run time of the animation.\n\nParameters\n----------\nrun_time\n    The new time the animation should take in seconds.\n\n.. note::\n\n    The run_time of an animation should not be changed while it is already\n    running.\n\nReturns\n-------\nAnimation\n    ``self``"
        },
        "update_mobjects": {
          "signature": "update_mobjects(dt)",
          "summary": "Updates things like starting_mobject, and (for",
          "doc": "Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject."
        }
      },
      "doc": "A Transform transforms a Mobject into a target Mobject.\n\nParameters\n----------\nmobject\n    The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``.\ntarget_mobject\n    The target of the transformation.\npath_func\n    A function defining the path that the points of the ``mobject`` are being moved\n    along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`.\npath_arc\n    The arc angle (in radians) that the points of ``mobject`` will follow to reach\n    the points of the target if using a circular path arc, see ``path_arc_centers``.\n    See also :func:`manim.utils.paths.path_along_arc`.\npath_arc_axis\n    The axis to rotate along if using a circular path arc, see ``path_arc_centers``.\npath_arc_centers\n    The center of the circular arcs along which the points of ``mobject`` are\n    moved by the transformation.\n\n    If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated\n    using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the\n    other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it.\nreplace_mobject_with_target_in_scene\n    Controls which mobject is replaced when the transformation is complete.\n\n    If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will\n    replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.\n\nExamples\n--------\n\n.. manim :: TransformPathArc\n\n    class TransformPathArc(Scene):\n        def construct(self):\n            def make_arc_path(start, end, arc_angle):\n                points = []\n                p_fn = path_along_arc(arc_angle)\n                # alpha animates between 0.0 and 1.0, where 0.0\n                # is the beginning of the animation and 1.0 is the end.\n                for alpha in range(0, 11):\n                    points.append(p_fn(start, end, alpha / 10.0))\n                path = VMobject(stroke_color=YELLOW)\n                path.set_points_smoothly(points)\n                return path\n\n            left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n            colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n            # Positive angles move counter-clockwise, negative angles move clockwise.\n            examples = [-90, 0, 30, 90, 180, 270]\n            anims = []\n            for idx, angle in enumerate(examples):\n                left_c = left.copy().shift((3 - idx) * UP)\n                left_c.fill_color = colors[idx]\n                right_c = left_c.copy().shift(4 * RIGHT)\n                path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                         arc_angle=angle * DEGREES)\n                desc = Text('%d\u00b0' % examples[idx]).next_to(left_c, LEFT)\n                # Make the circles in front of the text in front of the arcs.\n                self.add(\n                    path_arc.set_z_index(1),\n                    desc.set_z_index(2),\n                    left_c.set_z_index(3),\n                )\n                anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n            self.play(*anims, run_time=2)\n            self.wait()"
    }
  },
  "common_patterns": [
    {
      "pattern": "Creating a basic scene",
      "code": "\nclass MyScene(Scene):\n    def construct(self):\n        # Create objects\n        circle = Circle()\n        # Add objects to the scene\n        self.add(circle)\n        # Animate objects\n        self.play(Create(circle))\n",
      "explanation": "Every Manim animation is a Scene subclass with a construct method."
    },
    {
      "pattern": "Animating objects",
      "code": "\n# Animation basics\nself.play(Create(circle))  # Create animation\nself.play(FadeOut(circle))  # Fade out animation\nself.play(Transform(object1, object2))  # Transform one object into another\n",
      "explanation": "Animations are played using the self.play method."
    },
    {
      "pattern": "Positioning objects",
      "code": "\n# Absolute positioning\ncircle.move_to([1, 2, 0])  # Move to coordinates\n# Relative positioning\nsquare.next_to(circle, RIGHT)  # Position relative to another object\ntriangle.align_to(square, UP)  # Align with another object\n",
      "explanation": "Objects can be positioned absolutely or relative to other objects."
    },
    {
      "pattern": "Creating text",
      "code": "\n# Basic text\ntext = Text(\"Hello Manim\")\n# Mathematical text\nmath = MathTex(r\"e^{i\\pi} + 1 = 0\")\n# Different fonts and styling\nstyled_text = Text(\"Styled\", font=\"Times New Roman\", color=BLUE)\n",
      "explanation": "Manim provides various text objects for regular text and mathematical expressions."
    }
  ]
}
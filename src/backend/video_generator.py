import os
import subprocess
from pathlib import Path
from dotenv import load_dotenv
from backend.generate_script import generate_script
from backend.generate_scenes import generate_all_scenes_from_script
from backend.generate_audio import generate_audio_narration
from config.paths import VIDEO_OUTPUT_DIR
from config.settings import WORDS_PER_MINUTE

load_dotenv()
FFMPEG_PATH = os.path.expanduser("~/bin/ffmpeg")

def safe_slugify(text: str) -> str:
    """Convert text to safe folder name"""
    import re
    text = text.lower()
    text = re.sub(r'[^a-z0-9]+', '-', text)
    return text.strip('-')

def format_srt_time(seconds: float) -> str:
    """Format seconds into SRT timestamp format"""
    hrs, remainder = divmod(int(seconds), 3600)
    mins, secs = divmod(remainder, 60)
    millis = int((seconds - int(seconds)) * 1000)
    return f"{hrs:02}:{mins:02}:{secs:02},{millis:03}"

def generate_subtitle_file(script, output_dir: Path) -> Path:
    """Generate SRT subtitle file using proper timing from settings"""
    srt_path = output_dir / "subtitles.srt"
    
    # Use settings for proper timing
    words_per_second = WORDS_PER_MINUTE / 60
    
    with srt_path.open("w", encoding="utf-8") as f:
        start_time = 0
        counter = 1
        
        for concept in script.concepts:
            word_count = len(concept.narration.split())
            duration = max(word_count / words_per_second, 2)  # Minimum 2 seconds
            end_time = start_time + duration
            
            f.write(f"{counter}\n")
            f.write(f"{format_srt_time(start_time)} --> {format_srt_time(end_time)}\n")
            f.write(concept.narration.strip() + "\n\n")
            
            start_time = end_time
            counter += 1
    
    print(f"âœ… Subtitles generated: {srt_path}")
    return srt_path

def find_concatenated_video(topic: str) -> Path:
    """Find the concatenated video file generated by generate_scenes.py"""
    topic_slug = safe_slugify(topic)
    topic_video_dir = VIDEO_OUTPUT_DIR / topic_slug
    
    # Look for common concatenated video names
    possible_names = ["concatenated.mp4", "final.mp4", "merged.mp4", "output.mp4"]
    
    for name in possible_names:
        video_path = topic_video_dir / name
        if video_path.exists():
            print(f"âœ… Found concatenated video: {video_path}")
            return video_path
    
    # If no standard name found, look for any mp4 that might be the concatenated result
    mp4_files = list(topic_video_dir.glob("*.mp4"))
    if mp4_files:
        # Take the largest file (likely the concatenated one)
        largest_video = max(mp4_files, key=lambda f: f.stat().st_size)
        print(f"âœ… Using largest video file as concatenated video: {largest_video}")
        return largest_video
    
    raise FileNotFoundError(f"No concatenated video found in {topic_video_dir}")

def add_audio_and_subtitles(video_path: Path, audio_path: Path, subtitle_path: Path) -> Path:
    """Add audio track and subtitles to the concatenated video"""
    output_path = video_path.parent / "final_video_with_audio_subtitles.mp4"
    
    cmd = [
        FFMPEG_PATH, "-y",
        "-i", str(video_path)  # Input video
    ]
    
    # Add audio if available
    if audio_path and audio_path.exists():
        cmd += ["-i", str(audio_path)]
        audio_map = ["-c:a", "aac", "-map", "0:v:0", "-map", "1:a:0"]
    else:
        print("âš ï¸ No audio file found, proceeding without audio")
        audio_map = ["-map", "0:v:0"]
    
    # Add subtitle filter if available
    if subtitle_path and subtitle_path.exists():
        cmd += ["-vf", f"subtitles={subtitle_path}"]
    else:
        print("âš ï¸ No subtitle file found, proceeding without subtitles")
    
    # Finalize command
    cmd += audio_map + ["-c:v", "libx264", str(output_path)]
    
    print(f"ğŸ¬ Running ffmpeg command...")
    print(f"Command: {' '.join(cmd)}")
    
    try:
        subprocess.run(cmd, check=True, capture_output=True, text=True)
        print(f"âœ… Final video created: {output_path}")
        return output_path
    except subprocess.CalledProcessError as e:
        print(f"âŒ FFmpeg failed: {e.stderr}")
        raise

def make_video(topic: str, level: int = 2, duration: int = 10, dry_run: bool = False):
    """
    Generate complete video with scenes, audio, and subtitles
    
    Args:
        topic: Educational topic/question
        level: Sophistication level (1-3)
        duration: Duration in minutes
        dry_run: If True, skip actual audio generation
    """
    print("=" * 50)
    print(f"ğŸ¥ GENERATING VIDEO: {topic}")
    print("=" * 50)
    
    # Step 1: Generate script
    print("\nğŸ“œ Step 1: Generating script...")
    script = generate_script(topic="Teach me what an integral is", duration_minutes=duration, sophistication_level=level)
    print(f"âœ… Script generated with {len(script.concepts)} concepts")
    
    # Step 2: Generate and concatenate scenes
    print("\nğŸ¬ Step 2: Generating scenes...")
    generate_all_scenes_from_script(script)
    print("âœ… Scenes generated and concatenated")
    
    # Step 3: Find the concatenated video
    print("\nğŸ” Step 3: Finding concatenated video...")
    concatenated_video = find_concatenated_video(topic)
    
    # Step 4: Generate audio narration
    print("\nğŸ”Š Step 4: Generating audio narration...")
    narrator_script = "\n\n".join([c.narration for c in script.concepts])
    audio_path = generate_audio_narration(
        text=narrator_script, 
        filename="narration.mp3", 
        dry_run=dry_run
    )
    if audio_path:
        print(f"âœ… Audio generated: {audio_path}")
    
    # Step 5: Generate subtitles
    print("\nğŸ“ Step 5: Generating subtitles...")
    topic_slug = safe_slugify(topic)
    topic_video_dir = VIDEO_OUTPUT_DIR / topic_slug
    subtitle_path = generate_subtitle_file(script, topic_video_dir)
    
    # Step 6: Combine everything
    print("\nğŸ¯ Step 6: Adding audio and subtitles to video...")
    final_output = add_audio_and_subtitles(concatenated_video, audio_path, subtitle_path)
    
    print("\n" + "=" * 50)
    print("ğŸ‰ VIDEO GENERATION COMPLETE!")
    print(f"ğŸ“ Final video: {final_output}")
    print(f"ğŸ¬ Scenes: {len(script.concepts)} concepts")
    print(f"â±ï¸  Expected duration: ~{duration} minutes")
    print("=" * 50)
    
    return final_output

if __name__ == "__main__":
    # Example usage
    make_video("Teach me what a derivative is?", level=2, duration=10)